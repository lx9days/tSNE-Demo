{"version":3,"file":"js/app.eb456f77.js","mappings":"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","sources":["webpack://webpack-starter/webpack/runtime/chunk loaded","webpack://webpack-starter/../Libra/dist/esm/command/command.js","webpack://webpack-starter/../Libra/dist/esm/command/index.js","webpack://webpack-starter/../Libra/dist/esm/helpers.js","webpack://webpack-starter/../Libra/dist/esm/history/index.js","webpack://webpack-starter/../Libra/dist/esm/instrument/builtin.js","webpack://webpack-starter/../Libra/dist/esm/instrument/index.js","webpack://webpack-starter/../Libra/dist/esm/instrument/instrument.js","webpack://webpack-starter/../Libra/dist/esm/interactor/builtin.js","webpack://webpack-starter/../Libra/dist/esm/interactor/index.js","webpack://webpack-starter/../Libra/dist/esm/interactor/interactor.js","webpack://webpack-starter/../Libra/dist/esm/interactor/actions.jsgf.js","webpack://webpack-starter/../Libra/dist/esm/layer/layer.js","webpack://webpack-starter/../Libra/dist/esm/layer/d3Layer.js","webpack://webpack-starter/../Libra/dist/esm/layer/vegaLayer.js","webpack://webpack-starter/../Libra/dist/esm/layer/plotLayer.js","webpack://webpack-starter/../Libra/dist/esm/layer/index.js","webpack://webpack-starter/../Libra/dist/esm/service/layoutService.js","webpack://webpack-starter/../Libra/dist/esm/service/algorithmService.js","webpack://webpack-starter/../Libra/dist/esm/service/index.js","webpack://webpack-starter/../Libra/dist/esm/service/selectionService.js","webpack://webpack-starter/../Libra/dist/esm/service/service.js","webpack://webpack-starter/../Libra/dist/esm/transformer/transformer.js","webpack://webpack-starter/../Libra/dist/esm/transformer/builtin.js","webpack://webpack-starter/../Libra/dist/esm/transformer/index.js","webpack://webpack-starter/../Libra/dist/esm/interaction/index.js","webpack://webpack-starter/../Libra/dist/esm/index.js","webpack://webpack-starter/./src/scripts/index.js","webpack://webpack-starter/webpack/bootstrap","webpack://webpack-starter/webpack/runtime/define property getters","webpack://webpack-starter/webpack/runtime/global","webpack://webpack-starter/webpack/runtime/hasOwnProperty shorthand","webpack://webpack-starter/webpack/runtime/make namespace object","webpack://webpack-starter/webpack/runtime/jsonp chunk loading","webpack://webpack-starter/webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var _a;\r\nimport * as helpers from \"../helpers\";\r\nlet tryGetHistoryTrrackInstance;\r\nconst registeredCommands = {};\r\nexport const instanceCommands = [];\r\nexport default class Command {\r\n    constructor(baseName, options) {\r\n        this[_a] = true;\r\n        options.preInitialize && options.preInitialize.call(this, this);\r\n        this._baseName = baseName;\r\n        this._userOptions = options;\r\n        this._name = options.name ?? baseName;\r\n        this._feedback = options.feedback ?? [];\r\n        this._undo = options.undo ?? null;\r\n        this._redo = options.redo ?? null;\r\n        this._execute = options.execute ?? null;\r\n        this._preInitialize = options.preInitialize ?? null;\r\n        this._postInitialize = options.postInitialize ?? null;\r\n        this._preExecute = options.preExecute ?? null;\r\n        this._postExecute = options.postExecute ?? null;\r\n        options.postInitialize && options.postInitialize.call(this, this);\r\n    }\r\n    undo() {\r\n        this._undo && this._undo.call(this);\r\n    }\r\n    redo() {\r\n        this._redo && this._redo.call(this);\r\n    }\r\n    async execute(options) {\r\n        try {\r\n            this.preExecute();\r\n            this._execute && (await this._execute.call(this, options));\r\n            this.postExecute();\r\n            for (let feedback of this._feedback) {\r\n                await feedback.call(this, options);\r\n            }\r\n            await tryGetHistoryTrrackInstance(this).commit(this._name);\r\n        }\r\n        catch (e) {\r\n            console.error(e);\r\n        }\r\n    }\r\n    preExecute() {\r\n        this._preExecute && this._preExecute.call(this, this);\r\n    }\r\n    postExecute() {\r\n        this._postExecute && this._postExecute.call(this, this);\r\n    }\r\n    isInstanceOf(name) {\r\n        return this._baseName === name || this._name === name;\r\n    }\r\n    static register(baseName, options) {\r\n        registeredCommands[baseName] = options;\r\n    }\r\n    static unregister(baseName) {\r\n        delete registeredCommands[baseName];\r\n        return true;\r\n    }\r\n    static initialize(baseName, options) {\r\n        const mergedOptions = Object.assign({ constructor: Command }, registeredCommands[baseName] ?? {}, options ?? {});\r\n        const command = new mergedOptions.constructor(baseName, mergedOptions);\r\n        instanceCommands.push(command);\r\n        return command;\r\n    }\r\n    static findCommand(baseNameOrRealName) {\r\n        return instanceCommands.filter((command) => command.isInstanceOf(baseNameOrRealName));\r\n    }\r\n}\r\n_a = helpers.LibraSymbol;\r\nexport const register = Command.register;\r\nexport const unregister = Command.unregister;\r\nexport const initialize = Command.initialize;\r\nexport const findCommand = Command.findCommand;\r\nimport(\"../history\").then((HM) => {\r\n    tryGetHistoryTrrackInstance = HM.tryGetHistoryTrrackInstance;\r\n});\r\n","import * as CommandConstructor from \"./command\";\r\nimport CommandClass from \"./command\";\r\nexport default CommandClass;\r\nexport const register = CommandConstructor.register;\r\nexport const initialize = CommandConstructor.initialize;\r\nexport const findCommand = CommandConstructor.findCommand;\r\nexport const instanceCommands = CommandConstructor.instanceCommands;\r\nexport const Command = CommandClass;\r\n","export const LibraSymbol = Symbol(\"Libra\");\r\nexport var QueryType;\r\n(function (QueryType) {\r\n    QueryType[QueryType[\"Shape\"] = 0] = \"Shape\";\r\n    QueryType[QueryType[\"Data\"] = 1] = \"Data\";\r\n    QueryType[QueryType[\"Attr\"] = 2] = \"Attr\";\r\n})(QueryType || (QueryType = {}));\r\nexport var ShapeQueryType;\r\n(function (ShapeQueryType) {\r\n    ShapeQueryType[ShapeQueryType[\"SurfacePoint\"] = 0] = \"SurfacePoint\";\r\n    ShapeQueryType[ShapeQueryType[\"Point\"] = 1] = \"Point\";\r\n    ShapeQueryType[ShapeQueryType[\"Circle\"] = 2] = \"Circle\";\r\n    ShapeQueryType[ShapeQueryType[\"Rect\"] = 3] = \"Rect\";\r\n    ShapeQueryType[ShapeQueryType[\"Polygon\"] = 4] = \"Polygon\";\r\n})(ShapeQueryType || (ShapeQueryType = {}));\r\nexport var DataQueryType;\r\n(function (DataQueryType) {\r\n    DataQueryType[DataQueryType[\"Quantitative\"] = 0] = \"Quantitative\";\r\n    DataQueryType[DataQueryType[\"Nominal\"] = 1] = \"Nominal\";\r\n    DataQueryType[DataQueryType[\"Temporal\"] = 2] = \"Temporal\";\r\n})(DataQueryType || (DataQueryType = {}));\r\nclass NonsenseClass {\r\n}\r\nlet tryRegisterDynamicInstance = (...args) => { };\r\nexport function makeFindableList(list, typing, addFunc, removeFunc, self) {\r\n    return new Proxy(list, {\r\n        get(target, p) {\r\n            if (p === \"find\") {\r\n                return function (name, defaultValue) {\r\n                    if (!(\"initialize\" in typing)) {\r\n                        const filteredResult = target.slice();\r\n                        filteredResult.forEach((newTarget) => {\r\n                            newTarget.find(...arguments);\r\n                        });\r\n                        return makeFindableList(filteredResult, typing, addFunc, removeFunc, self);\r\n                    }\r\n                    else {\r\n                        const filteredResult = target.filter((item) => item.isInstanceOf(name));\r\n                        if (filteredResult.length <= 0 && defaultValue) {\r\n                            const newElement = typing.initialize(defaultValue);\r\n                            addFunc(newElement);\r\n                            filteredResult.push(newElement);\r\n                            tryRegisterDynamicInstance(self, newElement);\r\n                        }\r\n                        return makeFindableList(filteredResult, typing, addFunc, removeFunc, self);\r\n                    }\r\n                };\r\n            }\r\n            else if (p === \"add\") {\r\n                return (...args) => {\r\n                    const filteredResult = target.slice();\r\n                    if (!(\"initialize\" in typing)) {\r\n                        filteredResult.forEach((newTarget) => {\r\n                            newTarget.add(...args);\r\n                        });\r\n                        return makeFindableList(filteredResult, typing, addFunc, removeFunc, self);\r\n                    }\r\n                    else {\r\n                        const newElement = typing.initialize(...args);\r\n                        addFunc(newElement);\r\n                        filteredResult.push(newElement);\r\n                        tryRegisterDynamicInstance(self, newElement);\r\n                        return makeFindableList(filteredResult, typing, addFunc, removeFunc, self);\r\n                    }\r\n                };\r\n            }\r\n            else if (p === \"remove\") {\r\n                return (name) => {\r\n                    if (typing === NonsenseClass) {\r\n                        const filteredResult = target.slice();\r\n                        filteredResult.forEach((newTarget) => {\r\n                            newTarget.remove(name);\r\n                        });\r\n                        return makeFindableList(filteredResult, typing, addFunc, removeFunc, self);\r\n                    }\r\n                    else {\r\n                        const origin = target.slice();\r\n                        const filteredResult = origin.filter((item) => item.isInstanceOf(name));\r\n                        filteredResult.forEach((item) => {\r\n                            removeFunc(item);\r\n                            origin.splice(origin.indexOf(item), 1);\r\n                        });\r\n                        return makeFindableList(origin, typing, addFunc, removeFunc, self);\r\n                    }\r\n                };\r\n            }\r\n            else if (p in target && p !== \"join\" && p !== \"filter\") {\r\n                return target[p];\r\n            }\r\n            else {\r\n                if (!target.length) {\r\n                    const f = () => { };\r\n                    f[Symbol.iterator] = function* () { };\r\n                    return f;\r\n                }\r\n                else if (target[0][p] instanceof Function) {\r\n                    return function () {\r\n                        return makeFindableList(target.map((t) => t[p].apply(t, arguments)), NonsenseClass, () => { }, () => { }, self);\r\n                    };\r\n                }\r\n                else {\r\n                    return makeFindableList(target.map((t) => t[p]), NonsenseClass, () => { }, () => { }, self);\r\n                }\r\n            }\r\n        },\r\n    });\r\n}\r\nexport function getTransform(elem) {\r\n    try {\r\n        const transform = elem\r\n            .getAttribute(\"transform\")\r\n            .split(\"(\")[1]\r\n            .split(\")\")[0]\r\n            .split(\",\")\r\n            .map((i) => parseFloat(i));\r\n        return transform;\r\n    }\r\n    catch (e) {\r\n        return [0, 0];\r\n    }\r\n}\r\n/**\r\n * Parse an event selector string.\r\n * Returns an array of event stream definitions.\r\n */\r\nexport function parseEventSelector(selector) {\r\n    return parseMerge(selector.trim()).map(parseSelector);\r\n}\r\nconst VIEW = \"view\", LBRACK = \"[\", RBRACK = \"]\", LBRACE = \"{\", RBRACE = \"}\", COLON = \":\", COMMA = \",\", NAME = \"@\", GT = \">\", ILLEGAL = /[[\\]{}]/, DEFAULT_SOURCE = VIEW, DEFAULT_MARKS = {\r\n    \"*\": 1,\r\n    arc: 1,\r\n    area: 1,\r\n    group: 1,\r\n    image: 1,\r\n    line: 1,\r\n    path: 1,\r\n    rect: 1,\r\n    rule: 1,\r\n    shape: 1,\r\n    symbol: 1,\r\n    text: 1,\r\n    trail: 1,\r\n}, MARKS = DEFAULT_MARKS;\r\nfunction isMarkType(type) {\r\n    return MARKS.hasOwnProperty(type);\r\n}\r\nfunction find(s, i, endChar, pushChar, popChar) {\r\n    let count = 0, c;\r\n    const n = s.length;\r\n    for (; i < n; ++i) {\r\n        c = s[i];\r\n        if (!count && c === endChar)\r\n            return i;\r\n        else if (popChar && popChar.indexOf(c) >= 0)\r\n            --count;\r\n        else if (pushChar && pushChar.indexOf(c) >= 0)\r\n            ++count;\r\n    }\r\n    return i;\r\n}\r\nfunction parseMerge(s) {\r\n    const output = [], n = s.length;\r\n    let start = 0, i = 0;\r\n    while (i < n) {\r\n        i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);\r\n        output.push(s.substring(start, i).trim());\r\n        start = ++i;\r\n    }\r\n    if (output.length === 0) {\r\n        throw \"Empty event selector: \" + s;\r\n    }\r\n    return output;\r\n}\r\nfunction parseSelector(s) {\r\n    return s[0] === \"[\" ? parseBetween(s) : parseStream(s);\r\n}\r\nfunction parseBetween(s) {\r\n    const n = s.length;\r\n    let i = 1, b, stream;\r\n    i = find(s, i, RBRACK, LBRACK, RBRACK);\r\n    if (i === n) {\r\n        throw \"Empty between selector: \" + s;\r\n    }\r\n    b = parseMerge(s.substring(1, i));\r\n    if (b.length !== 2) {\r\n        throw \"Between selector must have two elements: \" + s;\r\n    }\r\n    s = s.slice(i + 1).trim();\r\n    if (s[0] !== GT) {\r\n        throw \"Expected '>' after between selector: \" + s;\r\n    }\r\n    const bt = b.map(parseSelector);\r\n    stream = parseSelector(s.slice(1).trim());\r\n    if (stream.between) {\r\n        return {\r\n            between: bt,\r\n            stream: stream,\r\n        };\r\n    }\r\n    else {\r\n        stream.between = bt;\r\n    }\r\n    return stream;\r\n}\r\nfunction parseStream(s) {\r\n    const stream = {\r\n        source: DEFAULT_SOURCE,\r\n        type: \"\",\r\n    }, source = [];\r\n    let throttle = [0, 0], markname = 0, start = 0, n = s.length, i = 0, j, filter;\r\n    // extract throttle from end\r\n    if (s[n - 1] === RBRACE) {\r\n        i = s.lastIndexOf(LBRACE);\r\n        if (i >= 0) {\r\n            try {\r\n                throttle = parseThrottle(s.substring(i + 1, n - 1));\r\n            }\r\n            catch (e) {\r\n                throw \"Invalid throttle specification: \" + s;\r\n            }\r\n            s = s.slice(0, i).trim();\r\n            n = s.length;\r\n        }\r\n        else\r\n            throw \"Unmatched right brace: \" + s;\r\n        i = 0;\r\n    }\r\n    if (!n)\r\n        throw s;\r\n    // set name flag based on first char\r\n    if (s[0] === NAME)\r\n        markname = ++i;\r\n    // extract first part of multi-part stream selector\r\n    j = find(s, i, COLON);\r\n    if (j < n) {\r\n        source.push(s.substring(start, j).trim());\r\n        start = i = ++j;\r\n    }\r\n    // extract remaining part of stream selector\r\n    i = find(s, i, LBRACK);\r\n    if (i === n) {\r\n        source.push(s.substring(start, n).trim());\r\n    }\r\n    else {\r\n        source.push(s.substring(start, i).trim());\r\n        filter = [];\r\n        start = ++i;\r\n        if (start === n)\r\n            throw \"Unmatched left bracket: \" + s;\r\n    }\r\n    // extract filters\r\n    while (i < n) {\r\n        i = find(s, i, RBRACK);\r\n        if (i === n)\r\n            throw \"Unmatched left bracket: \" + s;\r\n        filter.push(s.substring(start, i).trim());\r\n        if (i < n - 1 && s[++i] !== LBRACK)\r\n            throw \"Expected left bracket: \" + s;\r\n        start = ++i;\r\n    }\r\n    // marshall event stream specification\r\n    if (!(n = source.length) || ILLEGAL.test(source[n - 1])) {\r\n        throw \"Invalid event selector: \" + s;\r\n    }\r\n    if (n > 1) {\r\n        stream.type = source[1];\r\n        if (markname) {\r\n            stream.markname = source[0].slice(1);\r\n        }\r\n        else if (isMarkType(source[0])) {\r\n            stream.marktype = source[0];\r\n        }\r\n        else {\r\n            stream.source = source[0];\r\n        }\r\n    }\r\n    else {\r\n        stream.type = source[0];\r\n    }\r\n    if (stream.type.slice(-1) === \"!\") {\r\n        stream.consume = true;\r\n        stream.type = stream.type.slice(0, -1);\r\n    }\r\n    if (filter != null)\r\n        stream.filter = filter;\r\n    if (throttle[0])\r\n        stream.throttle = throttle[0];\r\n    if (throttle[1])\r\n        stream.debounce = throttle[1];\r\n    return stream;\r\n}\r\nfunction parseThrottle(s) {\r\n    const a = s.split(COMMA);\r\n    if (!s.length || a.length > 2)\r\n        throw s;\r\n    return a.map(function (_) {\r\n        const x = +_;\r\n        if (x !== x)\r\n            throw s;\r\n        return x;\r\n    });\r\n}\r\nexport function deepClone(obj) {\r\n    if (obj &&\r\n        obj instanceof Object &&\r\n        \"copy\" in obj &&\r\n        obj.copy instanceof Function) {\r\n        const nodeCopy = obj.copy();\r\n        // Assign other custom properties to the node\r\n        for (let key in Object.getOwnPropertyDescriptors(obj)) {\r\n            if (!(key in nodeCopy)) {\r\n                nodeCopy[key] = obj[key];\r\n            }\r\n        }\r\n        return nodeCopy;\r\n    }\r\n    if (obj instanceof Array) {\r\n        return obj.map(deepClone);\r\n    }\r\n    if ([\r\n        \"string\",\r\n        \"number\",\r\n        \"boolean\",\r\n        \"undefined\",\r\n        \"bigint\",\r\n        \"symbol\",\r\n        \"function\",\r\n    ].includes(typeof obj)) {\r\n        return obj;\r\n    }\r\n    if (obj === null)\r\n        return null;\r\n    if (LibraSymbol in obj && obj[LibraSymbol]) {\r\n        return obj;\r\n    }\r\n    if (obj instanceof Node) {\r\n        const nodeCopy = obj.cloneNode(true);\r\n        // Assign other custom properties to the node (e.g., __data__ from D3)\r\n        Object.assign(nodeCopy, obj);\r\n        return nodeCopy;\r\n    }\r\n    const propertyObject = Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, deepClone(v)]));\r\n    return Object.assign(Object.create(Object.getPrototypeOf(obj)), propertyObject);\r\n}\r\nexport const global = {\r\n    stopTransient: false,\r\n};\r\nimport(\"./history\").then((HM) => {\r\n    tryRegisterDynamicInstance = HM.tryRegisterDynamicInstance;\r\n});\r\n","import { instanceServices } from \"../service\";\r\nimport { instanceTransformers } from \"../transformer\";\r\nimport { instanceCommands } from \"../command\";\r\nimport { instanceInstruments } from \"../instrument\";\r\nimport { instanceInteractors } from \"../interactor\";\r\nimport { deepClone } from \"../helpers\";\r\nconst historyInstanceMapping = new Map();\r\nexport async function createHistoryTrrack() {\r\n    let historyTrace = null;\r\n    let currentHistoryNode = null;\r\n    let commitLock = false;\r\n    const HistoryManager = {\r\n        traceStructure: (node = historyTrace) => {\r\n            return {\r\n                recordList: [...node.record.keys()],\r\n                children: node.children.map((node) => HistoryManager.traceStructure(node)),\r\n                current: node === currentHistoryNode,\r\n            };\r\n        },\r\n        commit: async (commandName) => {\r\n            if (commitLock) {\r\n                return;\r\n            }\r\n            const record = new Map();\r\n            for (let { component, fields } of [\r\n                { list: instanceInteractors, fields: [\"_state\", \"_modalities\"] },\r\n                { list: instanceInstruments, fields: [\"_sharedVar\"] },\r\n                { list: instanceServices, fields: [\"_sharedVar\", \"_result\", \"_oldResult\"] },\r\n                { list: instanceTransformers, fields: [\"_sharedVar\"] },\r\n            ].flatMap(({ list, fields, }) => list\r\n                .filter((component) => tryGetHistoryTrrackInstance(component) === HistoryManager)\r\n                .map((component) => ({ component, fields })))) {\r\n                await component.results; // Ensure all works have been done\r\n                record.set(component, Object.fromEntries(fields.map((field) => [field, deepClone(component[field])])));\r\n            }\r\n            // If push not default command, then override back.\r\n            if (commandName && commandName != \"Log\") {\r\n                const checkParent = (historyNode) => {\r\n                    if (historyNode.name === 'Log' && historyNode.prev && historyNode.prev.children.length == 1) {\r\n                        historyNode.prev.children = [];\r\n                        return checkParent(historyNode.prev);\r\n                    }\r\n                    if (historyNode.name === 'Log' && historyNode.prev) {\r\n                        historyNode.prev.children.splice(historyNode.prev.children.indexOf(historyNode), 1);\r\n                        return checkParent(historyNode.prev);\r\n                    }\r\n                    return historyNode;\r\n                };\r\n                currentHistoryNode = checkParent(currentHistoryNode);\r\n            }\r\n            const newHistoryNode = {\r\n                name: commandName,\r\n                record,\r\n                prev: currentHistoryNode,\r\n                next: null,\r\n                children: [],\r\n            };\r\n            if (currentHistoryNode) {\r\n                currentHistoryNode.children.push(newHistoryNode);\r\n            }\r\n            currentHistoryNode = newHistoryNode;\r\n        },\r\n        async undo() {\r\n            if (currentHistoryNode && currentHistoryNode.prev) {\r\n                currentHistoryNode.prev.next = currentHistoryNode;\r\n                const record = currentHistoryNode.prev.record;\r\n                commitLock = true;\r\n                // try {\r\n                for (let [component, records] of record.entries()) {\r\n                    let layerHold = null;\r\n                    if (\"_sharedVar\" in component && component._sharedVar.layer) {\r\n                        layerHold = component._sharedVar.layer;\r\n                    }\r\n                    Object.entries(records).forEach(([k, v]) => (component[k] = deepClone(v)));\r\n                    if (layerHold &&\r\n                        \"_sharedVar\" in component &&\r\n                        !component._sharedVar.layer) {\r\n                        component._sharedVar.layer = layerHold;\r\n                    }\r\n                    if (\"_sharedVar\" in records) {\r\n                        // Invoke update manually\r\n                        await component.setSharedVar(\"$LIBRA_FORCE_UPDATE\", undefined);\r\n                    }\r\n                }\r\n                currentHistoryNode = currentHistoryNode.prev;\r\n                // } catch (e) {\r\n                //   console.error(\"Fail to undo history!\", e);\r\n                //   // Rollback\r\n                //   const record = currentHistoryNode.record;\r\n                //   for (let [component, records] of record.entries()) {\r\n                //     Object.entries(records).forEach(\r\n                //       ([k, v]) => (component[k] = deepClone(v))\r\n                //     );\r\n                //     if (\"_sharedVar\" in records) {\r\n                //       // Invoke update manually\r\n                //       await (\r\n                //         component as RecordingComponentsWithSharedVariables\r\n                //       ).setSharedVar(\"$LIBRA_FORCE_UPDATE\", undefined);\r\n                //     }\r\n                //   }\r\n                // }\r\n                commitLock = false;\r\n            }\r\n        },\r\n        async redo() {\r\n            if (currentHistoryNode &&\r\n                currentHistoryNode.children.length === 1 &&\r\n                !currentHistoryNode.next) {\r\n                currentHistoryNode.next = currentHistoryNode.children[0];\r\n            }\r\n            if (currentHistoryNode && currentHistoryNode.next) {\r\n                const record = currentHistoryNode.next.record;\r\n                commitLock = true;\r\n                try {\r\n                    for (let [component, records] of record.entries()) {\r\n                        let layerHold = null;\r\n                        if (\"_sharedVar\" in component && component._sharedVar.layer) {\r\n                            layerHold = component._sharedVar.layer;\r\n                        }\r\n                        Object.entries(records).forEach(([k, v]) => (component[k] = deepClone(v)));\r\n                        if (layerHold &&\r\n                            \"_sharedVar\" in component &&\r\n                            !component._sharedVar.layer) {\r\n                            component._sharedVar.layer = layerHold;\r\n                        }\r\n                        if (\"_sharedVar\" in records) {\r\n                            // Invoke update manually\r\n                            await component.setSharedVar(\"$LIBRA_FORCE_UPDATE\", undefined);\r\n                        }\r\n                    }\r\n                    currentHistoryNode = currentHistoryNode.next;\r\n                }\r\n                catch (e) {\r\n                    console.error(\"Fail to redo history!\", e);\r\n                    // Rollback\r\n                    const record = currentHistoryNode.record;\r\n                    for (let [component, records] of record.entries()) {\r\n                        Object.entries(records).forEach(([k, v]) => (component[k] = deepClone(v)));\r\n                        if (\"_sharedVar\" in records) {\r\n                            // Invoke update manually\r\n                            await component.setSharedVar(\"$LIBRA_FORCE_UPDATE\", undefined);\r\n                        }\r\n                    }\r\n                }\r\n                commitLock = false;\r\n            }\r\n        },\r\n        async jump(path = []) {\r\n            const targetNode = path.reduce((p, v) => p?.children[v], historyTrace);\r\n            if (targetNode) {\r\n                const record = targetNode.record;\r\n                commitLock = true;\r\n                try {\r\n                    for (let [component, records] of record.entries()) {\r\n                        let layerHold = null;\r\n                        if (\"_sharedVar\" in component && component._sharedVar.layer) {\r\n                            layerHold = component._sharedVar.layer;\r\n                        }\r\n                        Object.entries(records).forEach(([k, v]) => (component[k] = deepClone(v)));\r\n                        if (layerHold &&\r\n                            \"_sharedVar\" in component &&\r\n                            !component._sharedVar.layer) {\r\n                            component._sharedVar.layer = layerHold;\r\n                        }\r\n                        if (\"_sharedVar\" in records) {\r\n                            // Invoke update manually\r\n                            await component.setSharedVar(\"$LIBRA_FORCE_UPDATE\", undefined);\r\n                        }\r\n                    }\r\n                    currentHistoryNode = targetNode;\r\n                }\r\n                catch (e) {\r\n                    console.error(\"Fail to jump history!\", e);\r\n                    // Rollback\r\n                    const record = currentHistoryNode.record;\r\n                    for (let [component, records] of record.entries()) {\r\n                        Object.entries(records).forEach(([k, v]) => (component[k] = deepClone(v)));\r\n                        if (\"_sharedVar\" in records) {\r\n                            // Invoke update manually\r\n                            await component.setSharedVar(\"$LIBRA_FORCE_UPDATE\", undefined);\r\n                        }\r\n                    }\r\n                }\r\n                commitLock = false;\r\n            }\r\n            else {\r\n                console.error(`History path [${path.join(\", \")}] does not exist!`);\r\n            }\r\n        },\r\n    };\r\n    [\r\n        instanceServices,\r\n        instanceTransformers,\r\n        instanceCommands,\r\n        instanceInstruments,\r\n        instanceInteractors,\r\n    ]\r\n        .flatMap((x) => x)\r\n        .forEach((component) => {\r\n        if (!historyInstanceMapping.has(component)) {\r\n            historyInstanceMapping.set(component, HistoryManager);\r\n        }\r\n    });\r\n    await HistoryManager.commit();\r\n    historyTrace = currentHistoryNode;\r\n    return HistoryManager;\r\n}\r\nexport function tryGetHistoryTrrackInstance(component) {\r\n    const directHM = historyInstanceMapping.get(component);\r\n    if (directHM) {\r\n        return directHM;\r\n    }\r\n    // Otherwise, return a mimic HM that does nothing\r\n    return {\r\n        traceStructure() {\r\n            return null;\r\n        },\r\n        async commit() { },\r\n        async undo() { },\r\n        async redo() { },\r\n    };\r\n}\r\nexport function tryRegisterDynamicInstance(parentComponent, newComponent) {\r\n    const HM = historyInstanceMapping.get(parentComponent);\r\n    if (HM) {\r\n        historyInstanceMapping.set(newComponent, HM);\r\n    }\r\n}\r\n","import Instrument from \"./instrument\";\r\nimport GraphicalTransformer from \"../transformer\";\r\nimport { getTransform } from \"../helpers\";\r\nimport * as d3 from \"d3\";\r\nimport Command from \"../command/command\";\r\nInstrument.register(\"HoverInstrument\", {\r\n    constructor: Instrument,\r\n    interactors: [\"MousePositionInteractor\", \"TouchPositionInteractor\"],\r\n    on: {\r\n        hover: [\r\n            async ({ event, layer, instrument }) => {\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                const services = instrument.services.find(\"SelectionService\");\r\n                services.setSharedVars({\r\n                    event,\r\n                    x: event.clientX,\r\n                    y: event.clientY,\r\n                    offsetx: event.offsetX,\r\n                    offsety: event.offsetY,\r\n                }, { layer });\r\n                const transformers = instrument.transformers;\r\n                transformers.setSharedVars({ cx: event.clientX, cy: event.clientY });\r\n            },\r\n        ],\r\n        click: [Command.initialize(\"Log\", { execute() { } })],\r\n    },\r\n    postInitialize: (instrument) => {\r\n        instrument.services.add(\"SurfacePointSelectionService\", {\r\n            // layer,\r\n            sharedVar: {\r\n                deepClone: instrument.getSharedVar(\"deepClone\"),\r\n                highlightColor: instrument.getSharedVar(\"highlightColor\"),\r\n                highlightAttrValues: instrument.getSharedVar(\"highlightAttrValues\"),\r\n                tooltip: instrument.getSharedVar(\"tooltip\"),\r\n            },\r\n        });\r\n    },\r\n    preAttach: (instrument, layer) => {\r\n        instrument.services.add(\"SurfacePointSelectionService\", {\r\n            layer,\r\n            sharedVar: {\r\n                deepClone: instrument.getSharedVar(\"deepClone\"),\r\n                highlightColor: instrument.getSharedVar(\"highlightColor\"),\r\n                highlightAttrValues: instrument.getSharedVar(\"highlightAttrValues\"),\r\n                tooltip: instrument.getSharedVar(\"tooltip\"),\r\n                data: instrument.getSharedVar(\"data\"),\r\n            },\r\n        });\r\n    },\r\n});\r\nInstrument.register(\"ClickInstrument\", {\r\n    constructor: Instrument,\r\n    interactors: [\"MouseTraceInteractor\", \"TouchTraceInteractor\"],\r\n    on: {\r\n        dragstart: [\r\n            async (options) => {\r\n                let { event, layer, instrument } = options;\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                instrument.setSharedVar(\"x\", event.clientX);\r\n                instrument.setSharedVar(\"y\", event.clientY);\r\n                const services = instrument.services.find(\"SelectionService\");\r\n                services.setSharedVars({\r\n                    x: event.clientX,\r\n                    y: event.clientY,\r\n                    offsetx: event.offsetX,\r\n                    offsety: event.offsetY,\r\n                }, { layer });\r\n                instrument.emit(\"clickstart\", {\r\n                    ...options,\r\n                    self: options.instrument,\r\n                });\r\n            },\r\n            Command.initialize(\"Log\", { execute() { } }),\r\n        ],\r\n        dragend: [\r\n            async (options) => {\r\n                let { event, layer, instrument } = options;\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                const services = instrument.services.find(\"SelectionService\");\r\n                services.setSharedVars({\r\n                    x: 0,\r\n                    y: 0,\r\n                    offsetx: 0,\r\n                    offsety: 0,\r\n                }, { layer });\r\n                if (event.clientX === instrument.getSharedVar(\"x\") &&\r\n                    event.clientY === instrument.getSharedVar(\"y\")) {\r\n                    instrument.setSharedVar(\"x\", 0);\r\n                    instrument.setSharedVar(\"y\", 0);\r\n                    instrument.emit(\"click\", {\r\n                        ...options,\r\n                        self: options.instrument,\r\n                    });\r\n                }\r\n                else {\r\n                    instrument.setSharedVar(\"x\", 0);\r\n                    instrument.setSharedVar(\"y\", 0);\r\n                    instrument.emit(\"clickabort\", {\r\n                        ...options,\r\n                        self: options.instrument,\r\n                    });\r\n                }\r\n            },\r\n        ],\r\n        dragabort: [\r\n            (options) => {\r\n                if (options.event.changedTouches)\r\n                    options.event = options.event.changedTouches[0];\r\n                const services = options.instrument.services.find(\"SelectionService\");\r\n                services.setSharedVars({\r\n                    x: 0,\r\n                    y: 0,\r\n                    offsetx: 0,\r\n                    offsety: 0,\r\n                }, { layer: options.layer });\r\n                options.instrument.emit(\"clickabort\", {\r\n                    ...options,\r\n                    self: options.instrument,\r\n                });\r\n            },\r\n        ],\r\n    },\r\n    preAttach: (instrument, layer) => {\r\n        instrument.services.add(\"SurfacePointSelectionService\", {\r\n            layer,\r\n            sharedVar: {\r\n                deepClone: instrument.getSharedVar(\"deepClone\"),\r\n                highlightColor: instrument.getSharedVar(\"highlightColor\"),\r\n                highlightAttrValues: instrument.getSharedVar(\"highlightAttrValues\"),\r\n            },\r\n        });\r\n    },\r\n});\r\nInstrument.register(\"BrushInstrument\", {\r\n    constructor: Instrument,\r\n    interactors: [\"MouseTraceInteractor\", \"TouchTraceInteractor\"],\r\n    on: {\r\n        dragstart: [\r\n            async ({ event, layer, instrument }) => {\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                const services = instrument.services.find(\"RectSelectionService\");\r\n                services.setSharedVars({\r\n                    x: event.clientX,\r\n                    y: event.clientY,\r\n                    offsetx: event.offsetX,\r\n                    offsety: event.offsetY,\r\n                    width: 1,\r\n                    height: 1,\r\n                    startx: event.clientX,\r\n                    starty: event.clientY,\r\n                    startoffsetx: event.offsetX,\r\n                    startoffsety: event.offsetY,\r\n                    currentx: event.clientX,\r\n                    currenty: event.clientY,\r\n                }, { layer });\r\n                const x = event.offsetX;\r\n                const y = event.offsetY;\r\n                const width = 0;\r\n                const height = 0;\r\n                const layerOffsetX = layer._offset?.x ?? 0;\r\n                const layerOffsetY = layer._offset?.y ?? 0;\r\n                const scaleX = instrument.getSharedVar(\"scaleX\");\r\n                const scaleY = instrument.getSharedVar(\"scaleY\");\r\n                if (scaleX && scaleX.invert && scaleY && scaleY.invert) {\r\n                    const newExtentX = [x - layerOffsetX, x - layerOffsetX + width].map(scaleX.invert);\r\n                    const newExtentY = [y - layerOffsetY, y - layerOffsetY + height].map(scaleY.invert);\r\n                    instrument.setSharedVar(\"extent\", [newExtentX, newExtentY], {\r\n                        layer,\r\n                    });\r\n                    instrument.services\r\n                        .find(\"SelectionService\")\r\n                        .filter([newExtentX, newExtentY]);\r\n                }\r\n                else {\r\n                    instrument.services.find(\"SelectionService\").filter([\r\n                        [x - layerOffsetX, x - layerOffsetX + width],\r\n                        [y - layerOffsetY, y - layerOffsetY + height],\r\n                    ]);\r\n                }\r\n                instrument.setSharedVar(\"startx\", event.clientX);\r\n                instrument.setSharedVar(\"starty\", event.clientY);\r\n                instrument.setSharedVar(\"startoffsetx\", event.offsetX);\r\n                instrument.setSharedVar(\"startoffsety\", event.offsetY);\r\n            },\r\n        ],\r\n        drag: [\r\n            async (options) => {\r\n                let { event, layer, instrument } = options;\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                const startx = instrument.getSharedVar(\"startx\");\r\n                const starty = instrument.getSharedVar(\"starty\");\r\n                const startoffsetx = instrument.getSharedVar(\"startoffsetx\");\r\n                const startoffsety = instrument.getSharedVar(\"startoffsety\");\r\n                const x = Math.min(startx, event.clientX);\r\n                const y = Math.min(starty, event.clientY);\r\n                const offsetx = Math.min(startoffsetx, event.offsetX);\r\n                const offsety = Math.min(startoffsety, event.offsetY);\r\n                const width = Math.abs(event.clientX - startx);\r\n                const height = Math.abs(event.clientY - starty);\r\n                // selection, currently service use client coordinates, but coordinates relative to the layer maybe more appropriate.\r\n                const services = instrument.services.find(\"SelectionService\");\r\n                services.setSharedVars({\r\n                    x,\r\n                    y,\r\n                    offsetx,\r\n                    offsety,\r\n                    width,\r\n                    height,\r\n                    currentx: event.clientX,\r\n                    currenty: event.clientY,\r\n                }, { layer });\r\n            },\r\n        ],\r\n        dragend: [Command.initialize(\"Log\", { execute() { } })],\r\n        dragabort: [\r\n            async (options) => {\r\n                let { event, layer, instrument } = options;\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                const services = instrument.services.find(\"SelectionService\");\r\n                services.setSharedVars({\r\n                    x: 0,\r\n                    y: 0,\r\n                    offsetx: 0,\r\n                    offsety: 0,\r\n                    width: 0,\r\n                    height: 0,\r\n                    currentx: event.clientX,\r\n                    currenty: event.clientY,\r\n                    endx: event.clientX,\r\n                    endy: event.clientY,\r\n                }, { layer });\r\n                instrument.emit(\"brushabort\", options);\r\n            },\r\n        ],\r\n    },\r\n    preAttach: (instrument, layer) => {\r\n        // create selectionLayer first\r\n        layer.getLayerFromQueue(\"selectionLayer\");\r\n        instrument.services.add(\"RectSelectionService\", {\r\n            layer,\r\n            sharedVar: {\r\n                deepClone: instrument.getSharedVar(\"deepClone\"),\r\n                ...(instrument.getSharedVar(\"highlightColor\")\r\n                    ? { highlightColor: instrument.getSharedVar(\"highlightColor\") }\r\n                    : {}),\r\n                ...(instrument.getSharedVar(\"highlightAttrValues\")\r\n                    ? {\r\n                        highlightAttrValues: instrument.getSharedVar(\"highlightAttrValues\"),\r\n                    }\r\n                    : {}),\r\n            },\r\n        });\r\n    },\r\n});\r\nInstrument.register(\"BrushXInstrument\", {\r\n    constructor: Instrument,\r\n    interactors: [\"MouseTraceInteractor\", \"TouchTraceInteractor\"],\r\n    on: {\r\n        dragstart: [\r\n            async ({ event, layer, instrument }) => {\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                const services = instrument.services;\r\n                services.setSharedVars({\r\n                    x: event.clientX,\r\n                    offsetx: event.offsetX,\r\n                    width: 0,\r\n                    startx: event.clientX,\r\n                    startoffsetx: event.offsetX,\r\n                    currentx: event.clientX,\r\n                }, { layer });\r\n                instrument.setSharedVar(\"startx\", event.clientX);\r\n                instrument.setSharedVar(\"startoffsetx\", event.offsetX);\r\n            },\r\n        ],\r\n        drag: [\r\n            async (options) => {\r\n                let { event, layer, instrument } = options;\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                const startx = instrument.getSharedVar(\"startx\");\r\n                const startoffsetx = instrument.getSharedVar(\"startoffsetx\");\r\n                const x = Math.min(startx, event.clientX);\r\n                const offsetx = Math.min(startoffsetx, event.offsetX);\r\n                const width = Math.abs(event.clientX - startx);\r\n                // selection, currently service use client coordinates, but coordinates relative to the layer maybe more appropriate.\r\n                instrument.services.find(\"SelectionService\").setSharedVars({\r\n                    x,\r\n                    offsetx,\r\n                    width,\r\n                    currentx: event.clientX,\r\n                }, { layer });\r\n                instrument.setSharedVar(\"currentx\", event.clientX);\r\n                instrument.setSharedVar(\"currentoffsetx\", event.offsetX);\r\n                instrument.emit(\"brush\", options);\r\n            },\r\n        ],\r\n        dragend: [Command.initialize(\"Log\", { execute() { } })],\r\n        dragabort: [\r\n            async (options) => {\r\n                let { event, layer, instrument } = options;\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                instrument.services.setSharedVars({\r\n                    x: 0,\r\n                    offsetx: 0,\r\n                    width: 0,\r\n                    currentx: event.clientX,\r\n                }, { layer });\r\n                instrument.emit(\"brushabort\", options);\r\n            },\r\n        ],\r\n    },\r\n    preAttach: (instrument, layer) => {\r\n        instrument.services.add(\"RectSelectionService\", {\r\n            layer,\r\n            sharedVar: {\r\n                deepClone: instrument.getSharedVar(\"deepClone\"),\r\n                highlightColor: instrument.getSharedVar(\"highlightColor\"),\r\n                highlightAttrValues: instrument.getSharedVar(\"highlightAttrValues\"),\r\n            },\r\n        });\r\n    },\r\n});\r\nInstrument.register(\"BrushYInstrument\", {\r\n    constructor: Instrument,\r\n    interactors: [\"MouseTraceInteractor\", \"TouchTraceInteractor\"],\r\n    on: {\r\n        dragstart: [\r\n            async ({ event, layer, instrument }) => {\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                const services = instrument.services;\r\n                services.setSharedVars({\r\n                    y: event.clientY,\r\n                    offsety: event.offsetY,\r\n                    height: 0,\r\n                    starty: event.clientY,\r\n                    startoffsety: event.offsetY,\r\n                    currenty: event.clientY,\r\n                }, { layer });\r\n                instrument.setSharedVar(\"starty\", event.clientY);\r\n                instrument.setSharedVar(\"startoffsety\", event.offsetY);\r\n            },\r\n        ],\r\n        drag: [\r\n            async (options) => {\r\n                let { event, layer, instrument } = options;\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                const starty = instrument.getSharedVar(\"starty\");\r\n                const startoffsety = instrument.getSharedVar(\"startoffsety\");\r\n                const y = Math.min(starty, event.clientY);\r\n                const offsety = Math.min(startoffsety, event.offsetY);\r\n                const height = Math.abs(event.clientY - starty);\r\n                // selection, currently service use client coordinates, but coordinates relative to the layer maybe more appropriate.\r\n                instrument.services.find(\"SelectionService\").setSharedVars({\r\n                    y,\r\n                    offsety,\r\n                    height,\r\n                    currenty: event.clientY,\r\n                }, { layer });\r\n                instrument.setSharedVar(\"currenty\", event.clientY);\r\n                instrument.setSharedVar(\"currentoffsety\", event.offsetY);\r\n                instrument.emit(\"brush\", options);\r\n            },\r\n        ],\r\n        dragend: [Command.initialize(\"Log\", { execute() { } })],\r\n        dragabort: [\r\n            async (options) => {\r\n                let { event, layer, instrument } = options;\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                instrument.services.setSharedVars({\r\n                    y: 0,\r\n                    offsety: 0,\r\n                    height: 0,\r\n                    currenty: event.clientY,\r\n                }, { layer });\r\n                instrument.emit(\"brushabort\", options);\r\n            },\r\n        ],\r\n    },\r\n    preAttach: (instrument, layer) => {\r\n        instrument.services.add(\"RectSelectionService\", {\r\n            layer,\r\n            sharedVar: {\r\n                deepClone: instrument.getSharedVar(\"deepClone\"),\r\n                highlightColor: instrument.getSharedVar(\"highlightColor\"),\r\n                highlightAttrValues: instrument.getSharedVar(\"highlightAttrValues\"),\r\n            },\r\n        });\r\n    },\r\n});\r\nInstrument.register(\"HelperLineInstrument\", {\r\n    constructor: Instrument,\r\n    sharedVar: { orientation: [\"horizontal\"] },\r\n    interactors: [\"MousePositionInteractor\", \"TouchPositionInteractor\"],\r\n    on: {\r\n        hover: [\r\n            ({ event, layer, instrument }) => {\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                instrument.transformers.setSharedVars({\r\n                    x: event.offsetX,\r\n                    y: event.offsetY,\r\n                });\r\n                instrument.setSharedVar(\"x\", event.offsetX, {});\r\n                instrument.setSharedVar(\"y\", event.offsetY, {});\r\n            },\r\n        ],\r\n        click: [Command.initialize(\"Log\", { execute() { } })],\r\n    },\r\n    preAttach: function (instrument, layer) {\r\n        instrument.transformers.add(\"HelperLineTransformer\", {\r\n            layer: layer.getLayerFromQueue(\"transientLayer\"),\r\n            sharedVar: {\r\n                orientation: instrument.getSharedVar(\"orientation\"),\r\n                style: instrument.getSharedVar(\"style\") || {},\r\n                tooltip: instrument.getSharedVar(\"tooltip\"),\r\n                scaleX: instrument.getSharedVar(\"scaleX\"),\r\n                scaleY: instrument.getSharedVar(\"scaleY\"),\r\n            },\r\n        });\r\n    },\r\n});\r\nInstrument.register(\"DataBrushInstrument\", {\r\n    constructor: Instrument,\r\n    interactors: [\"MouseTraceInteractor\", \"TouchTraceInteractor\"],\r\n    on: {\r\n        dragstart: [\r\n            async ({ event, layer, instrument }) => {\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                const scaleX = instrument.getSharedVar(\"scaleX\");\r\n                const scaleY = instrument.getSharedVar(\"scaleY\");\r\n                const services = instrument.services.find(\"Quantitative2DSelectionService\");\r\n                // services.setSharedVar(\"x\", event.clientX, { layer });\r\n                // services.setSharedVar(\"width\", 1, { layer });\r\n                // const\r\n                // services.setSharedVar(\"startx\", event.clientX, { layer });\r\n                // services.setSharedVar(\"currentx\", event.clientX, { layer });\r\n                const layerPos = d3.pointer(event, layer.getGraphic());\r\n                instrument.setSharedVar(\"layerOffsetX\", event.clientX - layerPos[0]);\r\n                instrument.setSharedVar(\"layerOffsetY\", event.clientY - layerPos[1]);\r\n                instrument.setSharedVar(\"startx\", event.clientX);\r\n                instrument.setSharedVar(\"starty\", event.clientY);\r\n                const newExtentX = [layerPos[0], layerPos[0] + 1].map(scaleX.invert);\r\n                services.setSharedVar(\"extentX\", newExtentX);\r\n                const newExtentY = [layerPos[1], layerPos[1] + 1].map(scaleY.invert);\r\n                services.setSharedVar(\"extentX\", newExtentY);\r\n                instrument.transformers\r\n                    .find(\"TransientRectangleTransformer\")\r\n                    .setSharedVars({\r\n                    x: 0,\r\n                    y: 0,\r\n                    width: 1,\r\n                    height: 1,\r\n                });\r\n            },\r\n        ],\r\n        drag: [\r\n            Command.initialize(\"drawBrushAndSelect\", {\r\n                continuous: true,\r\n                execute: async ({ event, layer, instrument }) => {\r\n                    if (event.changedTouches)\r\n                        event = event.changedTouches[0];\r\n                    const startx = instrument.getSharedVar(\"startx\");\r\n                    const starty = instrument.getSharedVar(\"starty\");\r\n                    const layerOffsetX = instrument.getSharedVar(\"layerOffsetX\");\r\n                    const layerOffsetY = instrument.getSharedVar(\"layerOffsetY\");\r\n                    const scaleX = instrument.getSharedVar(\"scaleX\");\r\n                    const scaleY = instrument.getSharedVar(\"scaleY\");\r\n                    const x = Math.min(startx, event.clientX) - layerOffsetX;\r\n                    const y = Math.min(starty, event.clientY) - layerOffsetY;\r\n                    const width = Math.abs(event.clientX - startx);\r\n                    const height = Math.abs(event.clientY - starty);\r\n                    instrument.setSharedVar(\"x\", x);\r\n                    instrument.setSharedVar(\"y\", y);\r\n                    instrument.setSharedVar(\"width\", width);\r\n                    instrument.setSharedVar(\"height\", height);\r\n                    const newExtentDataX = [x, x + width].map(scaleX.invert);\r\n                    const newExtentDataY = [y + height, y].map(scaleY.invert);\r\n                    const services = instrument.services.find(\"SelectionService\");\r\n                    services.setSharedVar(\"extentX\", newExtentDataX);\r\n                    services.setSharedVar(\"extentY\", newExtentDataY);\r\n                    console.log(services);\r\n                    await Promise.all(instrument.services.results);\r\n                },\r\n                feedback: [\r\n                    async ({ event, layer, instrument }) => {\r\n                        const x = instrument.getSharedVar(\"x\");\r\n                        const y = instrument.getSharedVar(\"y\");\r\n                        const width = instrument.getSharedVar(\"width\");\r\n                        const height = instrument.getSharedVar(\"height\");\r\n                        instrument.transformers\r\n                            .find(\"TransientRectangleTransformer\")\r\n                            .setSharedVars({\r\n                            x: x,\r\n                            y: y,\r\n                            width: width,\r\n                            height: height,\r\n                        });\r\n                    },\r\n                    async ({ instrument }) => {\r\n                        instrument.transformers.find(\"HighlightSelection\").setSharedVars({\r\n                            highlightAttrValues: instrument.getSharedVar(\"highlightAttrValues\") || {},\r\n                        });\r\n                    },\r\n                ],\r\n            }),\r\n        ],\r\n        dragabort: [\r\n            async ({ event, layer, instrument }) => {\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                const services = instrument.services.find(\"SelectionService\");\r\n                services.setSharedVar(\"x\", 0, { layer });\r\n                services.setSharedVar(\"width\", 0, { layer });\r\n                services.setSharedVar(\"currentx\", event.clientX, { layer });\r\n                services.setSharedVar(\"endx\", event.clientX, { layer });\r\n                instrument.transformers\r\n                    .find(\"TransientRectangleTransformer\")\r\n                    .setSharedVars({\r\n                    x: 0,\r\n                    width: 0,\r\n                });\r\n            },\r\n        ],\r\n    },\r\n    preAttach: async (instrument, layer) => {\r\n        const scaleX = instrument.getSharedVar(\"scaleX\");\r\n        const scaleY = instrument.getSharedVar(\"scaleY\");\r\n        const attrNameX = instrument.getSharedVar(\"attrNameX\");\r\n        const extentX = instrument.getSharedVar(\"extentX\") ?? [0, 0];\r\n        const extentXData = extentX.map(scaleX);\r\n        const attrNameY = instrument.getSharedVar(\"attrNameY\");\r\n        const extentY = instrument.getSharedVar(\"extentY\") ?? [0, 0];\r\n        const extentYData = extentX.map(scaleY).reverse();\r\n        const services = instrument.services.add(\"Quantitative2DSelectionService\", {\r\n            layer,\r\n        });\r\n        services.setSharedVar(\"attrNameX\", attrNameX);\r\n        services.setSharedVar(\"extentX\", extentX);\r\n        services.setSharedVar(\"attrNameY\", attrNameY);\r\n        services.setSharedVar(\"extentY\", extentY);\r\n        instrument.transformers\r\n            .add(\"TransientRectangleTransformer\", {\r\n            transient: true,\r\n            layer: layer.getLayerFromQueue(\"transientLayer\"),\r\n            sharedVar: {\r\n                x: extentXData[0],\r\n                y: extentYData[0],\r\n                width: extentXData[1] - extentXData[0],\r\n                height: extentYData[1] - extentYData[0],\r\n                fill: \"#000\",\r\n                opacity: 0.3,\r\n            },\r\n        })\r\n            .add(\"HighlightSelection\", {\r\n            transient: true,\r\n            layer: layer.getLayerFromQueue(\"selectionLayer\"),\r\n            sharedVar: {\r\n                highlightAttrValues: instrument.getSharedVar(\"highlightAttrValues\") || {},\r\n            },\r\n        });\r\n        await Promise.all(instrument.services.results);\r\n    },\r\n});\r\nInstrument.register(\"DataBrushXInstrument\", {\r\n    constructor: Instrument,\r\n    interactors: [\"MouseTraceInteractor\", \"TouchTraceInteractor\"],\r\n    on: {\r\n        dragstart: [\r\n            async ({ event, layer, instrument }) => {\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                const scaleX = instrument.getSharedVar(\"scaleX\");\r\n                const services = instrument.services.find(\"QuantitativeSelectionService\");\r\n                // services.setSharedVar(\"x\", event.clientX, { layer });\r\n                // services.setSharedVar(\"width\", 1, { layer });\r\n                // const\r\n                // services.setSharedVar(\"startx\", event.clientX, { layer });\r\n                // services.setSharedVar(\"currentx\", event.clientX, { layer });\r\n                const layerPosX = d3.pointer(event, layer.getGraphic())[0];\r\n                instrument.setSharedVar(\"layerOffsetX\", event.clientX - layerPosX);\r\n                instrument.setSharedVar(\"startx\", event.clientX);\r\n                instrument.setSharedVar(\"startLayerPosX\", layerPosX);\r\n                const newExtent = [layerPosX, layerPosX + 1].map(scaleX.invert);\r\n                services.setSharedVar(\"extent\", newExtent);\r\n                instrument.transformers\r\n                    .find(\"TransientRectangleTransformer\")\r\n                    .setSharedVars({\r\n                    x: layerPosX,\r\n                    width: 1,\r\n                });\r\n            },\r\n        ],\r\n        drag: [\r\n            Command.initialize(\"drawBrushAndSelect\", {\r\n                continuous: true,\r\n                execute: async ({ event, layer, instrument }) => {\r\n                    if (event.changedTouches)\r\n                        event = event.changedTouches[0];\r\n                    const startx = instrument.getSharedVar(\"startx\");\r\n                    const layerOffsetX = instrument.getSharedVar(\"layerOffsetX\");\r\n                    const scaleX = instrument.getSharedVar(\"scaleX\");\r\n                    const x = Math.min(startx, event.clientX);\r\n                    const width = Math.abs(event.clientX - startx);\r\n                    const newExtent = [x - layerOffsetX, x - layerOffsetX + width].map(scaleX.invert);\r\n                    // selection, currently service use client coordinates, but coordinates relative to the layer maybe more appropriate.\r\n                    const services = instrument.services.find(\"QuantitativeSelectionService\");\r\n                    instrument.setSharedVar(\"extent\", newExtent);\r\n                    services.setSharedVar(\"extent\", newExtent);\r\n                    // services.setSharedVar(\"x\", x, { layer });\r\n                    // services.setSharedVar(\"width\", width, {\r\n                    //   layer,\r\n                    // });\r\n                    // services.setSharedVar(\"currentx\", event.clientX, { layer });\r\n                    await Promise.all(instrument.services.results);\r\n                },\r\n                feedback: [\r\n                    async ({ event, layer, instrument }) => {\r\n                        const startLayerPosX = instrument.getSharedVar(\"startLayerPosX\");\r\n                        const layerPosX = d3.pointer(event, layer.getGraphic())[0];\r\n                        console.log(startLayerPosX, layerPosX);\r\n                        const x = Math.min(startLayerPosX, layerPosX);\r\n                        const width = Math.abs(layerPosX - startLayerPosX);\r\n                        // // draw brush\r\n                        // const baseBBox = (\r\n                        //   layer.getGraphic().querySelector(\".ig-layer-background\") ||\r\n                        //   layer.getGraphic()\r\n                        // ).getBoundingClientRect();\r\n                        instrument.transformers\r\n                            .find(\"TransientRectangleTransformer\")\r\n                            .setSharedVars({\r\n                            x: x,\r\n                            width: width,\r\n                        });\r\n                    },\r\n                    async ({ instrument }) => {\r\n                        instrument.transformers.find(\"HighlightSelection\").setSharedVars({\r\n                            highlightAttrValues: instrument.getSharedVar(\"highlightAttrValues\") || {},\r\n                        });\r\n                    },\r\n                ],\r\n            }),\r\n        ],\r\n        dragabort: [\r\n            async ({ event, layer, instrument }) => {\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                const services = instrument.services.find(\"SelectionService\");\r\n                services.setSharedVar(\"x\", 0, { layer });\r\n                services.setSharedVar(\"width\", 0, { layer });\r\n                services.setSharedVar(\"currentx\", event.clientX, { layer });\r\n                services.setSharedVar(\"endx\", event.clientX, { layer });\r\n                instrument.transformers\r\n                    .find(\"TransientRectangleTransformer\")\r\n                    .setSharedVars({\r\n                    x: 0,\r\n                    width: 0,\r\n                });\r\n            },\r\n        ],\r\n    },\r\n    preAttach: (instrument, layer) => {\r\n        //const y = instrument.getSharedVar(\"y\") ?? 0;\r\n        const scaleX = instrument.getSharedVar(\"scaleX\");\r\n        const height = instrument.getSharedVar(\"height\") ?? layer._height;\r\n        const y = instrument.getSharedVar(\"y\") ?? 0;\r\n        const attrName = instrument.getSharedVar(\"attrNameX\");\r\n        const extent = instrument.getSharedVar(\"extentX\") ?? [0, 0];\r\n        const extentData = extent.map(scaleX);\r\n        // const attrNameY = instrument.getSharedVar(\"attrNameY\");\r\n        // const extentY = instrument.getSharedVar(\"extentY\");\r\n        const services = instrument.services.add(\"QuantitativeSelectionService\", {\r\n            layer,\r\n        });\r\n        // const bbox = layer.getGraphic().getBoundingClientRect();\r\n        services.setSharedVar(\"attrName\", attrName);\r\n        services.setSharedVar(\"extent\", extent);\r\n        instrument.transformers\r\n            .add(\"TransientRectangleTransformer\", {\r\n            transient: true,\r\n            layer: layer.getLayerFromQueue(\"transientLayer\"),\r\n            sharedVar: {\r\n                x: extentData[0],\r\n                y: y,\r\n                width: extentData[1] - extentData[0],\r\n                height: height,\r\n                fill: \"#000\",\r\n                opacity: 0.3,\r\n            },\r\n        })\r\n            .add(\"HighlightSelection\", {\r\n            transient: true,\r\n            layer: layer.getLayerFromQueue(\"selectionLayer\"),\r\n            sharedVar: {\r\n                highlightAttrValues: instrument.getSharedVar(\"highlightAttrValues\") || {},\r\n            },\r\n        });\r\n    },\r\n});\r\nInstrument.register(\"DragInstrument\", {\r\n    constructor: Instrument,\r\n    interactors: [\"MouseTraceInteractor\", \"TouchTraceInteractor\"],\r\n    on: {\r\n        dragstart: [\r\n            ({ layer, event, instrument }) => {\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                instrument.services.setSharedVars({\r\n                    x: event.clientX,\r\n                    y: event.clientY,\r\n                    startx: event.clientX,\r\n                    starty: event.clientY,\r\n                    currentx: event.clientX,\r\n                    currenty: event.clientY,\r\n                    offsetx: event.offsetX,\r\n                    offsety: event.offsetY,\r\n                    offset: { x: 0, y: 0 },\r\n                    skipPicking: false,\r\n                }, { layer });\r\n            },\r\n        ],\r\n        drag: [\r\n            ({ layer, event, instrument }) => {\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                const offsetX = event.clientX - instrument.services.getSharedVar(\"x\", { layer })[0];\r\n                const offsetY = event.clientY - instrument.services.getSharedVar(\"y\", { layer })[0];\r\n                instrument.setSharedVar(\"offsetx\", offsetX, { layer });\r\n                instrument.setSharedVar(\"offsety\", offsetY, { layer });\r\n                instrument.services.setSharedVars({\r\n                    x: event.clientX,\r\n                    y: event.clientY,\r\n                    currentx: event.clientX,\r\n                    currenty: event.clientY,\r\n                    offsetx: event.offsetX,\r\n                    offsety: event.offsetY,\r\n                    offset: { x: offsetX, y: offsetY },\r\n                    skipPicking: true,\r\n                }, { layer });\r\n            },\r\n        ],\r\n        dragend: [\r\n            ({ layer, event, instrument }) => {\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                const offsetX = event.clientX - instrument.services.getSharedVar(\"x\", { layer })[0];\r\n                const offsetY = event.clientY - instrument.services.getSharedVar(\"y\", { layer })[0];\r\n                instrument.services.setSharedVars({\r\n                    x: 0,\r\n                    y: 0,\r\n                    currentx: event.clientX,\r\n                    currenty: event.clientY,\r\n                    endx: event.clientX,\r\n                    endy: event.clientY,\r\n                    offsetx: 0,\r\n                    offsety: 0,\r\n                    offset: { x: 0, y: 0 },\r\n                    skipPicking: false,\r\n                }, { layer });\r\n                instrument.setSharedVar(\"offsetx\", offsetX, { layer });\r\n                instrument.setSharedVar(\"offsety\", offsetY, { layer });\r\n            },\r\n            Command.initialize(\"Log\", { execute() { } }),\r\n        ],\r\n        dragabort: [\r\n            (options) => {\r\n                let { layer, event, instrument } = options;\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                instrument.services.setSharedVars({\r\n                    x: 0,\r\n                    y: 0,\r\n                    currentx: event.clientX,\r\n                    currenty: event.clientY,\r\n                    endx: 0,\r\n                    endy: 0,\r\n                    offsetx: 0,\r\n                    offsety: 0,\r\n                    skipPicking: false,\r\n                }, { layer });\r\n                instrument.emit(\"dragconfirm\", {\r\n                    ...options,\r\n                    self: options.instrument,\r\n                });\r\n            },\r\n        ],\r\n    },\r\n    preAttach: (instrument, layer) => {\r\n        // Create default SM on layer\r\n        instrument.services.add(\"SurfacePointSelectionService\", {\r\n            layer,\r\n            sharedVar: { deepClone: instrument.getSharedVar(\"deepClone\") },\r\n        });\r\n    },\r\n});\r\nInstrument.register(\"SpeechInstrument\", {\r\n    constructor: Instrument,\r\n    interactors: [\"SpeechControlInteractor\"],\r\n});\r\nInstrument.register(\"KeyboardHelperBarInstrument\", {\r\n    constructor: Instrument,\r\n    interactors: [\"KeyboardPositionInteractor\"],\r\n    on: {\r\n        begin: [() => console.log(\"begin\")],\r\n        left: [\r\n            ({ event, layer, instrument }) => {\r\n                const speed = instrument.getSharedVar(\"speed\") || 1;\r\n                const transientLayer = layer.getLayerFromQueue(\"transientLayer\");\r\n                const helperBar = transientLayer\r\n                    .getGraphic()\r\n                    .querySelector(\"line\");\r\n                const transform = getTransform(helperBar);\r\n                const newX = transform[0] - speed;\r\n                helperBar.setAttribute(\"transform\", `translate(${newX}, 0)`);\r\n                instrument.setSharedVar(\"barX\", newX, {});\r\n            },\r\n        ],\r\n        right: [\r\n            ({ event, layer, instrument }) => {\r\n                const speed = instrument.getSharedVar(\"speed\") || 1;\r\n                const transientLayer = layer.getLayerFromQueue(\"transientLayer\");\r\n                const helperBar = transientLayer\r\n                    .getGraphic()\r\n                    .querySelector(\"line\");\r\n                const transform = getTransform(helperBar);\r\n                const newX = transform[0] + speed;\r\n                helperBar.setAttribute(\"transform\", `translate(${newX}, 0)`);\r\n                instrument.setSharedVar(\"barX\", newX, {});\r\n            },\r\n        ],\r\n    },\r\n    preAttach: function (instrument, layer) {\r\n        layer.getGraphic().setAttribute(\"tabindex\", 0);\r\n        layer.getGraphic().focus();\r\n        // const startX = layer.getSharedVar(\"startX\", 0);\r\n        const height = layer._height;\r\n        const startPos = instrument.getSharedVar(\"startPos\");\r\n        const transientLayer = layer.getLayerFromQueue(\"transientLayer\");\r\n        const helperBar = document.createElementNS(\"http://www.w3.org/2000/svg\", \"line\");\r\n        helperBar.setAttribute(\"x1\", startPos);\r\n        helperBar.setAttribute(\"y1\", \"0\");\r\n        helperBar.setAttribute(\"x2\", startPos);\r\n        helperBar.setAttribute(\"y2\", height);\r\n        helperBar.setAttribute(\"stroke\", `black`);\r\n        helperBar.setAttribute(\"stroke-width\", `1px`);\r\n        transientLayer.getGraphic().append(helperBar);\r\n    },\r\n});\r\n/** only apply to linear scale. should record currentX as x in domain if fixRange is true */\r\nInstrument.register(\"PanInstrument\", {\r\n    constructor: Instrument,\r\n    interactors: [\"MouseTraceInteractor\", \"TouchTraceInteractor\"],\r\n    on: {\r\n        dragstart: [\r\n            ({ layer, event, instrument }) => {\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                instrument.setSharedVar(\"startx\", event.clientX);\r\n                instrument.setSharedVar(\"starty\", event.clientY);\r\n                let transformers = instrument.transformers;\r\n                if (!transformers.length) {\r\n                    transformers = GraphicalTransformer.findTransformerByLayer(layer);\r\n                }\r\n                transformers.forEach((transformer) => {\r\n                    const sx = transformer.getSharedVar(\"scaleX\");\r\n                    const sy = transformer.getSharedVar(\"scaleY\");\r\n                    if (sx) {\r\n                        transformer.setSharedVar(\"$$scaleX\", sx.copy());\r\n                        // transformer.setSharedVar(\"startDomainX\", sx.domain());\r\n                        // transformer.setSharedVar(\"startRangeX\", sx.range());\r\n                    }\r\n                    if (sy) {\r\n                        transformer.setSharedVar(\"$$scaleY\", sy.copy());\r\n                        // transformer.setSharedVar(\"startDomainY\", sy.domain());\r\n                        // transformer.setSharedVar(\"startRangeY\", sy.range());\r\n                    }\r\n                });\r\n            },\r\n        ],\r\n        drag: [\r\n            async ({ layer, event, instrument, transformer }) => {\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                let transformers = instrument.transformers;\r\n                if (!transformers.length) {\r\n                    transformers = GraphicalTransformer.findTransformerByLayer(layer);\r\n                }\r\n                const startx = instrument.getSharedVar(\"startx\");\r\n                const starty = instrument.getSharedVar(\"starty\");\r\n                const fixRange = instrument.getSharedVar(\"fixRange\") ?? false;\r\n                transformers.forEach((transformer) => {\r\n                    const sx = transformer.getSharedVar(\"scaleX\");\r\n                    const sy = transformer.getSharedVar(\"scaleY\");\r\n                    if (fixRange) {\r\n                        if (sx) {\r\n                            const scaleXOrigin = transformer.getSharedVar(\"$$scaleX\");\r\n                            const startRangeX = scaleXOrigin.range();\r\n                            const newRangeX = startRangeX.map((x, i) => x - event.clientX + startx);\r\n                            const newDomain = newRangeX.map((x) => scaleXOrigin.invert(x));\r\n                            sx.domain(newDomain);\r\n                            transformer.setSharedVar(\"scaleX\", sx);\r\n                        }\r\n                        if (sy) {\r\n                            const scaleYOrigin = transformer.getSharedVar(\"$$scaleY\");\r\n                            const startRangeY = scaleYOrigin.range();\r\n                            const newRangeY = startRangeY.map((y, i) => y - event.clientY + starty);\r\n                            const newDomain = newRangeY.map((y) => scaleYOrigin.invert(y));\r\n                            sy.domain(newDomain);\r\n                            transformer.setSharedVar(\"scaleY\", sy);\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (sx) {\r\n                            const startRangeX = transformer.getSharedVar(\"$$scaleX\").range();\r\n                            const newRangeX = startRangeX.map((x, i) => x + event.clientX - startx);\r\n                            sx.range(newRangeX);\r\n                            transformer.setSharedVar(\"scaleX\", sx);\r\n                        }\r\n                        if (sy) {\r\n                            // const newRangeY = sy.range().map((y) => y + offsetY);\r\n                            const startRangeY = transformer.getSharedVar(\"$$scaleY\").range();\r\n                            const newRangeY = startRangeY.map((y, i) => y + event.clientY - starty);\r\n                            sy.range(newRangeY);\r\n                            transformer.setSharedVar(\"scaleY\", sy);\r\n                        }\r\n                    }\r\n                });\r\n            },\r\n        ],\r\n        dragend: [Command.initialize(\"Log\", { execute() { } })],\r\n        dragabort: [\r\n            ({ layer, event, instrument, transformer }) => {\r\n                // if (event.changedTouches) event = event.changedTouches[0];\r\n                // const sx = transformer.getTransformation(\"$$scaleX\");\r\n                // const sy = transformer.getTransformation(\"$$scaleY\");\r\n                // instrument.setSharedVar(\"startx\", event.clientX);\r\n                // instrument.setSharedVar(\"starty\", event.clientY);\r\n                // instrument.setSharedVar(\"currentx\", event.clientX);\r\n                // instrument.setSharedVar(\"currenty\", event.clientY);\r\n                // if (sx) {\r\n                //   transformer.setTransformation(\"scaleX\", sx);\r\n                //   transformer.setTransformation(\"$scaleX\", sx);\r\n                // }\r\n                // if (sy) {\r\n                //   transformer.setTransformation(\"scaleY\", sy);\r\n                //   transformer.setTransformation(\"$scaleY\", sy);\r\n                // }\r\n                // layer.getLayerFromQueue(\"selectionLayer\").getGraphic().innerHTML = \"\";\r\n                // layer.getLayerFromQueue(\"transientLayer\").getGraphic().innerHTML = \"\";\r\n            },\r\n        ],\r\n    },\r\n});\r\nInstrument.register(\"PanXInstrument\", {\r\n    constructor: Instrument,\r\n    interactors: [\"MouseTraceInteractor\", \"TouchTraceInteractor\"],\r\n    on: {\r\n        dragstart: [\r\n            ({ layer, event, instrument }) => {\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                instrument.setSharedVar(\"startx\", event.clientX);\r\n                // instrument.setSharedVar(\"starty\", event.clientY);\r\n                const transformers = instrument.transformers;\r\n                transformers.forEach((transformer) => {\r\n                    const sx = transformer.getSharedVar(\"scaleX\");\r\n                    // const sy = transformer.getSharedVar(\"scaleY\");\r\n                    if (sx) {\r\n                        transformer.setSharedVar(\"$$scaleX\", sx.copy());\r\n                        // transformer.setSharedVar(\"startDomainX\", sx.domain());\r\n                        // transformer.setSharedVar(\"startRangeX\", sx.range());\r\n                    }\r\n                    // if (sy) {\r\n                    // transformer.setSharedVar(\"$$scaleY\", sy.copy());\r\n                    // transformer.setSharedVar(\"startDomainY\", sy.domain());\r\n                    // transformer.setSharedVar(\"startRangeY\", sy.range());\r\n                    // }\r\n                });\r\n            },\r\n        ],\r\n        drag: [\r\n            async ({ layer, event, instrument, transformer }) => {\r\n                if (event.changedTouches)\r\n                    event = event.changedTouches[0];\r\n                const transformers = instrument.transformers;\r\n                const startx = instrument.getSharedVar(\"startx\");\r\n                // const starty = instrument.getSharedVar(\"starty\");\r\n                const fixRange = instrument.getSharedVar(\"fixRange\") ?? false;\r\n                transformers.forEach((transformer) => {\r\n                    const sx = transformer.getSharedVar(\"scaleX\");\r\n                    // const sy = transformer.getSharedVar(\"scaleY\");\r\n                    if (fixRange) {\r\n                        if (sx) {\r\n                            const scaleXOrigin = transformer.getSharedVar(\"$$scaleX\");\r\n                            const startRangeX = scaleXOrigin.range();\r\n                            const newRangeX = startRangeX.map((x, i) => x - event.clientX + startx);\r\n                            const newDomain = newRangeX.map((x) => scaleXOrigin.invert(x));\r\n                            sx.domain(newDomain);\r\n                            transformer.setSharedVar(\"scaleX\", sx);\r\n                        }\r\n                        // if (sy) {\r\n                        //   const scaleYOrigin = transformer.getSharedVar(\"$$scaleY\");\r\n                        //   const startRangeY = scaleYOrigin.range();\r\n                        //   const newRangeY = startRangeY.map((y, i) => y - event.clientY + starty);\r\n                        //   const newDomain = newRangeY.map(y => scaleYOrigin.invert(y));\r\n                        //   sy.domain(newDomain);\r\n                        //   transformer.setSharedVar(\"scaleY\", sy);\r\n                        // }\r\n                    }\r\n                    else {\r\n                        if (sx) {\r\n                            const startRangeX = transformer.getSharedVar(\"$$scaleX\").range();\r\n                            const newRangeX = startRangeX.map((x, i) => x + event.clientX - startx);\r\n                            sx.range(newRangeX);\r\n                            transformer.setSharedVar(\"scaleX\", sx);\r\n                        }\r\n                        // if (sy) {\r\n                        //   // const newRangeY = sy.range().map((y) => y + offsetY);\r\n                        //   const startRangeY = transformer.getSharedVar(\"$$scaleY\").range();\r\n                        //   const newRangeY = startRangeY.map((y, i) => y + event.clientY - starty);\r\n                        //   sy.range(newRangeY);\r\n                        //   transformer.setSharedVar(\"scaleY\", sy);\r\n                        // }\r\n                    }\r\n                });\r\n            },\r\n        ],\r\n        dragabort: [\r\n            ({ layer, event, instrument, transformer }) => {\r\n                // if (event.changedTouches) event = event.changedTouches[0];\r\n                // const sx = transformer.getTransformation(\"$$scaleX\");\r\n                // const sy = transformer.getTransformation(\"$$scaleY\");\r\n                // instrument.setSharedVar(\"startx\", event.clientX);\r\n                // instrument.setSharedVar(\"starty\", event.clientY);\r\n                // instrument.setSharedVar(\"currentx\", event.clientX);\r\n                // instrument.setSharedVar(\"currenty\", event.clientY);\r\n                // if (sx) {\r\n                //   transformer.setTransformation(\"scaleX\", sx);\r\n                //   transformer.setTransformation(\"$scaleX\", sx);\r\n                // }\r\n                // if (sy) {\r\n                //   transformer.setTransformation(\"scaleY\", sy);\r\n                //   transformer.setTransformation(\"$scaleY\", sy);\r\n                // }\r\n                // layer.getLayerFromQueue(\"selectionLayer\").getGraphic().innerHTML = \"\";\r\n                // layer.getLayerFromQueue(\"transientLayer\").getGraphic().innerHTML = \"\";\r\n            },\r\n        ],\r\n    },\r\n});\r\nInstrument.register(\"GeometricZoomInstrument\", {\r\n    constructor: Instrument,\r\n    interactors: [\"MouseWheelInteractor\"],\r\n    on: {\r\n        wheel: [\r\n            ({ layer, instrument, event }) => {\r\n                const layerGraphic = layer.getGraphic();\r\n                const layerRoot = d3.select(layerGraphic);\r\n                let transformers = instrument.transformers;\r\n                if (!transformers.length) {\r\n                    transformers = GraphicalTransformer.findTransformerByLayer(layer);\r\n                }\r\n                instrument.setSharedVar(\"currentx\", event.offsetX);\r\n                instrument.setSharedVar(\"currenty\", event.offsetY);\r\n                let delta = event.deltaY;\r\n                instrument.setSharedVar(\"delta\", delta);\r\n                let cumulativeDelta = instrument.getSharedVar(\"cumulativeDelta\", {\r\n                    defaultValue: 0,\r\n                });\r\n                cumulativeDelta += delta;\r\n                instrument.setSharedVar(\"cumulativeDelta\", cumulativeDelta);\r\n                delta /= 1000;\r\n                const [x, y] = d3.pointer(event, layerGraphic);\r\n                const offsetX = instrument.getSharedVar(\"centroidX\") || x;\r\n                const offsetY = instrument.getSharedVar(\"centroidY\") || y;\r\n                const fixRange = instrument.getSharedVar(\"fixRange\") ?? false;\r\n                transformers.forEach((transformer) => {\r\n                    const sx = transformer.getSharedVar(\"scaleX\");\r\n                    const sy = transformer.getSharedVar(\"scaleY\");\r\n                    if (fixRange) {\r\n                        if (sx) {\r\n                            if (sx.type === \"time\") {\r\n                                const offsetXDomain = sx.invert(offsetX);\r\n                                sx.domain(sx\r\n                                    .domain()\r\n                                    .map((d) => new Date(d.getTime() - offsetXDomain.getTime()))\r\n                                    .map((d) => new Date(d.getTime() * Math.exp(-delta)))\r\n                                    .map((d) => new Date(d.getTime() + offsetXDomain.getTime())));\r\n                            }\r\n                            else {\r\n                                const offsetXDomain = sx.invert(offsetX);\r\n                                sx.domain(sx\r\n                                    .domain()\r\n                                    .map((d) => d - offsetXDomain)\r\n                                    .map((d) => d * Math.exp(-delta))\r\n                                    .map((d) => d + offsetXDomain));\r\n                            }\r\n                            transformers.forEach((transformer) => transformer.setSharedVar(\"scaleX\", sx));\r\n                        }\r\n                        if (sy) {\r\n                            if (sy.type === \"time\") {\r\n                                const offsetYDomain = sy.invert(offsetY);\r\n                                sy.domain(sy\r\n                                    .domain()\r\n                                    .map((d) => new Date(d.getTime() - offsetYDomain.getTime()))\r\n                                    .map((d) => new Date(d.getTime() * Math.exp(-delta)))\r\n                                    .map((d) => new Date(d.getTime() + offsetYDomain.getTime())));\r\n                            }\r\n                            else {\r\n                                const offsetYDomain = sy.invert(offsetY);\r\n                                sy.domain(sy\r\n                                    .domain()\r\n                                    .map((d) => d - offsetYDomain)\r\n                                    .map((d) => d * Math.exp(-delta))\r\n                                    .map((d) => d + offsetYDomain));\r\n                            }\r\n                            transformers.forEach((transformer) => transformer.setSharedVar(\"scaleY\", sy));\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (sx) {\r\n                            const newRangeX = sx\r\n                                .range()\r\n                                .map((x) => (x - offsetX) * Math.exp(delta) + offsetX);\r\n                            sx.range(newRangeX);\r\n                            transformer.setSharedVar(\"scaleX\", sx);\r\n                        }\r\n                        if (sy) {\r\n                            const newRangeY = sy\r\n                                .range()\r\n                                .map((y) => (y - offsetY) * Math.exp(delta) + offsetY);\r\n                            sy.range(newRangeY);\r\n                            transformer.setSharedVar(\"scaleY\", sy);\r\n                        }\r\n                    }\r\n                });\r\n                // if (fixRange) {\r\n                //   if (sx) {\r\n                //     const scaleX = sx\r\n                //       .copy()\r\n                //       .domain(\r\n                //         sx.range().map((x) => (x - offsetX) * Math.exp(delta) + offsetX)\r\n                //       )\r\n                //       .range(sx.domain());\r\n                //     if (scaleX.clamp) scaleX.clamp(false);\r\n                //     scaleX.domain(sx.range().map((x) => scaleX(x))).range(sx.range());\r\n                //     transformers.forEach((transformer) => transformer.setSharedVar(\"scaleX\", scaleX));\r\n                //   }\r\n                //   if (sy) {\r\n                //     const scaleY = sy\r\n                //       .copy()\r\n                //       .domain(\r\n                //         sy.range().map((y) => (y - offsetY) * Math.exp(delta) + offsetY)\r\n                //       )\r\n                //       .range(sy.domain());\r\n                //     if (scaleY.clamp) scaleY.clamp(false);\r\n                //     scaleY.domain(sy.range().map((y) => scaleY(y))).range(sy.range());\r\n                //     transformers.forEach((transformer) => transformer.setSharedVar(\"scaleY\", scaleY));\r\n                //   }\r\n                // }\r\n                // else {\r\n                //   if (sx) {\r\n                //     const proxyRaw = (\r\n                //       raw: Transformation & { $origin: Transformation }\r\n                //     ) =>\r\n                //       new Proxy(raw, {\r\n                //         get(target, path) {\r\n                //           if (path in target) return target[path];\r\n                //           if (path === \"range\")\r\n                //             return (...args) =>\r\n                //               (target.$origin as any)\r\n                //                 .range(\r\n                //                   ...args.map(\r\n                //                     (x) => (x - offsetX) / Math.exp(delta) + offsetX\r\n                //                   )\r\n                //                 )\r\n                //                 .map((x) => (x - offsetX) * Math.exp(delta) + offsetX);\r\n                //           if (path === \"bandwidth\" && \"bandwidth\" in target.$origin) {\r\n                //             return () =>\r\n                //               (target.$origin as any).bandwidth() * Math.exp(delta);\r\n                //           }\r\n                //           return target.$origin[path];\r\n                //         },\r\n                //         apply(target, thisArg, argArray) {\r\n                //           return target.apply(thisArg, argArray);\r\n                //         },\r\n                //         has(target, path) {\r\n                //           return path in target || path in target.$origin;\r\n                //         },\r\n                //       });\r\n                //     const scaleXRaw = (domain) =>\r\n                //       (scaleXRaw.$origin(domain) - offsetX) * Math.exp(delta) + offsetX;\r\n                //     scaleXRaw.invert = (range) =>\r\n                //       scaleXRaw.$origin.invert(\r\n                //         (range - offsetX) / Math.exp(delta) + offsetX\r\n                //       );\r\n                //     scaleXRaw.$origin = sx;\r\n                //     scaleXRaw.copy = () => {\r\n                //       const anotherScaleXRaw = (domain) =>\r\n                //         (anotherScaleXRaw.$origin(domain) - offsetX) * Math.exp(delta) +\r\n                //         offsetX;\r\n                //       Object.assign(anotherScaleXRaw, scaleXRaw);\r\n                //       anotherScaleXRaw.$origin = sx.copy();\r\n                //       anotherScaleXRaw.invert = (range) =>\r\n                //         anotherScaleXRaw.$origin.invert(\r\n                //           (range - offsetX) / Math.exp(delta) + offsetX\r\n                //         );\r\n                //       return proxyRaw(anotherScaleXRaw as any);\r\n                //     };\r\n                //     const scaleX = proxyRaw(scaleXRaw);\r\n                //     transformer.setTransformation(\"scaleX\", scaleX);\r\n                //   }\r\n                //   if (sy) {\r\n                //     const proxyRaw = (\r\n                //       raw: Transformation & { $origin: Transformation }\r\n                //     ) =>\r\n                //       new Proxy(raw, {\r\n                //         get(target, path) {\r\n                //           if (path in target) return target[path];\r\n                //           if (path === \"range\")\r\n                //             return (...args) =>\r\n                //               (target.$origin as any)\r\n                //                 .range(...args)\r\n                //                 .map((y) => (y - offsetY) * Math.exp(delta) + offsetY);\r\n                //           if (path === \"bandwidth\" && \"bandwidth\" in target.$origin) {\r\n                //             return () =>\r\n                //               (target.$origin as any).bandwidth() * Math.exp(delta);\r\n                //           }\r\n                //           return target.$origin[path];\r\n                //         },\r\n                //         apply(target, thisArg, argArray) {\r\n                //           return target.apply(thisArg, argArray);\r\n                //         },\r\n                //         has(target, path) {\r\n                //           return path in target || path in target.$origin;\r\n                //         },\r\n                //       });\r\n                //     const scaleYRaw = (domain) =>\r\n                //       (scaleYRaw.$origin(domain) - offsetY) * Math.exp(delta) + offsetY;\r\n                //     scaleYRaw.invert = (range) =>\r\n                //       scaleYRaw.$origin.invert(\r\n                //         (range - offsetY) / Math.exp(delta) + offsetY\r\n                //       );\r\n                //     scaleYRaw.$origin = sy;\r\n                //     scaleYRaw.copy = () => {\r\n                //       const anotherScaleYRaw = (domain) =>\r\n                //         (anotherScaleYRaw.$origin(domain) - offsetY) * Math.exp(delta) +\r\n                //         offsetY;\r\n                //       Object.assign(anotherScaleYRaw, scaleYRaw);\r\n                //       anotherScaleYRaw.invert = (range) =>\r\n                //         anotherScaleYRaw.$origin.invert(\r\n                //           (range - offsetY) / Math.exp(delta) + offsetY\r\n                //         );\r\n                //       anotherScaleYRaw.$origin = sy.copy();\r\n                //       return proxyRaw(anotherScaleYRaw as any);\r\n                //     };\r\n                //     const scaleY = proxyRaw(scaleYRaw);\r\n                //     transformer.setTransformation(\"scaleY\", scaleY);\r\n                //   }\r\n                // }\r\n            },\r\n        ],\r\n        abort: [\r\n            ({ layer, event, instrument, transformer }) => {\r\n                // const sx = transformer.getTransformation(\"$$scaleX\");\r\n                // const sy = transformer.getTransformation(\"$$scaleY\");\r\n                // instrument.setSharedVar(\"delta\", 0);\r\n                // instrument.setSharedVar(\"currentx\", event.offsetX);\r\n                // instrument.setSharedVar(\"currenty\", event.offsetY);\r\n                // if (sx) {\r\n                //   transformer.setTransformation(\"scaleX\", sx);\r\n                // }\r\n                // if (sy) {\r\n                //   transformer.setTransformation(\"scaleY\", sy);\r\n                // }\r\n                // layer.getLayerFromQueue(\"selectionLayer\").getGraphic().innerHTML = \"\";\r\n                // layer.getLayerFromQueue(\"transientLayer\").getGraphic().innerHTML = \"\";\r\n            },\r\n        ],\r\n    },\r\n});\r\nInstrument.register(\"SemanticZoomInstrument\", {\r\n    constructor: Instrument,\r\n    interactors: [\"MouseWheelInteractor\"],\r\n    sharedVar: {\r\n        currentLevel: 0,\r\n    },\r\n    on: {\r\n        wheel: [\r\n            ({ layer, instrument, event }) => {\r\n                const layerGraphic = layer.getGraphic();\r\n                const layerRoot = d3.select(layerGraphic);\r\n                let transformers = instrument.transformers;\r\n                if (!transformers.length) {\r\n                    transformers = GraphicalTransformer.findTransformerByLayer(layer);\r\n                }\r\n                const scaleLevels = instrument.getSharedVar(\"scaleLevels\");\r\n                let currentLevel = instrument.getSharedVar(\"currentLevel\");\r\n                currentLevel += Math.sign(event.deltaY);\r\n                instrument.setSharedVar(\"currentLevel\", currentLevel);\r\n                if (typeof scaleLevels === \"object\") {\r\n                    const closestLevel = Object.keys(scaleLevels).reduce(function (prev, curr) {\r\n                        return Math.abs(parseInt(curr) - currentLevel) <\r\n                            Math.abs(parseInt(prev) - currentLevel)\r\n                            ? curr\r\n                            : prev;\r\n                    });\r\n                    transformers.forEach((t) => t.setSharedVars(scaleLevels[closestLevel]));\r\n                }\r\n                instrument.setSharedVar(\"currentx\", event.offsetX);\r\n                instrument.setSharedVar(\"currenty\", event.offsetY);\r\n                let delta = event.deltaY;\r\n                instrument.setSharedVar(\"delta\", delta);\r\n                let cumulativeDelta = instrument.getSharedVar(\"cumulativeDelta\", {\r\n                    defaultValue: 0,\r\n                });\r\n                cumulativeDelta += delta;\r\n                instrument.setSharedVar(\"cumulativeDelta\", cumulativeDelta);\r\n                delta /= 1000;\r\n                const [x, y] = d3.pointer(event, layerGraphic);\r\n                const offsetX = instrument.getSharedVar(\"centroidX\") || x;\r\n                const offsetY = instrument.getSharedVar(\"centroidY\") || y;\r\n                const fixRange = instrument.getSharedVar(\"fixRange\") ?? false;\r\n                transformers.forEach((transformer) => {\r\n                    const sx = transformer.getSharedVar(\"scaleX\");\r\n                    const sy = transformer.getSharedVar(\"scaleY\");\r\n                    if (fixRange) {\r\n                        if (sx) {\r\n                            if (sx.type === \"time\") {\r\n                                const offsetXDomain = sx.invert(offsetX);\r\n                                sx.domain(sx\r\n                                    .domain()\r\n                                    .map((d) => new Date(d.getTime() - offsetXDomain.getTime()))\r\n                                    .map((d) => new Date(d.getTime() * Math.exp(-delta)))\r\n                                    .map((d) => new Date(d.getTime() + offsetXDomain.getTime())));\r\n                            }\r\n                            else {\r\n                                const offsetXDomain = sx.invert(offsetX);\r\n                                sx.domain(sx\r\n                                    .domain()\r\n                                    .map((d) => d - offsetXDomain)\r\n                                    .map((d) => d * Math.exp(-delta))\r\n                                    .map((d) => d + offsetXDomain));\r\n                            }\r\n                            transformers.forEach((transformer) => transformer.setSharedVar(\"scaleX\", sx));\r\n                        }\r\n                        if (sy) {\r\n                            if (sy.type === \"time\") {\r\n                                const offsetYDomain = sy.invert(offsetY);\r\n                                sy.domain(sy\r\n                                    .domain()\r\n                                    .map((d) => new Date(d.getTime() - offsetYDomain.getTime()))\r\n                                    .map((d) => new Date(d.getTime() * Math.exp(-delta)))\r\n                                    .map((d) => new Date(d.getTime() + offsetYDomain.getTime())));\r\n                            }\r\n                            else {\r\n                                const offsetYDomain = sy.invert(offsetY);\r\n                                sy.domain(sy\r\n                                    .domain()\r\n                                    .map((d) => d - offsetYDomain)\r\n                                    .map((d) => d * Math.exp(-delta))\r\n                                    .map((d) => d + offsetYDomain));\r\n                            }\r\n                            transformers.forEach((transformer) => transformer.setSharedVar(\"scaleY\", sy));\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (sx) {\r\n                            const newRangeX = sx\r\n                                .range()\r\n                                .map((x) => (x - offsetX) * Math.exp(delta) + offsetX);\r\n                            sx.range(newRangeX);\r\n                            transformer.setSharedVar(\"scaleX\", sx);\r\n                        }\r\n                        if (sy) {\r\n                            const newRangeY = sy\r\n                                .range()\r\n                                .map((y) => (y - offsetY) * Math.exp(delta) + offsetY);\r\n                            sy.range(newRangeY);\r\n                            transformer.setSharedVar(\"scaleY\", sy);\r\n                        }\r\n                    }\r\n                });\r\n                // if (fixRange) {\r\n                //   if (sx) {\r\n                //     const scaleX = sx\r\n                //       .copy()\r\n                //       .domain(\r\n                //         sx.range().map((x) => (x - offsetX) * Math.exp(delta) + offsetX)\r\n                //       )\r\n                //       .range(sx.domain());\r\n                //     if (scaleX.clamp) scaleX.clamp(false);\r\n                //     scaleX.domain(sx.range().map((x) => scaleX(x))).range(sx.range());\r\n                //     transformers.forEach((transformer) => transformer.setSharedVar(\"scaleX\", scaleX));\r\n                //   }\r\n                //   if (sy) {\r\n                //     const scaleY = sy\r\n                //       .copy()\r\n                //       .domain(\r\n                //         sy.range().map((y) => (y - offsetY) * Math.exp(delta) + offsetY)\r\n                //       )\r\n                //       .range(sy.domain());\r\n                //     if (scaleY.clamp) scaleY.clamp(false);\r\n                //     scaleY.domain(sy.range().map((y) => scaleY(y))).range(sy.range());\r\n                //     transformers.forEach((transformer) => transformer.setSharedVar(\"scaleY\", scaleY));\r\n                //   }\r\n                // }\r\n                // else {\r\n                //   if (sx) {\r\n                //     const proxyRaw = (\r\n                //       raw: Transformation & { $origin: Transformation }\r\n                //     ) =>\r\n                //       new Proxy(raw, {\r\n                //         get(target, path) {\r\n                //           if (path in target) return target[path];\r\n                //           if (path === \"range\")\r\n                //             return (...args) =>\r\n                //               (target.$origin as any)\r\n                //                 .range(\r\n                //                   ...args.map(\r\n                //                     (x) => (x - offsetX) / Math.exp(delta) + offsetX\r\n                //                   )\r\n                //                 )\r\n                //                 .map((x) => (x - offsetX) * Math.exp(delta) + offsetX);\r\n                //           if (path === \"bandwidth\" && \"bandwidth\" in target.$origin) {\r\n                //             return () =>\r\n                //               (target.$origin as any).bandwidth() * Math.exp(delta);\r\n                //           }\r\n                //           return target.$origin[path];\r\n                //         },\r\n                //         apply(target, thisArg, argArray) {\r\n                //           return target.apply(thisArg, argArray);\r\n                //         },\r\n                //         has(target, path) {\r\n                //           return path in target || path in target.$origin;\r\n                //         },\r\n                //       });\r\n                //     const scaleXRaw = (domain) =>\r\n                //       (scaleXRaw.$origin(domain) - offsetX) * Math.exp(delta) + offsetX;\r\n                //     scaleXRaw.invert = (range) =>\r\n                //       scaleXRaw.$origin.invert(\r\n                //         (range - offsetX) / Math.exp(delta) + offsetX\r\n                //       );\r\n                //     scaleXRaw.$origin = sx;\r\n                //     scaleXRaw.copy = () => {\r\n                //       const anotherScaleXRaw = (domain) =>\r\n                //         (anotherScaleXRaw.$origin(domain) - offsetX) * Math.exp(delta) +\r\n                //         offsetX;\r\n                //       Object.assign(anotherScaleXRaw, scaleXRaw);\r\n                //       anotherScaleXRaw.$origin = sx.copy();\r\n                //       anotherScaleXRaw.invert = (range) =>\r\n                //         anotherScaleXRaw.$origin.invert(\r\n                //           (range - offsetX) / Math.exp(delta) + offsetX\r\n                //         );\r\n                //       return proxyRaw(anotherScaleXRaw as any);\r\n                //     };\r\n                //     const scaleX = proxyRaw(scaleXRaw);\r\n                //     transformer.setTransformation(\"scaleX\", scaleX);\r\n                //   }\r\n                //   if (sy) {\r\n                //     const proxyRaw = (\r\n                //       raw: Transformation & { $origin: Transformation }\r\n                //     ) =>\r\n                //       new Proxy(raw, {\r\n                //         get(target, path) {\r\n                //           if (path in target) return target[path];\r\n                //           if (path === \"range\")\r\n                //             return (...args) =>\r\n                //               (target.$origin as any)\r\n                //                 .range(...args)\r\n                //                 .map((y) => (y - offsetY) * Math.exp(delta) + offsetY);\r\n                //           if (path === \"bandwidth\" && \"bandwidth\" in target.$origin) {\r\n                //             return () =>\r\n                //               (target.$origin as any).bandwidth() * Math.exp(delta);\r\n                //           }\r\n                //           return target.$origin[path];\r\n                //         },\r\n                //         apply(target, thisArg, argArray) {\r\n                //           return target.apply(thisArg, argArray);\r\n                //         },\r\n                //         has(target, path) {\r\n                //           return path in target || path in target.$origin;\r\n                //         },\r\n                //       });\r\n                //     const scaleYRaw = (domain) =>\r\n                //       (scaleYRaw.$origin(domain) - offsetY) * Math.exp(delta) + offsetY;\r\n                //     scaleYRaw.invert = (range) =>\r\n                //       scaleYRaw.$origin.invert(\r\n                //         (range - offsetY) / Math.exp(delta) + offsetY\r\n                //       );\r\n                //     scaleYRaw.$origin = sy;\r\n                //     scaleYRaw.copy = () => {\r\n                //       const anotherScaleYRaw = (domain) =>\r\n                //         (anotherScaleYRaw.$origin(domain) - offsetY) * Math.exp(delta) +\r\n                //         offsetY;\r\n                //       Object.assign(anotherScaleYRaw, scaleYRaw);\r\n                //       anotherScaleYRaw.invert = (range) =>\r\n                //         anotherScaleYRaw.$origin.invert(\r\n                //           (range - offsetY) / Math.exp(delta) + offsetY\r\n                //         );\r\n                //       anotherScaleYRaw.$origin = sy.copy();\r\n                //       return proxyRaw(anotherScaleYRaw as any);\r\n                //     };\r\n                //     const scaleY = proxyRaw(scaleYRaw);\r\n                //     transformer.setTransformation(\"scaleY\", scaleY);\r\n                //   }\r\n                // }\r\n            },\r\n        ],\r\n        abort: [\r\n            ({ layer, event, instrument, transformer }) => {\r\n                // const sx = transformer.getTransformation(\"$$scaleX\");\r\n                // const sy = transformer.getTransformation(\"$$scaleY\");\r\n                // instrument.setSharedVar(\"delta\", 0);\r\n                // instrument.setSharedVar(\"currentx\", event.offsetX);\r\n                // instrument.setSharedVar(\"currenty\", event.offsetY);\r\n                // if (sx) {\r\n                //   transformer.setTransformation(\"scaleX\", sx);\r\n                // }\r\n                // if (sy) {\r\n                //   transformer.setTransformation(\"scaleY\", sy);\r\n                // }\r\n                // layer.getLayerFromQueue(\"selectionLayer\").getGraphic().innerHTML = \"\";\r\n                // layer.getLayerFromQueue(\"transientLayer\").getGraphic().innerHTML = \"\";\r\n            },\r\n        ],\r\n    },\r\n    postUse(instrument, layer) {\r\n        const scaleLevels = instrument.getSharedVar(\"scaleLevels\");\r\n        const transformers = instrument.transformers;\r\n        const currentLevel = instrument.getSharedVar(\"currentLevel\");\r\n        if (typeof scaleLevels === \"object\") {\r\n            const closestLevel = Object.keys(scaleLevels).reduce(function (prev, curr) {\r\n                return Math.abs(parseInt(curr) - currentLevel) <\r\n                    Math.abs(parseInt(prev) - currentLevel)\r\n                    ? curr\r\n                    : prev;\r\n            });\r\n            transformers.setSharedVars(scaleLevels[closestLevel]);\r\n        }\r\n    },\r\n});\r\nInstrument.register(\"ZoomXInstrument\", {\r\n    constructor: Instrument,\r\n    interactors: [\"MouseWheelInteractor\"],\r\n    on: {\r\n        wheel: [\r\n            ({ layer, instrument, event }) => {\r\n                const layerGraphic = layer.getGraphic();\r\n                const layerRoot = d3.select(layerGraphic);\r\n                const transformers = instrument.transformers;\r\n                instrument.setSharedVar(\"currentx\", event.offsetX);\r\n                // instrument.setSharedVar(\"currenty\", event.offsetY);\r\n                let delta = event.deltaY;\r\n                instrument.setSharedVar(\"delta\", delta);\r\n                let cumulativeDelta = instrument.getSharedVar(\"cumulativeDelta\", {\r\n                    defaultValue: 0,\r\n                });\r\n                cumulativeDelta += delta;\r\n                instrument.setSharedVar(\"cumulativeDelta\", cumulativeDelta);\r\n                delta /= 1000;\r\n                const [x, y] = d3.pointer(event, layerGraphic);\r\n                const offsetX = instrument.getSharedVar(\"centroidX\") || x;\r\n                // const offsetY = instrument.getSharedVar(\"centroidY\") || y;\r\n                const fixRange = instrument.getSharedVar(\"fixRange\") ?? false;\r\n                transformers.forEach((transformer) => {\r\n                    const sx = transformer.getSharedVar(\"scaleX\");\r\n                    // const sy = transformer.getSharedVar(\"scaleY\");\r\n                    if (fixRange) {\r\n                        if (sx) {\r\n                            const offsetXDomain = sx.invert(offsetX);\r\n                            sx.domain(sx\r\n                                .domain()\r\n                                .map((d) => d - offsetXDomain)\r\n                                .map((d) => d * Math.exp(-delta))\r\n                                .map((d) => d + offsetXDomain));\r\n                            transformers.forEach((transformer) => transformer.setSharedVar(\"scaleX\", sx));\r\n                        }\r\n                        // if (sy) {\r\n                        //   const offsetYDomain = sy.invert(offsetY);\r\n                        //   sy.domain(sy\r\n                        //     .domain()\r\n                        //     .map(d => d - offsetYDomain)\r\n                        //     .map(d => d * Math.exp(-delta))\r\n                        //     .map(d => d + offsetYDomain));\r\n                        //   transformers.forEach((transformer) => transformer.setSharedVar(\"scaleY\", sy));\r\n                        // }\r\n                    }\r\n                    else {\r\n                        if (sx) {\r\n                            const newRangeX = sx\r\n                                .range()\r\n                                .map((x) => (x - offsetX) * Math.exp(delta) + offsetX);\r\n                            sx.range(newRangeX);\r\n                            transformer.setSharedVar(\"scaleX\", sx);\r\n                        }\r\n                        // if (sy) {\r\n                        //   const newRangeY = sy.range().map((y) => (y - offsetY) * Math.exp(delta) + offsetY);\r\n                        //   sy.range(newRangeY);\r\n                        //   transformer.setSharedVar(\"scaleY\", sy);\r\n                        // }\r\n                    }\r\n                });\r\n            },\r\n        ],\r\n        abort: [\r\n            ({ layer, event, instrument, transformer }) => {\r\n                // const sx = transformer.getTransformation(\"$$scaleX\");\r\n                // const sy = transformer.getTransformation(\"$$scaleY\");\r\n                // instrument.setSharedVar(\"delta\", 0);\r\n                // instrument.setSharedVar(\"currentx\", event.offsetX);\r\n                // instrument.setSharedVar(\"currenty\", event.offsetY);\r\n                // if (sx) {\r\n                //   transformer.setTransformation(\"scaleX\", sx);\r\n                // }\r\n                // if (sy) {\r\n                //   transformer.setTransformation(\"scaleY\", sy);\r\n                // }\r\n                // layer.getLayerFromQueue(\"selectionLayer\").getGraphic().innerHTML = \"\";\r\n                // layer.getLayerFromQueue(\"transientLayer\").getGraphic().innerHTML = \"\";\r\n            },\r\n        ],\r\n    },\r\n});\r\n// function getTransformMatrix(transform: string){\r\n//   const regex = /.*matrix\\t*(\\t*\\t*).*/;\r\n//   return tran\r\n// }\r\n","import * as InstrumentConstructor from \"./instrument\";\r\nimport InstrumentClass from \"./instrument\";\r\nimport \"./builtin\";\r\nexport default InstrumentClass;\r\nexport const register = InstrumentConstructor.register;\r\nexport const initialize = InstrumentConstructor.initialize;\r\nexport const findInstrument = InstrumentConstructor.findInstrument;\r\nexport const instanceInstruments = InstrumentConstructor.instanceInstruments;\r\nexport const Instrument = InstrumentClass;\r\n","var _a;\r\nimport { Interactor } from \"../interactor\";\r\nimport * as helpers from \"../helpers\";\r\nimport { Command } from \"../command\";\r\nimport { Layer } from \"../layer\";\r\nimport { Service, findService } from \"../service\";\r\nimport { GraphicalTransformer } from \"../transformer\";\r\nexport const registeredInstruments = {};\r\nexport const instanceInstruments = [];\r\nconst EventDispatcher = new Map();\r\nconst EventQueue = [];\r\nlet eventHandling = false;\r\nexport default class Instrument {\r\n    constructor(baseName, options) {\r\n        this._transformers = [];\r\n        this._linkCache = {};\r\n        this[_a] = true;\r\n        options.preInitialize && options.preInitialize.call(this, this);\r\n        this._preInitialize = options.preInitialize ?? null;\r\n        this._postInitialize = options.postInitialize ?? null;\r\n        this._preAttach = options.preAttach ?? null;\r\n        this._postUse = options.postUse ?? null;\r\n        this._baseName = baseName;\r\n        this._userOptions = options;\r\n        this._name = options.name ?? baseName;\r\n        // this._on = helpers.deepClone(options.on ?? {});\r\n        this._on = Object.assign({}, options.on ?? {});\r\n        this._interactors = [];\r\n        this._layers = [];\r\n        this._layerInteractors = new Map();\r\n        this._services = options.services ?? [];\r\n        this._serviceInstances = [];\r\n        this._sharedVar = options.sharedVar ?? {};\r\n        this._transformers = options.transformers ?? [];\r\n        if (options.interactors) {\r\n            options.interactors.forEach((interactor) => {\r\n                if (typeof interactor === \"string\") {\r\n                    this.useInteractor(Interactor.initialize(interactor));\r\n                }\r\n                else if (\"options\" in interactor) {\r\n                    if (typeof interactor.interactor === \"string\") {\r\n                        this.useInteractor(Interactor.initialize(interactor.interactor, interactor.options));\r\n                    }\r\n                    else {\r\n                        this.useInteractor(interactor.interactor, interactor.options);\r\n                    }\r\n                }\r\n                else {\r\n                    this.useInteractor(interactor);\r\n                }\r\n            });\r\n        }\r\n        this._services.forEach((service) => {\r\n            if (typeof service === \"string\" || !(\"options\" in service)) {\r\n                this.useService(service);\r\n            }\r\n            else {\r\n                this.useService(service.service, service.options);\r\n            }\r\n        });\r\n        if (options.layers) {\r\n            options.layers.forEach((layer) => {\r\n                if (\"options\" in layer) {\r\n                    this.attach(layer.layer, layer.options);\r\n                }\r\n                else {\r\n                    this.attach(layer);\r\n                }\r\n            });\r\n        }\r\n        options.postInitialize && options.postInitialize.call(this, this);\r\n    }\r\n    emit(action, options) {\r\n        if (this._on[action]) {\r\n            this._on[action].forEach((feedforwardOrCommand) => {\r\n                if (feedforwardOrCommand instanceof Command) {\r\n                    feedforwardOrCommand.execute(Object.assign({\r\n                        self: this,\r\n                        layer: null,\r\n                        instrument: this,\r\n                        interactor: null,\r\n                    }, options || {}));\r\n                }\r\n                else {\r\n                    feedforwardOrCommand(Object.assign({\r\n                        self: this,\r\n                        layer: null,\r\n                        instrument: this,\r\n                        interactor: null,\r\n                    }, options || {}));\r\n                }\r\n            });\r\n        }\r\n        if (action.includes(\"confirm\")) {\r\n            this._serviceInstances.forEach((service) => {\r\n                service.invokeCommand();\r\n            });\r\n        }\r\n    }\r\n    on(action, feedforwardOrCommand) {\r\n        if (action instanceof Array) {\r\n            action.forEach((action) => {\r\n                if (!this._on[action]) {\r\n                    this._on[action] = [];\r\n                }\r\n                this._on[action].push(feedforwardOrCommand);\r\n            });\r\n        }\r\n        else {\r\n            if (!this._on[action]) {\r\n                this._on[action] = [];\r\n            }\r\n            this._on[action].push(feedforwardOrCommand);\r\n        }\r\n        return this;\r\n    }\r\n    off(action, feedforwardOrCommand) {\r\n        if (!this._on[action])\r\n            return;\r\n        if (this._on[action].includes(feedforwardOrCommand)) {\r\n            this._on[action].splice(this._on[action].indexOf(feedforwardOrCommand), 1);\r\n        }\r\n        return this;\r\n    }\r\n    _use(service, options) {\r\n        service.preAttach(this);\r\n        this._serviceInstances.push(service);\r\n        service.postUse(this);\r\n    }\r\n    useService(service, options) {\r\n        if (typeof service !== \"string\" &&\r\n            this._serviceInstances.includes(service)) {\r\n            return;\r\n        }\r\n        if (arguments.length >= 2) {\r\n            this._services.push({ service, options });\r\n        }\r\n        else {\r\n            this._services.push(service);\r\n        }\r\n        if (typeof service === \"string\") {\r\n            const services = findService(service);\r\n            services.forEach((service) => this._use(service, options));\r\n        }\r\n        else {\r\n            this._use(service, options);\r\n        }\r\n    }\r\n    useInteractor(interactor, options) {\r\n        interactor.preUse(this);\r\n        // TODO: inject options\r\n        if (arguments.length >= 2) {\r\n            this._interactors.push({ interactor, options });\r\n        }\r\n        else {\r\n            this._interactors.push(interactor);\r\n        }\r\n        this._layers.forEach((layer) => {\r\n            let layr;\r\n            if (layer instanceof Layer) {\r\n                layr = layer;\r\n            }\r\n            else {\r\n                layr = layer.layer;\r\n            }\r\n            if (!this._layerInteractors.has(layr)) {\r\n                this._layerInteractors.set(layr, []);\r\n            }\r\n            const copyInteractor = Interactor.initialize(interactor._baseName, interactor._userOptions);\r\n            this._layerInteractors.get(layr).push(copyInteractor);\r\n            copyInteractor.setActions(copyInteractor.getActions().map((action) => ({\r\n                ...action,\r\n                sideEffect: async (options) => {\r\n                    action.sideEffect && action.sideEffect(options);\r\n                    if (this._on[action.action]) {\r\n                        for (let command of this._on[action.action]) {\r\n                            try {\r\n                                if (command instanceof Command) {\r\n                                    await command.execute({\r\n                                        ...options,\r\n                                        self: this,\r\n                                        instrument: this,\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    await command({\r\n                                        ...options,\r\n                                        self: this,\r\n                                        instrument: this,\r\n                                    });\r\n                                }\r\n                            }\r\n                            catch (e) {\r\n                                console.error(e);\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n            })));\r\n            copyInteractor.getAcceptEvents().forEach((event) => {\r\n                if (!EventDispatcher.has(layr.getContainerGraphic())) {\r\n                    EventDispatcher.set(layr.getContainerGraphic(), new Map());\r\n                }\r\n                if (!EventDispatcher.get(layr.getContainerGraphic()).has(event)) {\r\n                    layr\r\n                        .getContainerGraphic()\r\n                        .addEventListener(event, this._dispatch.bind(this, layr, event));\r\n                    EventDispatcher.get(layr.getContainerGraphic()).set(event, []);\r\n                }\r\n                EventDispatcher.get(layr.getContainerGraphic())\r\n                    .get(event)\r\n                    .push([\r\n                    copyInteractor,\r\n                    layr,\r\n                    layer instanceof Layer ? null : layer.options,\r\n                    this,\r\n                ]);\r\n            });\r\n        });\r\n        interactor.postUse(this);\r\n    }\r\n    attach(layer, options) {\r\n        if (this._layers.find((l) => l instanceof Layer ? l === layer : l.layer === layer))\r\n            return; // Reject for duplicated attach\r\n        this.preAttach(layer, options ?? null);\r\n        if (arguments.length >= 2) {\r\n            this._layers.push({ layer, options });\r\n        }\r\n        else {\r\n            this._layers.push(layer);\r\n        }\r\n        this.postUse(layer);\r\n    }\r\n    getSharedVar(sharedName, options) {\r\n        if (!(sharedName in this._sharedVar) &&\r\n            options &&\r\n            \"defaultValue\" in options) {\r\n            this.setSharedVar(sharedName, options.defaultValue, options);\r\n        }\r\n        return this._sharedVar[sharedName];\r\n    }\r\n    setSharedVar(sharedName, value, options) {\r\n        this._sharedVar[sharedName] = value;\r\n        if (this._on[`update:${sharedName}`]) {\r\n            const feedforwardOrCommands = this._on[`update:${sharedName}`];\r\n            feedforwardOrCommands.forEach((feedforwardOrCommand) => {\r\n                if (feedforwardOrCommand instanceof Command) {\r\n                    feedforwardOrCommand.execute({\r\n                        self: this,\r\n                        layer: null,\r\n                        instrument: this,\r\n                        interactor: null,\r\n                    });\r\n                }\r\n                else {\r\n                    feedforwardOrCommand({\r\n                        self: this,\r\n                        layer: null,\r\n                        instrument: this,\r\n                        interactor: null,\r\n                    });\r\n                }\r\n            });\r\n        }\r\n        // const linkProps =\r\n        //   this.getSharedVar(\"linkProps\") || Object.keys(this._sharedVar);\r\n        // if (this._sharedVar.linking) {\r\n        //   for (let prop of linkProps) {\r\n        //     if (this._linkCache[prop] === this._sharedVar[prop]) continue;\r\n        //     this._sharedVar.linking.setSharedVar(prop, this._sharedVar[prop]);\r\n        //   }\r\n        // }\r\n    }\r\n    watchSharedVar(sharedName, handler) {\r\n        this.on(`update:${sharedName}`, handler);\r\n    }\r\n    preAttach(layer, options) {\r\n        this._preAttach && this._preAttach.call(this, this, layer);\r\n        this._interactors.forEach((interactor) => {\r\n            let inter;\r\n            if (interactor instanceof Interactor) {\r\n                inter = interactor;\r\n            }\r\n            else {\r\n                inter = interactor.interactor;\r\n            }\r\n            if (!this._layerInteractors.has(layer)) {\r\n                this._layerInteractors.set(layer, []);\r\n            }\r\n            const copyInteractor = Interactor.initialize(inter._baseName, inter._userOptions);\r\n            this._layerInteractors.get(layer).push(copyInteractor);\r\n            copyInteractor.setActions(copyInteractor.getActions().map((action) => ({\r\n                ...action,\r\n                sideEffect: async (options) => {\r\n                    action.sideEffect && action.sideEffect(options);\r\n                    if (this._on[action.action]) {\r\n                        for (let command of this._on[action.action]) {\r\n                            try {\r\n                                if (command instanceof Command) {\r\n                                    await command.execute({\r\n                                        ...options,\r\n                                        self: this,\r\n                                        instrument: this,\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    await command({\r\n                                        ...options,\r\n                                        self: this,\r\n                                        instrument: this,\r\n                                    });\r\n                                }\r\n                            }\r\n                            catch (e) {\r\n                                console.error(e);\r\n                            }\r\n                        }\r\n                    }\r\n                },\r\n            })));\r\n            copyInteractor.getAcceptEvents().forEach((event) => {\r\n                if (!EventDispatcher.has(layer.getContainerGraphic())) {\r\n                    EventDispatcher.set(layer.getContainerGraphic(), new Map());\r\n                }\r\n                if (!EventDispatcher.get(layer.getContainerGraphic()).has(event)) {\r\n                    layer\r\n                        .getContainerGraphic()\r\n                        .addEventListener(event, this._dispatch.bind(this, layer, event));\r\n                    EventDispatcher.get(layer.getContainerGraphic()).set(event, []);\r\n                }\r\n                EventDispatcher.get(layer.getContainerGraphic())\r\n                    .get(event)\r\n                    .push([copyInteractor, layer, options, this]);\r\n            });\r\n        });\r\n    }\r\n    async _dispatch(layer, event, e) {\r\n        if (layer._baseName !== \"Layer\") {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n            e.stopImmediatePropagation();\r\n        }\r\n        if (eventHandling) {\r\n            let existingEventIndex = EventQueue.findIndex((e) => e.instrument === this && e.layer === layer && e.eventType === event);\r\n            if (existingEventIndex >= 0) {\r\n                EventQueue.splice(existingEventIndex, 1);\r\n            }\r\n            EventQueue.push({ instrument: this, layer, eventType: event, event: e });\r\n            return;\r\n        }\r\n        eventHandling = true;\r\n        const layers = EventDispatcher.get(layer.getContainerGraphic())\r\n            .get(event)\r\n            .filter(([_, layr]) => layr._order >= 0);\r\n        layers.sort((a, b) => b[1]._order - a[1]._order);\r\n        let handled = false;\r\n        for (let [inter, layr, layerOption, instrument] of layers) {\r\n            if (e instanceof MouseEvent) {\r\n                if (layr._name?.toLowerCase().replaceAll(\"-\", \"\").replaceAll(\"_\", \"\") ===\r\n                    \"backgroundlayer\" ||\r\n                    layr._name?.toLowerCase().replaceAll(\"-\", \"\").replaceAll(\"_\", \"\") ===\r\n                        \"bglayer\" ||\r\n                    (layerOption && layerOption.pointerEvents === \"all\")) {\r\n                    // Default is `all` for BGLayer\r\n                }\r\n                else if (!layerOption || layerOption.pointerEvents === \"viewport\") {\r\n                    // Default is `viewport` for layers\r\n                    const maybeD3Layer = layr;\r\n                    if (maybeD3Layer._offset &&\r\n                        maybeD3Layer._width &&\r\n                        maybeD3Layer._height) {\r\n                        if (e.offsetX < maybeD3Layer._offset.x ||\r\n                            e.offsetX > maybeD3Layer._offset.x + maybeD3Layer._width ||\r\n                            e.offsetY < maybeD3Layer._offset.y ||\r\n                            e.offsetY > maybeD3Layer._offset.y + maybeD3Layer._height) {\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    // Others is `visiblePainted`\r\n                    const query = layr.picking({\r\n                        baseOn: helpers.QueryType.Shape,\r\n                        type: helpers.ShapeQueryType.Point,\r\n                        x: e.clientX,\r\n                        y: e.clientY,\r\n                    });\r\n                    if (query.length <= 0 && inter._state === \"start\")\r\n                        continue;\r\n                    const maybeD3Layer = layr;\r\n                    if (maybeD3Layer._offset &&\r\n                        maybeD3Layer._width &&\r\n                        maybeD3Layer._height) {\r\n                        if (e.offsetX < maybeD3Layer._offset.x ||\r\n                            e.offsetX > maybeD3Layer._offset.x + maybeD3Layer._width ||\r\n                            e.offsetY < maybeD3Layer._offset.y ||\r\n                            e.offsetY > maybeD3Layer._offset.y + maybeD3Layer._height) {\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            try {\r\n                let flag = await inter.dispatch(e, layr);\r\n                if (flag &&\r\n                    e instanceof MouseEvent &&\r\n                    layerOption &&\r\n                    layerOption.pointerEvents === \"visiblePainted\") {\r\n                    handled = true;\r\n                    break;\r\n                }\r\n            }\r\n            catch (e) {\r\n                console.error(e);\r\n                break;\r\n            }\r\n        }\r\n        // if (!handled && e instanceof MouseEvent) {\r\n        //   // default fallback of BGLayer\r\n        //   helpers.global.stopTransient = true;\r\n        // } else {\r\n        //   helpers.global.stopTransient = false;\r\n        // }\r\n        eventHandling = false;\r\n        if (EventQueue.length) {\r\n            const eventDescription = EventQueue.shift();\r\n            eventDescription.instrument._dispatch(eventDescription.layer, eventDescription.eventType, eventDescription.event);\r\n        }\r\n    }\r\n    postUse(layer) {\r\n        const graphic = layer.getGraphic();\r\n        graphic && graphic.style && (graphic.style.pointerEvents = \"auto\");\r\n        this._postUse && this._postUse.call(this, this, layer);\r\n    }\r\n    isInstanceOf(name) {\r\n        return this._baseName === name || this._name === name;\r\n    }\r\n    get services() {\r\n        return helpers.makeFindableList(this._serviceInstances.slice(0), Service, this.useService.bind(this), () => {\r\n            throw new Error(\"Do not support dynamic change service yet\");\r\n        }, this);\r\n    }\r\n    get transformers() {\r\n        return helpers.makeFindableList(this._transformers.slice(0), GraphicalTransformer, (e) => this._transformers.push(e), (e) => this._transformers.splice(this._transformers.indexOf(e), 1), this);\r\n    }\r\n    static register(baseName, options) {\r\n        registeredInstruments[baseName] = options;\r\n    }\r\n    static unregister(baseName) {\r\n        delete registeredInstruments[baseName];\r\n        return true;\r\n    }\r\n    static initialize(baseName, options) {\r\n        const mergedOptions = Object.assign({ constructor: Instrument }, registeredInstruments[baseName] ?? {}, options ?? {}, {\r\n            on: helpers.deepClone(Object.assign({}, (registeredInstruments[baseName] ?? {}).on ?? {}, options?.on ?? {})),\r\n            sharedVar: Object.assign({}, (registeredInstruments[baseName] ?? {}).sharedVar ?? {}, options?.sharedVar ?? {}),\r\n        });\r\n        const instrument = new mergedOptions.constructor(baseName, mergedOptions);\r\n        instanceInstruments.push(instrument);\r\n        return instrument;\r\n    }\r\n    static findInstrument(baseNameOrRealName) {\r\n        return instanceInstruments.filter((instrument) => instrument.isInstanceOf(baseNameOrRealName));\r\n    }\r\n}\r\n_a = helpers.LibraSymbol;\r\nexport const register = Instrument.register;\r\nexport const unregister = Instrument.unregister;\r\nexport const initialize = Instrument.initialize;\r\nexport const findInstrument = Instrument.findInstrument;\r\n","import Interactor from \"./interactor\";\r\nInteractor.register(\"MousePositionInteractor\", {\r\n    constructor: Interactor,\r\n    state: \"start\",\r\n    actions: [\r\n        {\r\n            action: \"hover\",\r\n            events: [\"mousemove\"],\r\n            transition: [[\"start\", \"start\"]],\r\n        },\r\n        {\r\n            action: \"click\",\r\n            events: [\"mouseup\"],\r\n            transition: [[\"start\", \"start\"]],\r\n        },\r\n    ],\r\n});\r\nInteractor.register(\"TouchPositionInteractor\", {\r\n    constructor: Interactor,\r\n    state: \"start\",\r\n    actions: [\r\n        {\r\n            action: \"enter\",\r\n            events: [\"touchstart\"],\r\n            transition: [[\"start\", \"running\"]],\r\n        },\r\n        {\r\n            action: \"hover\",\r\n            events: [\"touchmove\"],\r\n            transition: [[\"running\", \"running\"]],\r\n        },\r\n        {\r\n            action: \"leave\",\r\n            events: [\"touchend\"],\r\n            transition: [\r\n                [\"running\", \"start\"],\r\n                [\"start\", \"start\"],\r\n            ],\r\n        },\r\n    ],\r\n});\r\nInteractor.register(\"MouseTraceInteractor\", {\r\n    constructor: Interactor,\r\n    state: \"start\",\r\n    actions: [\r\n        {\r\n            action: \"dragabort\",\r\n            events: [\"mousedown[event.button==2]\", \"mouseup[event.button==2]\"],\r\n            transition: [[\"drag\", \"start\"]],\r\n        },\r\n        {\r\n            action: \"dragstart\",\r\n            events: [\"mousedown\"],\r\n            transition: [[\"start\", \"drag\"]],\r\n        },\r\n        {\r\n            action: \"drag\",\r\n            events: [\"mousemove\"],\r\n            transition: [[\"drag\", \"drag\"]],\r\n        },\r\n        {\r\n            action: \"dragend\",\r\n            events: [\"mouseup[event.button==0]\"],\r\n            transition: [[\"drag\", \"start\"]],\r\n        },\r\n    ],\r\n});\r\nInteractor.register(\"TouchTraceInteractor\", {\r\n    constructor: Interactor,\r\n    state: \"start\",\r\n    actions: [\r\n        {\r\n            action: \"dragstart\",\r\n            events: [\"touchstart\"],\r\n            transition: [[\"start\", \"drag\"]],\r\n        },\r\n        {\r\n            action: \"drag\",\r\n            events: [\"touchmove\"],\r\n            transition: [[\"drag\", \"drag\"]],\r\n        },\r\n        {\r\n            action: \"dragend\",\r\n            events: [\"touchend\"],\r\n            transition: [[\"drag\", \"start\"]],\r\n        },\r\n        // {\r\n        //   action: \"dragabort\",\r\n        //   events: [\"mouseup[event.button==2]\",\"contextmenu\"],\r\n        //   transition: [\r\n        //     [\"drag\", \"start\"],\r\n        //     [\"start\", \"start\"],\r\n        //   ],\r\n        // },\r\n    ],\r\n});\r\nInteractor.register(\"SpeechControlInteractor\", {\r\n    constructor: Interactor,\r\n    state: \"start\",\r\n    actions: [\r\n        {\r\n            action: \"enableSpeech\",\r\n            events: [\"click\"],\r\n            transition: [[\"*\", \"speech:ready\"]],\r\n        },\r\n        {\r\n            action: \"disableSpeech\",\r\n            events: [\"mouseup[event.button==2]\"],\r\n            transition: [[\"*\", \"start\"]],\r\n        },\r\n        {\r\n            action: \"speech\",\r\n            events: [\"*\"],\r\n            transition: [[\"*\", \"speech:ready\"]],\r\n        },\r\n    ],\r\n});\r\nInteractor.register(\"KeyboardPositionInteractor\", {\r\n    constructor: Interactor,\r\n    state: \"start\",\r\n    actions: [\r\n        {\r\n            action: \"begin\",\r\n            events: [\"keydown[event.key===' ']\"],\r\n            transition: [[\"start\", \"running\"]],\r\n        },\r\n        {\r\n            action: \"up\",\r\n            events: [\r\n                \"keypress[event.key==='w' || event.key==='W']\",\r\n                \"keydown[event.key==='ArrowUp']{100}\",\r\n            ],\r\n            transition: [[\"running\", \"running\"]],\r\n        },\r\n        {\r\n            action: \"left\",\r\n            events: [\r\n                \"keypress[event.key==='a' || event.key==='A']\",\r\n                \"keydown[event.key==='ArrowLeft']{100}\",\r\n            ],\r\n            transition: [[\"running\", \"running\"]],\r\n        },\r\n        {\r\n            action: \"down\",\r\n            events: [\r\n                \"keypress[event.key==='s' || event.key==='S']\",\r\n                \"keydown[event.key==='ArrowDown']{100}\",\r\n            ],\r\n            transition: [[\"running\", \"running\"]],\r\n        },\r\n        {\r\n            action: \"right\",\r\n            events: [\r\n                \"keypress[event.key==='d' || event.key==='D']\",\r\n                \"keydown[event.key==='ArrowRight']{100}\",\r\n            ],\r\n            transition: [[\"running\", \"running\"]],\r\n        },\r\n        // {\r\n        //   action: \"end\",\r\n        //   events: [\"keydown[event.key===' ']\"] ,\r\n        //   transition: [\r\n        //     [\"running\", \"start\"],\r\n        //     [\"start\", \"start\"],\r\n        //   ],\r\n        // },\r\n    ],\r\n});\r\nInteractor.register(\"MouseWheelInteractor\", {\r\n    constructor: Interactor,\r\n    state: \"start\",\r\n    actions: [\r\n        {\r\n            action: \"enter\",\r\n            events: [\"mouseenter\"],\r\n            transition: [[\"start\", \"running\"]],\r\n        },\r\n        {\r\n            action: \"wheel\",\r\n            events: [\"wheel\", \"mousewheel\"],\r\n            transition: [[\"running\", \"running\"]],\r\n        },\r\n        {\r\n            action: \"leave\",\r\n            events: [\"mouseleave\"],\r\n            transition: [\r\n                [\"running\", \"start\"],\r\n                [\"start\", \"start\"],\r\n            ],\r\n        },\r\n        {\r\n            action: \"abort\",\r\n            events: [\"mouseup[event.button==2]\"],\r\n            transition: [\r\n                [\"running\", \"running\"],\r\n                [\"start\", \"start\"],\r\n            ],\r\n        },\r\n    ],\r\n});\r\n","import * as InstrumentConstructor from \"./interactor\";\r\nimport InteractorClass from \"./interactor\";\r\nimport \"./builtin\";\r\nexport default InteractorClass;\r\nexport const register = InteractorClass.register;\r\nexport const initialize = InteractorClass.initialize;\r\nexport const findInteractor = InteractorClass.findInteractor;\r\nexport const instanceInteractors = InstrumentConstructor.instanceInteractors;\r\nexport const Interactor = InteractorClass;\r\n","var _a;\r\nimport * as helpers from \"../helpers\";\r\nimport Actions from \"./actions.jsgf\";\r\nconst SR = window.SpeechRecognition || window.webkitSpeechRecognition;\r\nconst SGL = window.SpeechGrammarList || window.webkitSpeechGrammarList;\r\nconst registeredInteractors = {};\r\nexport const instanceInteractors = [];\r\nexport default class Interactor {\r\n    constructor(baseName, options) {\r\n        this[_a] = true;\r\n        options.preInitialize && options.preInitialize.call(this, this);\r\n        this._baseName = baseName;\r\n        this._userOptions = options;\r\n        this._name = options.name ?? baseName;\r\n        this._state = options.state;\r\n        this._actions = helpers\r\n            .deepClone(options.actions ?? [])\r\n            .map(transferInteractorInnerAction);\r\n        this._modalities = {};\r\n        this._preInitialize = options.preInitialize ?? null;\r\n        this._postInitialize = options.postInitialize ?? null;\r\n        this._preUse = options.preUse ?? null;\r\n        this._postUse = options.postUse ?? null;\r\n        options.postInitialize && options.postInitialize.call(this, this);\r\n    }\r\n    enableModality(modal) {\r\n        switch (modal) {\r\n            case \"speech\":\r\n                if (this._modalities[\"speech\"])\r\n                    break;\r\n                const recognition = new SR();\r\n                this._modalities[\"speech\"] = recognition;\r\n                const speechRecognitionList = new SGL();\r\n                speechRecognitionList.addFromString(Actions);\r\n                recognition.grammars = speechRecognitionList;\r\n                // recognition.continuous = true;\r\n                recognition.lang = \"en-US\";\r\n                break;\r\n        }\r\n    }\r\n    disableModality(modal) {\r\n        switch (modal) {\r\n            case \"speech\":\r\n                if (this._modalities[\"speech\"]) {\r\n                    this._modalities.speech.onresult = null;\r\n                    this._modalities.speech.onend = null;\r\n                    this._modalities[\"speech\"].abort();\r\n                    this._modalities[\"speech\"] = null;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    getActions() {\r\n        return this._actions.slice(0);\r\n    }\r\n    setActions(actions) {\r\n        const mergeActions = actions.concat(this._actions);\r\n        this._actions = mergeActions.filter((action, i) => i === mergeActions.findIndex((a) => a.action === action.action));\r\n    }\r\n    _parseEvent(event) {\r\n        const flatStream = (stream) => \"stream\" in stream\r\n            ? stream.between.concat(stream.stream).flatMap(flatStream)\r\n            : \"between\" in stream\r\n                ? stream.between\r\n                    .concat([{ type: stream.type }])\r\n                    .flatMap(flatStream)\r\n                : stream.type;\r\n        return helpers.parseEventSelector(event).flatMap(flatStream);\r\n    }\r\n    getAcceptEvents() {\r\n        return [\r\n            ...new Set(this._actions\r\n                .flatMap((action) => action.eventStreams.flatMap((eventStream) => eventStream.type))\r\n                .concat([\"contextmenu\"])),\r\n        ];\r\n    }\r\n    async dispatch(event, layer) {\r\n        const moveAction = this._actions.find((action) => {\r\n            const events = action.eventStreams.map((es) => es.type);\r\n            let inculdeEvent = false;\r\n            if (events.includes(\"*\"))\r\n                inculdeEvent = true;\r\n            if (event instanceof Event) {\r\n                inculdeEvent = action.eventStreams\r\n                    .filter((es) => es.type === event.type)\r\n                    .some((es) => es.filterFuncs ? es.filterFuncs.every((f) => f(event)) : true);\r\n            }\r\n            else {\r\n                if (events.includes(event))\r\n                    inculdeEvent = true;\r\n            }\r\n            return (inculdeEvent &&\r\n                (!action.transition ||\r\n                    action.transition.find((transition) => transition[0] === this._state || transition[0] === \"*\")));\r\n        });\r\n        if (moveAction) {\r\n            // if (event instanceof Event) {\r\n            //   event.preventDefault();\r\n            //   event.stopPropagation();\r\n            // }\r\n            const moveTransition = moveAction.transition &&\r\n                moveAction.transition.find((transition) => transition[0] === this._state || transition[0] === \"*\");\r\n            if (moveTransition) {\r\n                this._state = moveTransition[1];\r\n                if (this._state.startsWith(\"speech:\")) {\r\n                    this.enableModality(\"speech\");\r\n                    try {\r\n                        this._modalities.speech.start();\r\n                    }\r\n                    catch {\r\n                        // just ignore if already started\r\n                    }\r\n                    this._modalities.speech.onresult = (e) => {\r\n                        const result = e.results[e.resultIndex][0];\r\n                        this.dispatch(result.transcript, layer);\r\n                    };\r\n                    this._modalities.speech.onend = (e) => {\r\n                        this._modalities.speech.start();\r\n                    };\r\n                }\r\n                else {\r\n                    this.disableModality(\"speech\");\r\n                }\r\n                if (moveAction.sideEffect) {\r\n                    try {\r\n                        await moveAction.sideEffect({\r\n                            self: this,\r\n                            layer,\r\n                            instrument: null,\r\n                            interactor: this,\r\n                            event,\r\n                        });\r\n                    }\r\n                    catch (e) {\r\n                        console.error(e);\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    preUse(instrument) {\r\n        this._preUse && this._preUse.call(this, this, instrument);\r\n    }\r\n    postUse(instrument) {\r\n        this._postUse && this._postUse.call(this, this, instrument);\r\n    }\r\n    isInstanceOf(name) {\r\n        return (\"Interactor\" == name || this._baseName === name || this._name === name);\r\n    }\r\n    static register(baseName, options) {\r\n        registeredInteractors[baseName] = options;\r\n    }\r\n    static unregister(baseName) {\r\n        delete registeredInteractors[baseName];\r\n        return true;\r\n    }\r\n    static initialize(baseName, options) {\r\n        const mergedOptions = Object.assign({ constructor: Interactor }, registeredInteractors[baseName] ?? {}, options ?? {});\r\n        const interactor = new mergedOptions.constructor(baseName, mergedOptions);\r\n        instanceInteractors.push(interactor);\r\n        return interactor;\r\n    }\r\n    static findInteractor(baseNameOrRealName) {\r\n        return instanceInteractors.filter((instrument) => instrument.isInstanceOf(baseNameOrRealName));\r\n    }\r\n}\r\n_a = helpers.LibraSymbol;\r\nexport function transferInteractorInnerAction(originAction) {\r\n    const eventStreams = originAction.events.map((evtSelector) => {\r\n        if (typeof evtSelector === \"string\") {\r\n            return helpers.parseEventSelector(evtSelector)[0];\r\n        }\r\n        else {\r\n            const es = helpers.parseEventSelector(\"*\")[0];\r\n            es.filterFuncs = [evtSelector];\r\n        }\r\n    }); // do not accept combinator\r\n    return {\r\n        ...originAction,\r\n        eventStreams: eventStreams.map((es) => transferEventStream(es)),\r\n    };\r\n}\r\nfunction transferEventStream(es) {\r\n    return es.filter\r\n        ? {\r\n            ...es,\r\n            filterFuncs: es.filter\r\n                ? es.filter.map((f) => new Function(\"event\", `return ${f}`))\r\n                : [],\r\n        }\r\n        : { ...es };\r\n}\r\nexport const register = Interactor.register;\r\nexport const unregister = Interactor.unregister;\r\nexport const initialize = Interactor.initialize;\r\nexport const findInteractor = Interactor.findInteractor;\r\n","export default `#JSGF V1.0;\r\n\r\ngrammar actions;\r\n\r\npublic <action> = start | stop | pause | resume | play | delete | add | insert | create | remove | drag | move | drag | brush;`;\r\n","var _a;\r\nimport * as helpers from \"../helpers\";\r\nconst registeredLayers = {};\r\nconst instanceLayers = [];\r\nconst siblingLayers = new Map();\r\nconst orderLayers = new Map();\r\nexport default class Layer {\r\n    constructor(baseName, options) {\r\n        this._nextTick = 0;\r\n        this[_a] = true;\r\n        options.preInitialize && options.preInitialize.call(this, this);\r\n        this._baseName = baseName;\r\n        this._userOptions = options;\r\n        this._name = options.name ?? baseName;\r\n        // this._transformation = options.transformation ?? {};\r\n        // this._services = options.services ?? [];\r\n        this._container = options.container;\r\n        // this._sharedVar = options.sharedVar ?? {};\r\n        // this._sharedVarWatcher = {};\r\n        // this._transformationWatcher = {};\r\n        // this._serviceInstances = [];\r\n        this._order = 0;\r\n        // this._redraw = options.redraw;\r\n        this._preInitialize = options.preInitialize ?? null;\r\n        this._postInitialize = options.postInitialize ?? null;\r\n        this._preUpdate = options.preUpdate ?? null;\r\n        this._postUpdate = options.postUpdate ?? null;\r\n        // this._services.forEach((service) => {\r\n        //   if (typeof service === \"string\" || !(\"options\" in service)) {\r\n        //     this.use(service);\r\n        //   } else {\r\n        //     this.use(service.service, service.options);\r\n        //   }\r\n        // });\r\n        // this.redraw();\r\n        instanceLayers.push(this);\r\n        this._postInitialize && this._postInitialize.call(this, this);\r\n    }\r\n    getGraphic() {\r\n        return this._graphic;\r\n    }\r\n    getContainerGraphic() {\r\n        return this._container;\r\n    }\r\n    getVisualElements() {\r\n        return [];\r\n    }\r\n    cloneVisualElements(element, deep = false) {\r\n        const copiedElement = element.cloneNode(deep);\r\n        const frag = document.createDocumentFragment();\r\n        frag.append(copiedElement);\r\n        copiedElement.__libra__screenElement = element;\r\n        return copiedElement;\r\n    }\r\n    getDatum(elem) {\r\n        return null;\r\n    }\r\n    // getSharedVar(sharedName: string, defaultValue?: any): any {\r\n    //   if (sharedName in this._sharedVar) {\r\n    //     return this._sharedVar[sharedName];\r\n    //   } else {\r\n    //     this.setSharedVar(sharedName, defaultValue);\r\n    //     return defaultValue;\r\n    //   }\r\n    // }\r\n    // setSharedVar(sharedName: string, value: any): void {\r\n    //   this.preUpdate();\r\n    //   const oldValue = this._sharedVar[sharedName];\r\n    //   this._sharedVar[sharedName] = value;\r\n    //   // if (sharedName in this._sharedVarWatcher) {\r\n    //   //   this._sharedVarWatcher[sharedName].forEach((callback) => {\r\n    //   //     if (callback instanceof Command) {\r\n    //   //       callback.execute({\r\n    //   //         self: this,\r\n    //   //         layer: this,\r\n    //   //         instrument: null,\r\n    //   //         interactor: null,\r\n    //   //         value,\r\n    //   //         oldValue,\r\n    //   //       });\r\n    //   //     } else {\r\n    //   //       callback({ value, oldValue });\r\n    //   //     }\r\n    //   //   });\r\n    //   // }\r\n    //   this.postUpdate();\r\n    // }\r\n    // watchSharedVar(sharedName: string, handler: Function | Command): void {\r\n    //   if (!(sharedName in this._sharedVarWatcher)) {\r\n    //     this._sharedVarWatcher[sharedName] = [];\r\n    //   }\r\n    //   this._sharedVarWatcher[sharedName].push(handler);\r\n    // }\r\n    // getTransformation(\r\n    //   scaleName: string,\r\n    //   defaultValue?: helpers.Transformation\r\n    // ): helpers.Transformation {\r\n    //   if (scaleName in this._transformation) {\r\n    //     return this._transformation[scaleName];\r\n    //   } else {\r\n    //     this.setTransformation(scaleName, defaultValue);\r\n    //     return defaultValue;\r\n    //   }\r\n    // }\r\n    // setTransformation(\r\n    //   scaleName: string,\r\n    //   transformation: helpers.Transformation\r\n    // ): void {\r\n    //   this.preUpdate();\r\n    //   const oldValue = this._transformation[scaleName];\r\n    //   this._transformation[scaleName] = transformation;\r\n    //   if (this._nextTick) {\r\n    //     cancelAnimationFrame(this._nextTick);\r\n    //   }\r\n    //   this._nextTick = requestAnimationFrame(() => {\r\n    //     this.redraw();\r\n    //   });\r\n    //   // if (scaleName in this._transformationWatcher) {\r\n    //   //   this._transformationWatcher[scaleName].forEach((callback) => {\r\n    //   //     if (callback instanceof Command) {\r\n    //   //       callback.execute({\r\n    //   //         self: this,\r\n    //   //         layer: this,\r\n    //   //         instrument: null,\r\n    //   //         interactor: null,\r\n    //   //         value: transformation,\r\n    //   //         oldValue,\r\n    //   //       });\r\n    //   //     } else {\r\n    //   //       callback({ value: transformation, oldValue });\r\n    //   //     }\r\n    //   //   });\r\n    //   // }\r\n    //   this.postUpdate();\r\n    // }\r\n    // watchTransformation(scaleName: string, handler: Function | Command): void {\r\n    //   if (!(scaleName in this._transformationWatcher)) {\r\n    //     this._transformationWatcher[scaleName] = [];\r\n    //   }\r\n    //   this._transformationWatcher[scaleName].push(handler);\r\n    // }\r\n    // redraw(): void {\r\n    //   this.preUpdate();\r\n    //   if (this._redraw && this._redraw instanceof Function) {\r\n    //     this._redraw(\r\n    //       this._sharedVar,\r\n    //       this._transformation,\r\n    //       this._serviceInstances\r\n    //     );\r\n    //   }\r\n    //   this.postUpdate();\r\n    // }\r\n    join(rightTable, joinKey) {\r\n        return [];\r\n    }\r\n    preUpdate() {\r\n        this._preUpdate && this._preUpdate.call(this, this);\r\n    }\r\n    postUpdate() {\r\n        this._postUpdate && this._postUpdate.call(this, this);\r\n    }\r\n    picking(options) {\r\n        return [];\r\n    }\r\n    // _use(service: Service, options?: any) {\r\n    //   service.preAttach(this);\r\n    //   this._serviceInstances.push(service);\r\n    //   service.postUse(this);\r\n    // }\r\n    // use(service: string | Service, options?: any) {\r\n    //   if (\r\n    //     typeof service !== \"string\" &&\r\n    //     this._serviceInstances.includes(service)\r\n    //   ) {\r\n    //     return;\r\n    //   }\r\n    //   if (arguments.length >= 2) {\r\n    //     this._services.push({ service, options });\r\n    //   } else {\r\n    //     this._services.push(service);\r\n    //   }\r\n    //   if (typeof service === \"string\") {\r\n    //     const services = findService(service);\r\n    //     services.forEach((service) => this._use(service, options));\r\n    //   } else {\r\n    //     this._use(service, options);\r\n    //   }\r\n    // }\r\n    isPointInPolygon(point, polygon) {\r\n        let inside = false;\r\n        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\r\n            const xi = polygon[i].x, yi = polygon[i].y;\r\n            const xj = polygon[j].x, yj = polygon[j].y;\r\n            const intersect = yi > point.y !== yj > point.y &&\r\n                point.x < ((xj - xi) * (point.y - yi)) / (yj - yi) + xi;\r\n            if (intersect)\r\n                inside = !inside;\r\n        }\r\n        return inside;\r\n    }\r\n    pathIntersectsRect(path, rect) {\r\n        const pathLength = path.getTotalLength();\r\n        if (pathLength <= 0)\r\n            return false;\r\n        const step = pathLength / 100; // Check 100 points along the path\r\n        for (let i = 0; i <= pathLength; i += step) {\r\n            const point = path.getPointAtLength(i);\r\n            if (point.x >= rect.x &&\r\n                point.x <= rect.x + rect.width &&\r\n                point.y >= rect.y &&\r\n                point.y <= rect.y + rect.height) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    getLayerFromQueue(siblingLayerName) {\r\n        if (!siblingLayers.has(this)) {\r\n            siblingLayers.set(this, { [this._name]: this });\r\n        }\r\n        if (!orderLayers.has(this)) {\r\n            orderLayers.set(this, { [this._name]: 0 });\r\n        }\r\n        const siblings = siblingLayers.get(this);\r\n        if (!(siblingLayerName in siblings)) {\r\n            const layer = Layer.initialize(this._baseName, {\r\n                ...this._userOptions,\r\n                name: siblingLayerName,\r\n                group: \"\",\r\n                redraw() { },\r\n            });\r\n            siblings[siblingLayerName] = layer;\r\n            siblingLayers.set(layer, siblings);\r\n            const graphic = siblings[siblingLayerName].getGraphic();\r\n            graphic && graphic.style && (graphic.style.pointerEvents = \"none\");\r\n        }\r\n        if (!(siblingLayerName in orderLayers.get(this))) {\r\n            orderLayers.get(this)[siblingLayerName] = 0;\r\n        }\r\n        return siblings[siblingLayerName];\r\n    }\r\n    setLayersOrder(layerNameOrderKVPairs) {\r\n        if (!siblingLayers.has(this)) {\r\n            siblingLayers.set(this, { [this._name]: this });\r\n        }\r\n        if (!orderLayers.has(this)) {\r\n            orderLayers.set(this, { [this._name]: 0 });\r\n        }\r\n        const orders = orderLayers.get(this);\r\n        const frag = document.createDocumentFragment();\r\n        Object.entries(layerNameOrderKVPairs).forEach(([layerName, order]) => {\r\n            orders[layerName] = order;\r\n        });\r\n        Object.entries(orders)\r\n            .sort((a, b) => a[1] - b[1])\r\n            .forEach(([layerName, order]) => {\r\n            orders[layerName] = order;\r\n            orderLayers.set(this.getLayerFromQueue(layerName), orders);\r\n            if (order >= 0) {\r\n                const graphic = this.getLayerFromQueue(layerName).getGraphic(true);\r\n                // graphic && graphic.style && (graphic.style.pointerEvents = \"auto\");\r\n                graphic && graphic.style && (graphic.style.display = \"initial\");\r\n            }\r\n            else {\r\n                const graphic = this.getLayerFromQueue(layerName).getGraphic(true);\r\n                // graphic && graphic.style && (graphic.style.pointerEvents = \"none\");\r\n                graphic && graphic.style && (graphic.style.display = \"none\");\r\n            }\r\n            this.getLayerFromQueue(layerName)._order = order;\r\n            frag.append(this.getLayerFromQueue(layerName).getGraphic(true));\r\n        });\r\n        this.getContainerGraphic().appendChild(frag);\r\n    }\r\n    isInstanceOf(name) {\r\n        return this._baseName === name || this._name === name;\r\n    }\r\n}\r\n_a = helpers.LibraSymbol;\r\nexport function register(baseName, options) {\r\n    registeredLayers[baseName] = options;\r\n}\r\nexport function unregister(baseName) {\r\n    delete registeredLayers[baseName];\r\n    return true;\r\n}\r\nexport function initialize(baseName, options) {\r\n    const mergedOptions = Object.assign({ constructor: Layer }, registeredLayers[baseName] ?? {}, options ?? {}, {\r\n    // needs to deep merge object\r\n    // transformation: Object.assign(\r\n    //   {},\r\n    //   (registeredLayers[baseName] ?? {}).transformation ?? {},\r\n    //   options?.transformation ?? {}\r\n    // ),\r\n    // sharedVar: Object.assign(\r\n    //   {},\r\n    //   (registeredLayers[baseName] ?? {}).sharedVar ?? {},\r\n    //   options?.sharedVar ?? {}\r\n    // ),\r\n    });\r\n    const layer = new mergedOptions.constructor(baseName, mergedOptions);\r\n    return layer;\r\n}\r\nexport function findLayer(baseNameOrRealName) {\r\n    return instanceLayers.filter((layer) => layer.isInstanceOf(baseNameOrRealName));\r\n}\r\nLayer.register = register;\r\nLayer.initialize = initialize;\r\nLayer.findLayer = findLayer;\r\n","import Layer from \"./layer\";\r\nimport * as d3 from \"d3\";\r\nimport * as helpers from \"../helpers\";\r\nconst baseName = \"D3Layer\";\r\nconst backgroundClassName = \"ig-layer-background\";\r\nexport default class D3Layer extends Layer {\r\n    constructor(baseName, options) {\r\n        super(baseName, options);\r\n        this._width = options.width;\r\n        this._height = options.height;\r\n        this._offset = options.offset;\r\n        this._name = options.name;\r\n        this._graphic = d3\r\n            .select(options.container)\r\n            .append(\"g\")\r\n            .call((g) => {\r\n            if (this._name)\r\n                g.attr(\"className\", this._name);\r\n        })\r\n            .call((g) => {\r\n            if (this._offset)\r\n                g.attr(\"transform\", `translate(${this._offset.x || 0}, ${this._offset.y || 0})`);\r\n        })\r\n            .node();\r\n        d3.select(this._graphic)\r\n            .append(\"rect\")\r\n            .attr(\"class\", backgroundClassName)\r\n            .attr(\"width\", this._width)\r\n            .attr(\"height\", this._height)\r\n            .attr(\"opacity\", 0);\r\n        let tempElem = this._container;\r\n        while (tempElem && tempElem.tagName !== \"svg\")\r\n            tempElem = tempElem.parentElement;\r\n        if (tempElem.tagName !== \"svg\")\r\n            throw Error(\"Container must be wrapped in SVGSVGElement\");\r\n        this._svg = tempElem;\r\n        // this.redraw();\r\n        this._postInitialize && this._postInitialize.call(this, this);\r\n    }\r\n    // _toTemplate() {  // it is better to store initOption in base class.\r\n    //   return {\r\n    //     //...super._toTemplate(), !!!\r\n    //     extraParams: [this._width, this._height],\r\n    //   };\r\n    // }\r\n    getDatum(elem) {\r\n        if (!elem || (elem instanceof Array && elem.length == 0))\r\n            return null;\r\n        if (elem instanceof Array) {\r\n            return d3.selectAll(elem).datum();\r\n        }\r\n        return d3.select(elem).datum();\r\n    }\r\n    getVisualElements() {\r\n        const elems = [\r\n            ...this._graphic.querySelectorAll(`:root :not(.${backgroundClassName})`),\r\n        ];\r\n        return elems;\r\n    }\r\n    cloneVisualElements(element, deep = false) {\r\n        const copiedElement = d3.select(element).clone(deep).node();\r\n        const frag = document.createDocumentFragment();\r\n        frag.append(copiedElement);\r\n        copiedElement.__libra__screenElement = element;\r\n        return copiedElement;\r\n    }\r\n    // onObject(pointer: { x: number, y: number }): boolean {\r\n    //   const elements = document.elementsFromPoint(pointer.x, pointer.y);\r\n    //   return (\r\n    //     this._root.node().contains(element) &&\r\n    //     !element.classList.contains(backgroundClassName)\r\n    //   );\r\n    // }\r\n    // join(rightTable: any[], joinKey: string): any[] {\r\n    //   const leftTable = d3.select(this._graphic).selectChildren(\"*\").data();\r\n    //   const joinTable = leftTable.flatMap((obj) => {\r\n    //     if (typeof obj !== \"object\" || obj === undefined || obj === null)\r\n    //       return [];\r\n    //     return rightTable\r\n    //       .filter(\r\n    //         (rObj) =>\r\n    //           typeof obj === \"object\" &&\r\n    //           obj !== undefined &&\r\n    //           obj !== null &&\r\n    //           rObj[joinKey] === obj[joinKey]\r\n    //       )\r\n    //       .map((rObj) => ({ ...obj, ...rObj }));\r\n    //   });\r\n    //   return joinTable;\r\n    // }\r\n    select(selector) {\r\n        return this._graphic.querySelectorAll(selector);\r\n    }\r\n    picking(options) {\r\n        if (options.baseOn === helpers.QueryType.Shape) {\r\n            return this._shapeQuery(options);\r\n        }\r\n        else if (options.baseOn === helpers.QueryType.Data) {\r\n            return this._dataQuery(options);\r\n        }\r\n        else if (options.baseOn === helpers.QueryType.Attr) {\r\n            return this._attrQuery(options);\r\n        }\r\n        return [];\r\n    }\r\n    _isElementInLayer(elem) {\r\n        return (this._graphic.contains(elem) && // in layer\r\n            !elem.classList.contains(backgroundClassName)); // not background\r\n    }\r\n    // the x y position is relative to the viewport (clientX, clientY)\r\n    _shapeQuery(options) {\r\n        let result = [];\r\n        const svgBCR = this._svg.getBoundingClientRect();\r\n        const layerBCR = this._graphic.getBoundingClientRect();\r\n        if (options.type === helpers.ShapeQueryType.SurfacePoint) {\r\n            const { x, y } = options;\r\n            if (!isFinite(x) || !isFinite(y)) {\r\n                return [];\r\n            }\r\n            result = [...document.elementsFromPoint(x, y)].filter(this._isElementInLayer.bind(this));\r\n            if (result.length >= 1) {\r\n                result = [result[0]];\r\n            }\r\n        }\r\n        else if (options.type === helpers.ShapeQueryType.Point) {\r\n            const { x, y } = options;\r\n            if (!isFinite(x) || !isFinite(y)) {\r\n                return [];\r\n            }\r\n            result = document\r\n                .elementsFromPoint(x, y)\r\n                .filter(this._isElementInLayer.bind(this));\r\n        }\r\n        else if (options.type === helpers.ShapeQueryType.Circle) {\r\n            const x = options.x - svgBCR.left, y = options.y - svgBCR.top, r = options.r;\r\n            // Derive a special rect from a circle: the biggest square which the circle fully contains\r\n            const innerRectWidth = Math.floor(r * Math.sin(Math.PI / 4)) << 1;\r\n            const innerRectX = x - (innerRectWidth >>> 1);\r\n            const innerRectY = y - (innerRectWidth >>> 1);\r\n            const elemSet = new Set();\r\n            // get the elements intersect with the innerRect\r\n            const innerRect = this._svg.createSVGRect();\r\n            innerRect.x = innerRectX;\r\n            innerRect.y = innerRectY;\r\n            innerRect.width = innerRectWidth;\r\n            innerRect.height = innerRectWidth;\r\n            this._svg\r\n                .getIntersectionList(innerRect, this._graphic)\r\n                .forEach((elem) => elemSet.add(elem));\r\n            // Custom check for paths with no fill and zero stroke-width\r\n            const zeroStrokeWidthPaths = [\r\n                ...this._graphic.querySelectorAll(\"path\"),\r\n            ].filter((path) => {\r\n                const computedStyle = window.getComputedStyle(path);\r\n                return computedStyle.fill === \"none\";\r\n            });\r\n            if (zeroStrokeWidthPaths.length > 0) {\r\n                const customIntersectingPaths = zeroStrokeWidthPaths.filter((path) => {\r\n                    const transformedRect = this.transformRect(innerRect, this._graphic);\r\n                    return this.pathIntersectsRect(path, transformedRect);\r\n                });\r\n                customIntersectingPaths.forEach((elem) => elemSet.add(elem));\r\n            }\r\n            const outerRectWidth = r;\r\n            const outerRectX = x - r;\r\n            const outerRectY = y - r;\r\n            const outerElemSet = new Set();\r\n            // get the elements intersect with the outerRect\r\n            const outerRect = this._svg.createSVGRect();\r\n            outerRect.x = outerRectX;\r\n            outerRect.y = outerRectY;\r\n            outerRect.width = outerRectWidth * 2;\r\n            outerRect.height = outerRectWidth * 2;\r\n            this._svg\r\n                .getIntersectionList(outerRect, this._graphic)\r\n                .forEach((elem) => outerElemSet.add(elem));\r\n            if (zeroStrokeWidthPaths.length > 0) {\r\n                const customIntersectingPaths = zeroStrokeWidthPaths.filter((path) => {\r\n                    const transformedRect = this.transformRect(outerRect, this._graphic);\r\n                    return this.pathIntersectsRect(path, transformedRect);\r\n                });\r\n                customIntersectingPaths.forEach((elem) => outerElemSet.add(elem));\r\n            }\r\n            let outer = 1;\r\n            while (true) {\r\n                for (let elem of outerElemSet) {\r\n                    if (elemSet.has(elem))\r\n                        outerElemSet.delete(elem);\r\n                }\r\n                if (!outerElemSet.size)\r\n                    break;\r\n                if (outer * 2 + innerRectWidth >= r * 2)\r\n                    break;\r\n                const w = Math.sqrt(r * r - Math.pow(innerRectWidth / 2 + outer, 2));\r\n                const topRect = this._svg.createSVGRect();\r\n                topRect.x = x - w;\r\n                topRect.y = innerRectY - outer;\r\n                topRect.width = w * 2;\r\n                topRect.height = 1;\r\n                const bottomRect = this._svg.createSVGRect();\r\n                bottomRect.x = x - w;\r\n                bottomRect.y = innerRectY + innerRectWidth + outer - 1;\r\n                bottomRect.width = w * 2;\r\n                bottomRect.height = 1;\r\n                const leftRect = this._svg.createSVGRect();\r\n                leftRect.x = innerRectX - outer;\r\n                leftRect.y = y - w;\r\n                leftRect.width = 1;\r\n                leftRect.height = w * 2;\r\n                const rightRect = this._svg.createSVGRect();\r\n                rightRect.x = innerRectX + innerRectWidth + outer - 1;\r\n                rightRect.y = y - w;\r\n                rightRect.width = 1;\r\n                rightRect.height = w * 2;\r\n                [topRect, bottomRect, leftRect, rightRect].forEach((rect) => {\r\n                    this._svg\r\n                        .getIntersectionList(rect, this._graphic)\r\n                        .forEach((elem) => elemSet.add(elem));\r\n                    // Custom check for paths with no fill and zero stroke-width\r\n                    const zeroStrokeWidthPaths = [\r\n                        ...this._graphic.querySelectorAll(\"path\"),\r\n                    ].filter((path) => {\r\n                        const computedStyle = window.getComputedStyle(path);\r\n                        return computedStyle.fill === \"none\";\r\n                    });\r\n                    if (zeroStrokeWidthPaths.length > 0) {\r\n                        const customIntersectingPaths = zeroStrokeWidthPaths.filter((path) => {\r\n                            const transformedRect = this.transformRect(rect, this._graphic);\r\n                            return this.pathIntersectsRect(path, transformedRect);\r\n                        });\r\n                        customIntersectingPaths.forEach((elem) => elemSet.add(elem));\r\n                    }\r\n                });\r\n                outer++;\r\n            }\r\n            // // get the elements between circle and innerRect;\r\n            // for (let i = x - r; i <= x + r; i++) {\r\n            //   for (let j = y - r; j <= y + r; j++) {\r\n            //     if (\r\n            //       innerRect.x < i &&\r\n            //       i < innerRect.x + innerRect.width &&\r\n            //       innerRect.y < j &&\r\n            //       j < innerRect.y + innerRect.height\r\n            //     )\r\n            //       continue;\r\n            //     document\r\n            //       .elementsFromPoint(i + svgBCR.left, j + svgBCR.top)\r\n            //       .forEach((elem) => elemSet.add(elem));\r\n            //   }\r\n            // }\r\n            result = [...elemSet].filter(this._isElementInLayer.bind(this));\r\n        }\r\n        else if (options.type === helpers.ShapeQueryType.Rect) {\r\n            const { x, y, width, height } = options;\r\n            const x0 = Math.min(x, x + width) - svgBCR.left, y0 = Math.min(y, y + height) - svgBCR.top, absWidth = Math.abs(width), absHeight = Math.abs(height);\r\n            const rect = this._svg.createSVGRect();\r\n            rect.x = x0;\r\n            rect.y = y0;\r\n            rect.width = absWidth;\r\n            rect.height = absHeight;\r\n            // Get intersecting elements using the built-in method\r\n            result = [...this._svg.getIntersectionList(rect, this._graphic)]\r\n                .filter(this._isElementInLayer.bind(this))\r\n                .filter((elem) => !elem.classList.contains(backgroundClassName));\r\n            // Custom check for paths with no fill and zero stroke-width\r\n            const zeroStrokeWidthPaths = [\r\n                ...this._graphic.querySelectorAll(\"path\"),\r\n            ].filter((path) => {\r\n                const computedStyle = window.getComputedStyle(path);\r\n                return computedStyle.fill === \"none\";\r\n            });\r\n            if (zeroStrokeWidthPaths.length > 0) {\r\n                const customIntersectingPaths = zeroStrokeWidthPaths.filter((path) => {\r\n                    const transformedRect = this.transformRect(rect, this._graphic);\r\n                    return this.pathIntersectsRect(path, transformedRect);\r\n                });\r\n                result = [...new Set([...result, ...customIntersectingPaths])];\r\n            }\r\n        }\r\n        else if (options.type === helpers.ShapeQueryType.Polygon) {\r\n            const { points } = options;\r\n            const svgBCR = this._svg.getBoundingClientRect();\r\n            // Adjust points to SVG coordinate system\r\n            const adjustedPoints = points.map((p) => ({\r\n                x: p.x - svgBCR.left,\r\n                y: p.y - svgBCR.top,\r\n            }));\r\n            const elemSet = new Set();\r\n            this.queryLargestRectangles(adjustedPoints, elemSet);\r\n            result = Array.from(elemSet);\r\n        }\r\n        // getElementsFromPoint cannot get the SVGGElement since it will never be touched directly.\r\n        const resultWithSVGGElement = [];\r\n        while (result.length > 0) {\r\n            const elem = result.shift();\r\n            resultWithSVGGElement.push(elem);\r\n            if (elem.parentElement.tagName === \"g\" &&\r\n                this._graphic.contains(elem.parentElement) &&\r\n                this._graphic !== elem.parentElement)\r\n                result.push(elem.parentElement);\r\n        }\r\n        return resultWithSVGGElement;\r\n    }\r\n    _dataQuery(options) {\r\n        let result = [];\r\n        const visualElements = d3.selectAll(this.getVisualElements());\r\n        if (options.type === helpers.DataQueryType.Quantitative) {\r\n            const { attrName, extent } = options;\r\n            if (attrName instanceof Array) {\r\n                let intermediateResult = visualElements;\r\n                attrName.forEach((attrName, i) => {\r\n                    const ext = extent[i];\r\n                    intermediateResult = intermediateResult.filter((d) => d &&\r\n                        d[attrName] !== undefined &&\r\n                        ext[0] < d[attrName] &&\r\n                        d[attrName] < ext[1]);\r\n                });\r\n                result = intermediateResult.nodes();\r\n            }\r\n            else {\r\n                result = visualElements\r\n                    .filter((d) => d &&\r\n                    d[attrName] !== undefined &&\r\n                    extent[0] < d[attrName] &&\r\n                    d[attrName] < extent[1])\r\n                    .nodes();\r\n            }\r\n        }\r\n        else if (options.type === helpers.DataQueryType.Nominal) {\r\n            const { attrName, extent } = options;\r\n            if (attrName instanceof Array) {\r\n                let intermediateResult = visualElements;\r\n                attrName.forEach((attrName, i) => {\r\n                    const ext = extent[i];\r\n                    intermediateResult = intermediateResult.filter((d) => d && d[attrName] !== undefined && ext.findIndex(d[attrName]) >= 0);\r\n                });\r\n                result = intermediateResult.nodes();\r\n            }\r\n            else {\r\n                result = visualElements\r\n                    .filter((d) => d &&\r\n                    d[attrName] !== undefined &&\r\n                    extent.findIndex(d[attrName]) >= 0)\r\n                    .nodes();\r\n            }\r\n        }\r\n        else if (options.type === helpers.DataQueryType.Temporal) {\r\n            const { attrName, extent } = options;\r\n            if (attrName instanceof Array) {\r\n                let intermediateResult = visualElements;\r\n                attrName.forEach((attrName, i) => {\r\n                    const ext = extent[i];\r\n                    const dateParser = options.dateParser?.[i] ?? ((d) => d);\r\n                    intermediateResult = intermediateResult.filter((d) => d &&\r\n                        d[attrName] !== undefined &&\r\n                        ext[0].getTime() < dateParser(d[attrName]).getTime() &&\r\n                        dateParser(d[attrName]).getTime() < ext[1].getTime());\r\n                });\r\n                result = intermediateResult.nodes();\r\n            }\r\n            else {\r\n                const dateParser = options.dateParser || ((d) => d);\r\n                result = visualElements\r\n                    .filter((d) => d &&\r\n                    d[attrName] !== undefined &&\r\n                    extent[0].getTime() <\r\n                        dateParser(d[attrName]).getTime() &&\r\n                    dateParser(d[attrName]).getTime() <\r\n                        extent[1].getTime())\r\n                    .nodes();\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    _attrQuery(options) {\r\n        const { attrName, value } = options;\r\n        const result = d3\r\n            .select(this._graphic)\r\n            .filter((d) => d[attrName] === value)\r\n            .nodes();\r\n        return result;\r\n    }\r\n    transformRect(rect, referenceElement) {\r\n        if (!this._offset)\r\n            return rect;\r\n        const transformedRect = this._svg.createSVGRect();\r\n        transformedRect.x = rect.x - this._offset.x;\r\n        transformedRect.y = rect.y - this._offset.y;\r\n        transformedRect.width = rect.width;\r\n        transformedRect.height = rect.height;\r\n        return transformedRect;\r\n    }\r\n    queryLargestRectangles(points, elemSet) {\r\n        const boundingBox = this.getBoundingBox(points);\r\n        // Base case: if the area is too small, query the whole polygon as is\r\n        if ((boundingBox.maxX - boundingBox.minX) *\r\n            (boundingBox.maxY - boundingBox.minY) <\r\n            100) {\r\n            // Adjust this threshold as needed\r\n            this.queryPolygon(points, elemSet);\r\n            return;\r\n        }\r\n        const largestRect = this.findLargestRectangle(points, boundingBox);\r\n        // Query the largest rectangle\r\n        const rect = this._svg.createSVGRect();\r\n        rect.x = largestRect.x;\r\n        rect.y = largestRect.y;\r\n        rect.width = largestRect.width;\r\n        rect.height = largestRect.height;\r\n        const intersectingElements = [\r\n            ...this._svg.getIntersectionList(rect, this._graphic),\r\n        ]\r\n            .filter(this._isElementInLayer.bind(this))\r\n            .filter((elem) => !elem.classList.contains(backgroundClassName));\r\n        intersectingElements.forEach((elem) => elemSet.add(elem));\r\n        // Custom check for paths with no fill\r\n        const zeroFillPaths = [...this._graphic.querySelectorAll(\"path\")].filter((path) => {\r\n            const computedStyle = window.getComputedStyle(path);\r\n            return computedStyle.fill === \"none\";\r\n        });\r\n        if (zeroFillPaths.length > 0) {\r\n            const customIntersectingPaths = zeroFillPaths.filter((path) => {\r\n                const transformedRect = this.transformRect(rect, this._graphic);\r\n                return this.pathIntersectsRect(path, transformedRect);\r\n            });\r\n            customIntersectingPaths.forEach((elem) => elemSet.add(elem));\r\n        }\r\n        // Recursively handle the remaining areas\r\n        const remainingPolygons = this.subtractRectFromPolygon(points, largestRect);\r\n        remainingPolygons.forEach((polygon) => this.queryLargestRectangles(polygon, elemSet));\r\n    }\r\n    getBoundingBox(points) {\r\n        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\r\n        for (const point of points) {\r\n            minX = Math.min(minX, point.x);\r\n            minY = Math.min(minY, point.y);\r\n            maxX = Math.max(maxX, point.x);\r\n            maxY = Math.max(maxY, point.y);\r\n        }\r\n        return { minX, minY, maxX, maxY };\r\n    }\r\n    findLargestRectangle(points, boundingBox) {\r\n        // Implement an algorithm to find the largest rectangle in the polygon\r\n        // This is a complex problem. For simplicity, we'll use a basic approach here.\r\n        // You might want to implement a more sophisticated algorithm for better results.\r\n        const width = boundingBox.maxX - boundingBox.minX;\r\n        const height = boundingBox.maxY - boundingBox.minY;\r\n        let largestArea = 0;\r\n        let largestRect = { x: 0, y: 0, width: 0, height: 0 };\r\n        for (let x = boundingBox.minX; x < boundingBox.maxX; x += width / 10) {\r\n            for (let y = boundingBox.minY; y < boundingBox.maxY; y += height / 10) {\r\n                for (let w = width / 10; x + w <= boundingBox.maxX; w += width / 10) {\r\n                    for (let h = height / 10; y + h <= boundingBox.maxY; h += height / 10) {\r\n                        if (this.isRectangleInPolygon({ x, y, width: w, height: h }, points)) {\r\n                            const area = w * h;\r\n                            if (area > largestArea) {\r\n                                largestArea = area;\r\n                                largestRect = { x, y, width: w, height: h };\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return largestRect;\r\n    }\r\n    isRectangleInPolygon(rect, polygon) {\r\n        const corners = [\r\n            { x: rect.x, y: rect.y },\r\n            { x: rect.x + rect.width, y: rect.y },\r\n            { x: rect.x + rect.width, y: rect.y + rect.height },\r\n            { x: rect.x, y: rect.y + rect.height },\r\n        ];\r\n        return corners.every((corner) => this.isPointInPolygon(corner, polygon));\r\n    }\r\n    subtractRectFromPolygon(polygon, rect) {\r\n        // Implement polygon clipping to subtract the rectangle from the polygon\r\n        // This is a complex operation. For simplicity, we'll return the original polygon minus the rectangle corners.\r\n        // You might want to implement a proper polygon clipping algorithm for better results.\r\n        const remainingPoints = polygon.filter((point) => !(point.x >= rect.x &&\r\n            point.x <= rect.x + rect.width &&\r\n            point.y >= rect.y &&\r\n            point.y <= rect.y + rect.height));\r\n        // Add rectangle corners to ensure the remaining shape is properly defined\r\n        const rectCorners = [\r\n            { x: rect.x, y: rect.y },\r\n            { x: rect.x + rect.width, y: rect.y },\r\n            { x: rect.x + rect.width, y: rect.y + rect.height },\r\n            { x: rect.x, y: rect.y + rect.height },\r\n        ];\r\n        return [remainingPoints.concat(rectCorners)];\r\n    }\r\n    queryPolygon(points, elemSet) {\r\n        const boundingBox = this.getBoundingBox(points);\r\n        const rect = this._svg.createSVGRect();\r\n        rect.x = boundingBox.minX;\r\n        rect.y = boundingBox.minY;\r\n        rect.width = boundingBox.maxX - boundingBox.minX;\r\n        rect.height = boundingBox.maxY - boundingBox.minY;\r\n        const potentialElements = [\r\n            ...this._svg.getIntersectionList(rect, this._graphic),\r\n        ]\r\n            .filter(this._isElementInLayer.bind(this))\r\n            .filter((elem) => !elem.classList.contains(backgroundClassName));\r\n        potentialElements.forEach((elem) => {\r\n            const bbox = elem.getBBox();\r\n            const elemPoints = [\r\n                { x: bbox.x, y: bbox.y },\r\n                { x: bbox.x + bbox.width, y: bbox.y },\r\n                { x: bbox.x + bbox.width, y: bbox.y + bbox.height },\r\n                { x: bbox.x, y: bbox.y + bbox.height },\r\n            ];\r\n            if (elemPoints.some((point) => this.isPointInPolygon(point, points))) {\r\n                elemSet.add(elem);\r\n            }\r\n        });\r\n        // Custom check for paths with no fill\r\n        const zeroFillPaths = [...this._graphic.querySelectorAll(\"path\")].filter((path) => {\r\n            const computedStyle = window.getComputedStyle(path);\r\n            return computedStyle.fill === \"none\";\r\n        });\r\n        if (zeroFillPaths.length > 0) {\r\n            const customIntersectingPaths = zeroFillPaths.filter((path) => {\r\n                const transformedRect = this.transformRect(rect, this._graphic);\r\n                return this.pathIntersectsRect(path, transformedRect);\r\n            });\r\n            customIntersectingPaths.forEach((elem) => elemSet.add(elem));\r\n        }\r\n    }\r\n    pathIntersectsPolygon(path, polygon) {\r\n        const pathLength = path.getTotalLength();\r\n        const step = pathLength / 100; // Check 100 points along the path\r\n        for (let i = 0; i <= pathLength; i += step) {\r\n            const point = path.getPointAtLength(i);\r\n            if (this.isPointInPolygon(point, polygon)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nLayer.D3Layer = D3Layer;\r\nLayer.register(baseName, { constructor: D3Layer });\r\nLayer.register(baseName, { constructor: D3Layer });\r\n","import Layer from \"./layer\";\r\nimport * as d3 from \"d3\";\r\nimport * as helpers from \"../helpers\";\r\nimport { fromTransformAttribute, fromDefinition, compose, } from \"transformation-matrix\";\r\nconst baseName = \"VegaLayer\";\r\nconst backgroundClassName = \"background\";\r\nexport default class VegaLayer extends Layer {\r\n    constructor(baseName, options) {\r\n        super(baseName, options);\r\n        this._name = options.name;\r\n        this._container = options.container;\r\n        if (options.group) {\r\n            this._graphic = this._container.querySelector(`.${options.group}`);\r\n            // const bg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\r\n            // bg.setAttribute(\"class\", backgroundClassName);\r\n            // bg.setAttribute(\"x\", \"0\");\r\n            // bg.setAttribute(\"y\", \"0\");\r\n            // bg.setAttribute(\"width\", \"100%\");\r\n            // bg.setAttribute(\"height\", \"100%\");\r\n            // bg.setAttribute(\"fill\", \"transparent\");\r\n            // bg.setAttribute(\"pointer-events\", \"none\");\r\n            // this._graphic.prepend(bg);\r\n        }\r\n        else {\r\n            this._graphic = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\r\n            // this._graphic.setAttribute(\r\n            //   \"transform\",\r\n            //   options.container.querySelector(\"g\")?.getAttribute(\"transform\") ?? \"\"\r\n            // ); // Make the offset same as the Vega output\r\n            options.container.appendChild(this._graphic);\r\n        }\r\n        let tempElem = this._container;\r\n        while (tempElem && tempElem.tagName !== \"svg\")\r\n            tempElem = tempElem.parentElement;\r\n        if (tempElem.tagName !== \"svg\")\r\n            throw Error(\"Container must be wrapped in SVGSVGElement\");\r\n        this._svg = tempElem;\r\n        // this.redraw();\r\n        this._postInitialize && this._postInitialize.call(this, this);\r\n    }\r\n    // _toTemplate() {  // it is better to store initOption in base class.\r\n    //   return {\r\n    //     //...super._toTemplate(), !!!\r\n    //     extraParams: [this._width, this._height],\r\n    //   };\r\n    // }\r\n    get _offset() {\r\n        let matrixStr = \"translate(0, 0)\";\r\n        if ([...this._container.children].includes(this._graphic)) {\r\n            matrixStr =\r\n                this._container.querySelector(\"g\")?.getAttribute(\"transform\") ??\r\n                    \"translate(0,0)\";\r\n        }\r\n        else {\r\n            let currDom = this._graphic;\r\n            while (currDom != this._container) {\r\n                if (currDom.getAttribute(\"transform\")) {\r\n                    matrixStr += ` ${currDom.getAttribute(\"transform\")}`;\r\n                }\r\n                currDom = currDom.parentElement;\r\n            }\r\n        }\r\n        const matrix = compose(fromDefinition(fromTransformAttribute(matrixStr ?? \"translate(0,0)\")));\r\n        return { x: matrix.e, y: matrix.f };\r\n    }\r\n    getVisualElements() {\r\n        const elems = [\r\n            ...this._graphic.querySelectorAll(`:root :not(.${backgroundClassName})`),\r\n        ];\r\n        return elems;\r\n    }\r\n    getGraphic(real = false) {\r\n        if (this._userOptions.group) {\r\n            if (real) {\r\n                return [...this._container.children].find((el) => el.contains(this._graphic));\r\n            }\r\n            return this._container;\r\n        }\r\n        return this._graphic;\r\n    }\r\n    getDatum(elem) {\r\n        if (!elem || (elem instanceof Array && elem.length == 0))\r\n            return null;\r\n        if (elem instanceof Array) {\r\n            return d3.selectAll(elem).datum()?.datum;\r\n        }\r\n        return d3.select(elem).datum()?.datum;\r\n    }\r\n    cloneVisualElements(element, deep = false) {\r\n        const copiedElement = d3.select(element).clone(deep).node();\r\n        let currentElement = copiedElement.parentElement;\r\n        let transform = copiedElement.getAttribute(\"transform\") || \"\";\r\n        while (currentElement && currentElement != this._container) {\r\n            if (currentElement.getAttribute(\"transform\")) {\r\n                transform += ` ${currentElement.getAttribute(\"transform\")}`;\r\n            }\r\n            currentElement = currentElement.parentElement;\r\n        }\r\n        copiedElement.setAttribute(\"transform\", transform);\r\n        const frag = document.createDocumentFragment();\r\n        frag.append(copiedElement);\r\n        copiedElement.__libra__screenElement = element;\r\n        return copiedElement;\r\n    }\r\n    select(selector) {\r\n        return this._graphic.querySelectorAll(selector);\r\n    }\r\n    picking(options) {\r\n        if (options.baseOn === helpers.QueryType.Shape) {\r\n            return this._shapeQuery(options);\r\n        }\r\n        else if (options.baseOn === helpers.QueryType.Data) {\r\n            return this._dataQuery(options);\r\n        }\r\n        else if (options.baseOn === helpers.QueryType.Attr) {\r\n            return this._attrQuery(options);\r\n        }\r\n        return [];\r\n    }\r\n    _isElementInLayer(elem) {\r\n        return (this._graphic.contains(elem) && // in layer\r\n            !elem.classList.contains(backgroundClassName)); // not background\r\n    }\r\n    // the x y position is relative to the viewport (clientX, clientY)\r\n    _shapeQuery(options) {\r\n        let result = [];\r\n        const svgBCR = this._svg.getBoundingClientRect();\r\n        const layerBCR = this._graphic.getBoundingClientRect();\r\n        if (options.type === helpers.ShapeQueryType.SurfacePoint) {\r\n            const { x, y } = options;\r\n            if (!isFinite(x) || !isFinite(y)) {\r\n                return [];\r\n            }\r\n            result = [...document.elementsFromPoint(x, y)].filter((elem) => {\r\n                if (!this._isElementInLayer(elem))\r\n                    return false;\r\n                // fix chrome bug for stroke-width\r\n                const rect = elem.getBoundingClientRect();\r\n                return (rect.right >= x && rect.left <= x && rect.bottom >= y && rect.top <= y);\r\n            });\r\n            if (result.length >= 1) {\r\n                result = [result[0]];\r\n            }\r\n        }\r\n        else if (options.type === helpers.ShapeQueryType.Point) {\r\n            const { x, y } = options;\r\n            if (!isFinite(x) || !isFinite(y)) {\r\n                return [];\r\n            }\r\n            result = document.elementsFromPoint(x, y).filter((elem) => {\r\n                if (!this._isElementInLayer(elem))\r\n                    return false;\r\n                // fix chrome bug for stroke-width\r\n                const rect = elem.getBoundingClientRect();\r\n                return (rect.right >= x && rect.left <= x && rect.bottom >= y && rect.top <= y);\r\n            });\r\n        }\r\n        else if (options.type === helpers.ShapeQueryType.Circle) {\r\n            const rawX = options.x, rawY = options.y;\r\n            const x = options.x - svgBCR.left, y = options.y - svgBCR.top, r = options.r;\r\n            // Derive a special rect from a circle: the biggest square which the circle fully contains\r\n            const outerRectWidth = r;\r\n            const outerRectX = x - r;\r\n            const outerRectY = y - r;\r\n            const outerElemSet = new Set();\r\n            // get the elements intersect with the outerRect\r\n            const outerRect = this._svg.createSVGRect();\r\n            outerRect.x = outerRectX;\r\n            outerRect.y = outerRectY;\r\n            outerRect.width = outerRectWidth * 2;\r\n            outerRect.height = outerRectWidth * 2;\r\n            this._svg\r\n                .getIntersectionList(outerRect, this._graphic)\r\n                .forEach((elem) => outerElemSet.add(elem));\r\n            result = [...outerElemSet].filter((elem) => {\r\n                if (!this._isElementInLayer(elem))\r\n                    return false;\r\n                // fix chrome bug for stroke-width\r\n                const rect = elem.getBoundingClientRect();\r\n                const circleDistanceX = Math.abs(rawX - rect.left);\r\n                const circleDistanceY = Math.abs(rawY - rect.top);\r\n                if (circleDistanceX > rect.width / 2 + r) {\r\n                    return false;\r\n                }\r\n                if (circleDistanceY > rect.height / 2 + r) {\r\n                    return false;\r\n                }\r\n                if (circleDistanceX <= rect.width / 2) {\r\n                    return true;\r\n                }\r\n                if (circleDistanceY <= rect.height / 2) {\r\n                    return true;\r\n                }\r\n                const cornerDistance = Math.pow(circleDistanceX - rect.width / 2, 2) +\r\n                    Math.pow(circleDistanceY - rect.height / 2, 2);\r\n                return cornerDistance <= r * r;\r\n            });\r\n        }\r\n        else if (options.type === helpers.ShapeQueryType.Rect) {\r\n            const { x, y, width, height } = options;\r\n            const x0 = Math.min(x, x + width) - svgBCR.left, y0 = Math.min(y, y + height) - svgBCR.top, absWidth = Math.abs(width), absHeight = Math.abs(height);\r\n            const rect = this._svg.createSVGRect();\r\n            rect.x = x0;\r\n            rect.y = y0;\r\n            rect.width = absWidth;\r\n            rect.height = absHeight;\r\n            // Get intersecting elements using the built-in method\r\n            result = [...this._svg.getIntersectionList(rect, this._graphic)]\r\n                .filter(this._isElementInLayer.bind(this))\r\n                .filter((elem) => !elem.classList.contains(backgroundClassName));\r\n            // Custom check for paths with no fill and zero stroke-width\r\n            const zeroStrokeWidthPaths = [\r\n                ...this._graphic.querySelectorAll(\"path\"),\r\n            ].filter((path) => {\r\n                const computedStyle = window.getComputedStyle(path);\r\n                return computedStyle.fill === \"none\";\r\n            });\r\n            if (zeroStrokeWidthPaths.length > 0) {\r\n                const customIntersectingPaths = zeroStrokeWidthPaths.filter((path) => {\r\n                    const transformedRect = this.transformRect(rect, this._graphic);\r\n                    return this.pathIntersectsRect(path, transformedRect);\r\n                });\r\n                result = [...new Set([...result, ...customIntersectingPaths])];\r\n            }\r\n        }\r\n        else if (options.type === helpers.ShapeQueryType.Polygon) {\r\n            const { points } = options;\r\n            const svgBCR = this._svg.getBoundingClientRect();\r\n            // Adjust points to SVG coordinate system\r\n            const adjustedPoints = points.map((p) => ({\r\n                x: p.x - svgBCR.left,\r\n                y: p.y - svgBCR.top,\r\n            }));\r\n            const elemSet = new Set();\r\n            this.queryLargestRectangles(adjustedPoints, elemSet);\r\n            result = Array.from(elemSet);\r\n        }\r\n        // getElementsFromPoint cannot get the SVGGElement since it will never be touched directly.\r\n        const resultWithSVGGElement = [];\r\n        while (result.length > 0) {\r\n            const elem = result.shift();\r\n            if (elem.classList.contains(backgroundClassName))\r\n                continue;\r\n            resultWithSVGGElement.push(elem);\r\n            if (elem.parentElement.tagName === \"g\" &&\r\n                this._graphic.contains(elem.parentElement) &&\r\n                this._graphic !== elem.parentElement)\r\n                result.push(elem.parentElement);\r\n        }\r\n        return resultWithSVGGElement;\r\n    }\r\n    _dataQuery(options) {\r\n        let result = [];\r\n        // const visualElements = vega.selectAll(this.getVisualElements());\r\n        // if (options.type === helpers.DataQueryType.Quantitative) {\r\n        //   const { attrName, extent } = options;\r\n        //   if (attrName instanceof Array) {\r\n        //     let intermediateResult = visualElements;\r\n        //     attrName.forEach((attrName, i) => {\r\n        //       const ext = extent[i] as [number, number];\r\n        //       intermediateResult = intermediateResult.filter(\r\n        //         (d) =>\r\n        //           d &&\r\n        //           d[attrName] !== undefined &&\r\n        //           ext[0] < d[attrName] &&\r\n        //           d[attrName] < ext[1]\r\n        //       );\r\n        //     });\r\n        //     result = intermediateResult.nodes();\r\n        //   } else {\r\n        //     result = visualElements\r\n        //       .filter(\r\n        //         (d) =>\r\n        //           d &&\r\n        //           d[attrName] !== undefined &&\r\n        //           extent[0] < d[attrName] &&\r\n        //           d[attrName] < extent[1]\r\n        //       )\r\n        //       .nodes();\r\n        //   }\r\n        // } else if (options.type === helpers.DataQueryType.Nominal) {\r\n        //   const { attrName, extent } = options;\r\n        //   if (attrName instanceof Array) {\r\n        //     let intermediateResult = visualElements;\r\n        //     attrName.forEach((attrName, i) => {\r\n        //       const ext = extent[i] as unknown[];\r\n        //       intermediateResult = intermediateResult.filter(\r\n        //         (d) =>\r\n        //           d && d[attrName] !== undefined && ext.findIndex(d[attrName]) >= 0\r\n        //       );\r\n        //     });\r\n        //     result = intermediateResult.nodes();\r\n        //   } else {\r\n        //     result = visualElements\r\n        //       .filter(\r\n        //         (d) =>\r\n        //           d &&\r\n        //           d[attrName] !== undefined &&\r\n        //           extent.findIndex(d[attrName]) >= 0\r\n        //       )\r\n        //       .nodes();\r\n        //   }\r\n        // } else if (options.type === helpers.DataQueryType.Temporal) {\r\n        //   const { attrName, extent } = options;\r\n        //   if (attrName instanceof Array) {\r\n        //     let intermediateResult = visualElements;\r\n        //     attrName.forEach((attrName, i) => {\r\n        //       const ext = extent[i] as [Date, Date];\r\n        //       const dateParser = options.dateParser?.[i] ?? ((d: Date) => d);\r\n        //       intermediateResult = intermediateResult.filter(\r\n        //         (d) =>\r\n        //           d &&\r\n        //           d[attrName] !== undefined &&\r\n        //           ext[0].getTime() < dateParser(d[attrName]).getTime() &&\r\n        //           dateParser(d[attrName]).getTime() < ext[1].getTime()\r\n        //       );\r\n        //     });\r\n        //     result = intermediateResult.nodes();\r\n        //   } else {\r\n        //     const dateParser =\r\n        //       (options.dateParser as (d: unknown) => Date) || ((d: Date) => d);\r\n        //     result = visualElements\r\n        //       .filter(\r\n        //         (d) =>\r\n        //           d &&\r\n        //           d[attrName] !== undefined &&\r\n        //           (extent as [Date, Date])[0].getTime() <\r\n        //             dateParser(d[attrName]).getTime() &&\r\n        //           dateParser(d[attrName]).getTime() <\r\n        //             (extent as [Date, Date])[1].getTime()\r\n        //       )\r\n        //       .nodes();\r\n        //   }\r\n        // }\r\n        return result;\r\n    }\r\n    _attrQuery(options) {\r\n        const { attrName, value } = options;\r\n        // const result = vega\r\n        //   .select(this._graphic)\r\n        //   .filter((d) => d[attrName] === value)\r\n        //   .nodes();\r\n        // return result;\r\n        return [];\r\n    }\r\n    transformRect(rect, referenceElement) {\r\n        if (!this._offset)\r\n            return rect;\r\n        const transformedRect = this._svg.createSVGRect();\r\n        transformedRect.x = rect.x - this._offset.x;\r\n        transformedRect.y = rect.y - this._offset.y;\r\n        transformedRect.width = rect.width;\r\n        transformedRect.height = rect.height;\r\n        return transformedRect;\r\n    }\r\n    queryLargestRectangles(points, elemSet) {\r\n        const boundingBox = this.getBoundingBox(points);\r\n        // Base case: if the area is too small, query the whole polygon as is\r\n        if ((boundingBox.maxX - boundingBox.minX) *\r\n            (boundingBox.maxY - boundingBox.minY) <\r\n            100) {\r\n            // Adjust this threshold as needed\r\n            this.queryPolygon(points, elemSet);\r\n            return;\r\n        }\r\n        const largestRect = this.findLargestRectangle(points, boundingBox);\r\n        // Query the largest rectangle\r\n        const rect = this._svg.createSVGRect();\r\n        rect.x = largestRect.x;\r\n        rect.y = largestRect.y;\r\n        rect.width = largestRect.width;\r\n        rect.height = largestRect.height;\r\n        const intersectingElements = [\r\n            ...this._svg.getIntersectionList(rect, this._graphic),\r\n        ]\r\n            .filter(this._isElementInLayer.bind(this))\r\n            .filter((elem) => !elem.classList.contains(backgroundClassName));\r\n        intersectingElements.forEach((elem) => elemSet.add(elem));\r\n        // Custom check for paths with no fill\r\n        const zeroFillPaths = [...this._graphic.querySelectorAll(\"path\")].filter((path) => {\r\n            const computedStyle = window.getComputedStyle(path);\r\n            return computedStyle.fill === \"none\";\r\n        });\r\n        if (zeroFillPaths.length > 0) {\r\n            const customIntersectingPaths = zeroFillPaths.filter((path) => {\r\n                const transformedRect = this.transformRect(rect, this._graphic);\r\n                return this.pathIntersectsRect(path, transformedRect);\r\n            });\r\n            customIntersectingPaths.forEach((elem) => elemSet.add(elem));\r\n        }\r\n        // Recursively handle the remaining areas\r\n        const remainingPolygons = this.subtractRectFromPolygon(points, largestRect);\r\n        remainingPolygons.forEach((polygon) => this.queryLargestRectangles(polygon, elemSet));\r\n    }\r\n    getBoundingBox(points) {\r\n        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\r\n        for (const point of points) {\r\n            minX = Math.min(minX, point.x);\r\n            minY = Math.min(minY, point.y);\r\n            maxX = Math.max(maxX, point.x);\r\n            maxY = Math.max(maxY, point.y);\r\n        }\r\n        return { minX, minY, maxX, maxY };\r\n    }\r\n    findLargestRectangle(points, boundingBox) {\r\n        // Implement an algorithm to find the largest rectangle in the polygon\r\n        // This is a complex problem. For simplicity, we'll use a basic approach here.\r\n        // You might want to implement a more sophisticated algorithm for better results.\r\n        const width = boundingBox.maxX - boundingBox.minX;\r\n        const height = boundingBox.maxY - boundingBox.minY;\r\n        let largestArea = 0;\r\n        let largestRect = { x: 0, y: 0, width: 0, height: 0 };\r\n        for (let x = boundingBox.minX; x < boundingBox.maxX; x += width / 10) {\r\n            for (let y = boundingBox.minY; y < boundingBox.maxY; y += height / 10) {\r\n                for (let w = width / 10; x + w <= boundingBox.maxX; w += width / 10) {\r\n                    for (let h = height / 10; y + h <= boundingBox.maxY; h += height / 10) {\r\n                        if (this.isRectangleInPolygon({ x, y, width: w, height: h }, points)) {\r\n                            const area = w * h;\r\n                            if (area > largestArea) {\r\n                                largestArea = area;\r\n                                largestRect = { x, y, width: w, height: h };\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return largestRect;\r\n    }\r\n    isRectangleInPolygon(rect, polygon) {\r\n        const corners = [\r\n            { x: rect.x, y: rect.y },\r\n            { x: rect.x + rect.width, y: rect.y },\r\n            { x: rect.x + rect.width, y: rect.y + rect.height },\r\n            { x: rect.x, y: rect.y + rect.height },\r\n        ];\r\n        return corners.every((corner) => this.isPointInPolygon(corner, polygon));\r\n    }\r\n    subtractRectFromPolygon(polygon, rect) {\r\n        // Implement polygon clipping to subtract the rectangle from the polygon\r\n        // This is a complex operation. For simplicity, we'll return the original polygon minus the rectangle corners.\r\n        // You might want to implement a proper polygon clipping algorithm for better results.\r\n        const remainingPoints = polygon.filter((point) => !(point.x >= rect.x &&\r\n            point.x <= rect.x + rect.width &&\r\n            point.y >= rect.y &&\r\n            point.y <= rect.y + rect.height));\r\n        // Add rectangle corners to ensure the remaining shape is properly defined\r\n        const rectCorners = [\r\n            { x: rect.x, y: rect.y },\r\n            { x: rect.x + rect.width, y: rect.y },\r\n            { x: rect.x + rect.width, y: rect.y + rect.height },\r\n            { x: rect.x, y: rect.y + rect.height },\r\n        ];\r\n        return [remainingPoints.concat(rectCorners)];\r\n    }\r\n    queryPolygon(points, elemSet) {\r\n        const boundingBox = this.getBoundingBox(points);\r\n        const rect = this._svg.createSVGRect();\r\n        rect.x = boundingBox.minX;\r\n        rect.y = boundingBox.minY;\r\n        rect.width = boundingBox.maxX - boundingBox.minX;\r\n        rect.height = boundingBox.maxY - boundingBox.minY;\r\n        const potentialElements = [\r\n            ...this._svg.getIntersectionList(rect, this._graphic),\r\n        ]\r\n            .filter(this._isElementInLayer.bind(this))\r\n            .filter((elem) => !elem.classList.contains(backgroundClassName));\r\n        potentialElements.forEach((elem) => {\r\n            const bbox = elem.getBBox();\r\n            const elemPoints = [\r\n                { x: bbox.x, y: bbox.y },\r\n                { x: bbox.x + bbox.width, y: bbox.y },\r\n                { x: bbox.x + bbox.width, y: bbox.y + bbox.height },\r\n                { x: bbox.x, y: bbox.y + bbox.height },\r\n            ];\r\n            if (elemPoints.some((point) => this.isPointInPolygon(point, points))) {\r\n                elemSet.add(elem);\r\n            }\r\n        });\r\n        // Custom check for paths with no fill\r\n        const zeroFillPaths = [...this._graphic.querySelectorAll(\"path\")].filter((path) => {\r\n            const computedStyle = window.getComputedStyle(path);\r\n            return computedStyle.fill === \"none\";\r\n        });\r\n        if (zeroFillPaths.length > 0) {\r\n            const customIntersectingPaths = zeroFillPaths.filter((path) => {\r\n                const transformedRect = this.transformRect(rect, this._graphic);\r\n                return this.pathIntersectsRect(path, transformedRect);\r\n            });\r\n            customIntersectingPaths.forEach((elem) => elemSet.add(elem));\r\n        }\r\n    }\r\n    pathIntersectsPolygon(path, polygon) {\r\n        const pathLength = path.getTotalLength();\r\n        const step = pathLength / 100; // Check 100 points along the path\r\n        for (let i = 0; i <= pathLength; i += step) {\r\n            const point = path.getPointAtLength(i);\r\n            if (this.isPointInPolygon(point, polygon)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\nLayer.VegaLayer = VegaLayer;\r\nLayer.register(baseName, { constructor: VegaLayer });\r\nLayer.register(baseName, { constructor: VegaLayer });\r\n","import Layer from \"./layer\";\r\nimport * as d3 from \"d3\";\r\nimport * as helpers from \"../helpers\";\r\nimport { fromTransformAttribute, fromDefinition, compose, } from \"transformation-matrix\";\r\nconst baseName = \"PlotLayer\";\r\nconst backgroundClassName = \"background\";\r\nexport default class PlotLayer extends Layer {\r\n    constructor(baseName, options) {\r\n        super(baseName, options);\r\n        this._name = options.name;\r\n        this._container = options.container;\r\n        if (options.group) {\r\n            this._graphic = this._container.querySelector(`*[aria-label=\"${options.group}\"]`);\r\n            // const bg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\r\n            // bg.setAttribute(\"class\", backgroundClassName);\r\n            // bg.setAttribute(\"x\", \"0\");\r\n            // bg.setAttribute(\"y\", \"0\");\r\n            // bg.setAttribute(\"width\", \"100%\");\r\n            // bg.setAttribute(\"height\", \"100%\");\r\n            // bg.setAttribute(\"fill\", \"transparent\");\r\n            // bg.setAttribute(\"pointer-events\", \"none\");\r\n            // this._graphic.prepend(bg);\r\n        }\r\n        else {\r\n            this._graphic = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\r\n            // this._graphic.setAttribute(\r\n            //   \"transform\",\r\n            //   options.container.querySelector(\"g\")?.getAttribute(\"transform\") ?? \"\"\r\n            // ); // Make the offset same as the Plot output\r\n            options.container.appendChild(this._graphic);\r\n        }\r\n        let tempElem = this._container;\r\n        while (tempElem && tempElem.tagName !== \"svg\")\r\n            tempElem = tempElem.parentElement;\r\n        if (tempElem.tagName !== \"svg\")\r\n            throw Error(\"Container must be wrapped in SVGSVGElement\");\r\n        this._svg = tempElem;\r\n        // this.redraw();\r\n        this._postInitialize && this._postInitialize.call(this, this);\r\n    }\r\n    // _toTemplate() {  // it is better to store initOption in base class.\r\n    //   return {\r\n    //     //...super._toTemplate(), !!!\r\n    //     extraParams: [this._width, this._height],\r\n    //   };\r\n    // }\r\n    get _offset() {\r\n        let matrixStr = \"translate(0, 0)\";\r\n        if ([...this._container.children].includes(this._graphic)) {\r\n            matrixStr =\r\n                this._container.querySelector(\"g\")?.getAttribute(\"transform\") ??\r\n                    \"translate(0,0)\";\r\n        }\r\n        else {\r\n            let currDom = this._graphic;\r\n            while (currDom != this._container) {\r\n                if (currDom.getAttribute(\"transform\")) {\r\n                    matrixStr += ` ${currDom.getAttribute(\"transform\")}`;\r\n                }\r\n                currDom = currDom.parentElement;\r\n            }\r\n        }\r\n        const matrix = compose(fromDefinition(fromTransformAttribute(matrixStr ?? \"translate(0,0)\")));\r\n        return { x: matrix.e, y: matrix.f };\r\n    }\r\n    getVisualElements() {\r\n        const elems = [\r\n            ...this._graphic.querySelectorAll(`:root :not(.${backgroundClassName})`),\r\n        ];\r\n        return elems;\r\n    }\r\n    getGraphic(real = false) {\r\n        if (this._userOptions.group) {\r\n            if (real) {\r\n                return [...this._container.children].find((el) => el.contains(this._graphic));\r\n            }\r\n            return this._container;\r\n        }\r\n        return this._graphic;\r\n    }\r\n    getDatum(elem) {\r\n        if (!elem || (elem instanceof Array && elem.length == 0))\r\n            return null;\r\n        if (elem instanceof Array) {\r\n            return d3.selectAll(elem).datum()?.datum;\r\n        }\r\n        return d3.select(elem).datum()?.datum;\r\n    }\r\n    cloneVisualElements(element, deep = false) {\r\n        const copiedElement = d3.select(element).clone(deep).node();\r\n        let currentElement = copiedElement.parentElement;\r\n        let transform = copiedElement.getAttribute(\"transform\");\r\n        while (currentElement && currentElement != this._container) {\r\n            if (currentElement.getAttribute(\"transform\")) {\r\n                transform += ` ${currentElement.getAttribute(\"transform\")}`;\r\n            }\r\n            currentElement = currentElement.parentElement;\r\n        }\r\n        copiedElement.setAttribute(\"transform\", transform);\r\n        const frag = document.createDocumentFragment();\r\n        frag.append(copiedElement);\r\n        copiedElement.__libra__screenElement = element;\r\n        return copiedElement;\r\n    }\r\n    select(selector) {\r\n        return this._graphic.querySelectorAll(selector);\r\n    }\r\n    picking(options) {\r\n        if (options.baseOn === helpers.QueryType.Shape) {\r\n            return this._shapeQuery(options);\r\n        }\r\n        else if (options.baseOn === helpers.QueryType.Data) {\r\n            return this._dataQuery(options);\r\n        }\r\n        else if (options.baseOn === helpers.QueryType.Attr) {\r\n            return this._attrQuery(options);\r\n        }\r\n        return [];\r\n    }\r\n    _isElementInLayer(elem) {\r\n        return (this._graphic.contains(elem) && // in layer\r\n            !elem.classList.contains(backgroundClassName)); // not background\r\n    }\r\n    // the x y position is relative to the viewport (clientX, clientY)\r\n    _shapeQuery(options) {\r\n        let result = [];\r\n        const svgBCR = this._svg.getBoundingClientRect();\r\n        const layerBCR = this._graphic.getBoundingClientRect();\r\n        if (options.type === helpers.ShapeQueryType.SurfacePoint) {\r\n            const { x, y } = options;\r\n            if (!isFinite(x) || !isFinite(y)) {\r\n                return [];\r\n            }\r\n            result = [...document.elementsFromPoint(x, y)].filter((elem) => {\r\n                if (!this._isElementInLayer(elem))\r\n                    return false;\r\n                // fix chrome bug for stroke-width\r\n                const rect = elem.getBoundingClientRect();\r\n                return (rect.right >= x && rect.left <= x && rect.bottom >= y && rect.top <= y);\r\n            });\r\n            if (result.length >= 1) {\r\n                result = [result[0]];\r\n            }\r\n        }\r\n        else if (options.type === helpers.ShapeQueryType.Point) {\r\n            const { x, y } = options;\r\n            if (!isFinite(x) || !isFinite(y)) {\r\n                return [];\r\n            }\r\n            result = document.elementsFromPoint(x, y).filter((elem) => {\r\n                if (!this._isElementInLayer(elem))\r\n                    return false;\r\n                // fix chrome bug for stroke-width\r\n                const rect = elem.getBoundingClientRect();\r\n                return (rect.right >= x && rect.left <= x && rect.bottom >= y && rect.top <= y);\r\n            });\r\n        }\r\n        else if (options.type === helpers.ShapeQueryType.Circle) {\r\n            const rawX = options.x, rawY = options.y;\r\n            const x = options.x - svgBCR.left, y = options.y - svgBCR.top, r = options.r;\r\n            // Derive a special rect from a circle: the biggest square which the circle fully contains\r\n            const outerRectWidth = r;\r\n            const outerRectX = x - r;\r\n            const outerRectY = y - r;\r\n            const outerElemSet = new Set();\r\n            // get the elements intersect with the outerRect\r\n            const outerRect = this._svg.createSVGRect();\r\n            outerRect.x = outerRectX;\r\n            outerRect.y = outerRectY;\r\n            outerRect.width = outerRectWidth * 2;\r\n            outerRect.height = outerRectWidth * 2;\r\n            this._svg\r\n                .getIntersectionList(outerRect, this._graphic)\r\n                .forEach((elem) => outerElemSet.add(elem));\r\n            result = [...outerElemSet].filter((elem) => {\r\n                if (!this._isElementInLayer(elem))\r\n                    return false;\r\n                // fix chrome bug for stroke-width\r\n                const rect = elem.getBoundingClientRect();\r\n                const circleDistanceX = Math.abs(rawX - rect.left);\r\n                const circleDistanceY = Math.abs(rawY - rect.top);\r\n                if (circleDistanceX > rect.width / 2 + r) {\r\n                    return false;\r\n                }\r\n                if (circleDistanceY > rect.height / 2 + r) {\r\n                    return false;\r\n                }\r\n                if (circleDistanceX <= rect.width / 2) {\r\n                    return true;\r\n                }\r\n                if (circleDistanceY <= rect.height / 2) {\r\n                    return true;\r\n                }\r\n                const cornerDistance = Math.pow(circleDistanceX - rect.width / 2, 2) +\r\n                    Math.pow(circleDistanceY - rect.height / 2, 2);\r\n                return cornerDistance <= r * r;\r\n            });\r\n        }\r\n        else if (options.type === helpers.ShapeQueryType.Rect) {\r\n            const { x, y, width, height } = options;\r\n            const x0 = Math.min(x, x + width) - svgBCR.left, y0 = Math.min(y, y + height) - svgBCR.top, absWidth = Math.abs(width), absHeight = Math.abs(height);\r\n            const rect = this._svg.createSVGRect();\r\n            rect.x = x0;\r\n            rect.y = y0;\r\n            rect.width = absWidth;\r\n            rect.height = absHeight;\r\n            result = [...this._svg.getIntersectionList(rect, this._graphic)].filter((elem) => {\r\n                if (!this._isElementInLayer(elem))\r\n                    return false;\r\n                // fix chrome bug for stroke-width\r\n                const rect = elem.getBoundingClientRect();\r\n                return !(rect.right < x0 + svgBCR.left ||\r\n                    rect.left > x0 + absWidth + svgBCR.left ||\r\n                    rect.bottom < y0 + svgBCR.top ||\r\n                    rect.top > y0 + absHeight + svgBCR.top);\r\n            });\r\n        }\r\n        else if (options.type === helpers.ShapeQueryType.Polygon) {\r\n            // algorithms to determine if a point in a given polygon https://www.cnblogs.com/coderkian/p/3535977.html\r\n            const { points } = options;\r\n            const x0 = Math.min(...points.map((p) => p.x)) - svgBCR.left, y0 = Math.min(...points.map((p) => p.y)) - svgBCR.top, x1 = Math.max(...points.map((p) => p.x)) - svgBCR.left, y1 = Math.max(...points.map((p) => p.y)) - svgBCR.top;\r\n            const rect = this._svg.createSVGRect();\r\n            rect.x = x0;\r\n            rect.y = y0;\r\n            rect.width = x1 - x0;\r\n            rect.height = y1 - y0;\r\n            result = [...this._svg.getIntersectionList(rect, this._graphic)].filter((elem) => {\r\n                if (!this._isElementInLayer(elem))\r\n                    return false;\r\n                // fix chrome bug for stroke-width\r\n                const rect = elem.getBoundingClientRect();\r\n                return !(rect.right < x0 + svgBCR.left ||\r\n                    rect.left > x1 + svgBCR.left ||\r\n                    rect.bottom < y0 + svgBCR.top ||\r\n                    rect.top > y1 + svgBCR.top);\r\n            });\r\n        }\r\n        // getElementsFromPoint cannot get the SVGGElement since it will never be touched directly.\r\n        const resultWithSVGGElement = [];\r\n        while (result.length > 0) {\r\n            const elem = result.shift();\r\n            if (elem.classList.contains(backgroundClassName))\r\n                continue;\r\n            resultWithSVGGElement.push(elem);\r\n            if (elem.parentElement.tagName === \"g\" &&\r\n                this._graphic.contains(elem.parentElement) &&\r\n                this._graphic !== elem.parentElement)\r\n                result.push(elem.parentElement);\r\n        }\r\n        return resultWithSVGGElement;\r\n    }\r\n    _dataQuery(options) {\r\n        let result = [];\r\n        // const visualElements = plot.selectAll(this.getVisualElements());\r\n        // if (options.type === helpers.DataQueryType.Quantitative) {\r\n        //   const { attrName, extent } = options;\r\n        //   if (attrName instanceof Array) {\r\n        //     let intermediateResult = visualElements;\r\n        //     attrName.forEach((attrName, i) => {\r\n        //       const ext = extent[i] as [number, number];\r\n        //       intermediateResult = intermediateResult.filter(\r\n        //         (d) =>\r\n        //           d &&\r\n        //           d[attrName] !== undefined &&\r\n        //           ext[0] < d[attrName] &&\r\n        //           d[attrName] < ext[1]\r\n        //       );\r\n        //     });\r\n        //     result = intermediateResult.nodes();\r\n        //   } else {\r\n        //     result = visualElements\r\n        //       .filter(\r\n        //         (d) =>\r\n        //           d &&\r\n        //           d[attrName] !== undefined &&\r\n        //           extent[0] < d[attrName] &&\r\n        //           d[attrName] < extent[1]\r\n        //       )\r\n        //       .nodes();\r\n        //   }\r\n        // } else if (options.type === helpers.DataQueryType.Nominal) {\r\n        //   const { attrName, extent } = options;\r\n        //   if (attrName instanceof Array) {\r\n        //     let intermediateResult = visualElements;\r\n        //     attrName.forEach((attrName, i) => {\r\n        //       const ext = extent[i] as unknown[];\r\n        //       intermediateResult = intermediateResult.filter(\r\n        //         (d) =>\r\n        //           d && d[attrName] !== undefined && ext.findIndex(d[attrName]) >= 0\r\n        //       );\r\n        //     });\r\n        //     result = intermediateResult.nodes();\r\n        //   } else {\r\n        //     result = visualElements\r\n        //       .filter(\r\n        //         (d) =>\r\n        //           d &&\r\n        //           d[attrName] !== undefined &&\r\n        //           extent.findIndex(d[attrName]) >= 0\r\n        //       )\r\n        //       .nodes();\r\n        //   }\r\n        // } else if (options.type === helpers.DataQueryType.Temporal) {\r\n        //   const { attrName, extent } = options;\r\n        //   if (attrName instanceof Array) {\r\n        //     let intermediateResult = visualElements;\r\n        //     attrName.forEach((attrName, i) => {\r\n        //       const ext = extent[i] as [Date, Date];\r\n        //       const dateParser = options.dateParser?.[i] ?? ((d: Date) => d);\r\n        //       intermediateResult = intermediateResult.filter(\r\n        //         (d) =>\r\n        //           d &&\r\n        //           d[attrName] !== undefined &&\r\n        //           ext[0].getTime() < dateParser(d[attrName]).getTime() &&\r\n        //           dateParser(d[attrName]).getTime() < ext[1].getTime()\r\n        //       );\r\n        //     });\r\n        //     result = intermediateResult.nodes();\r\n        //   } else {\r\n        //     const dateParser =\r\n        //       (options.dateParser as (d: unknown) => Date) || ((d: Date) => d);\r\n        //     result = visualElements\r\n        //       .filter(\r\n        //         (d) =>\r\n        //           d &&\r\n        //           d[attrName] !== undefined &&\r\n        //           (extent as [Date, Date])[0].getTime() <\r\n        //             dateParser(d[attrName]).getTime() &&\r\n        //           dateParser(d[attrName]).getTime() <\r\n        //             (extent as [Date, Date])[1].getTime()\r\n        //       )\r\n        //       .nodes();\r\n        //   }\r\n        // }\r\n        return result;\r\n    }\r\n    _attrQuery(options) {\r\n        const { attrName, value } = options;\r\n        // const result = plot\r\n        //   .select(this._graphic)\r\n        //   .filter((d) => d[attrName] === value)\r\n        //   .nodes();\r\n        // return result;\r\n        return [];\r\n    }\r\n}\r\nLayer.PlotLayer = PlotLayer;\r\nLayer.register(baseName, { constructor: PlotLayer });\r\nLayer.register(baseName, { constructor: PlotLayer });\r\n","import * as LayerConstructor from \"./layer\";\r\nimport LayerClass from \"./layer\";\r\nimport \"./d3Layer\";\r\nimport \"./vegaLayer\";\r\nimport \"./plotLayer\";\r\nexport default LayerClass;\r\nexport const register = LayerConstructor.register;\r\nexport const initialize = LayerConstructor.initialize;\r\nexport const findLayer = LayerConstructor.findLayer;\r\nexport const Layer = LayerClass;\r\n","import Service from \"./service\";\r\nexport default class LayoutService extends Service {\r\n    constructor(baseName, options) {\r\n        super(baseName, {\r\n            ...options,\r\n            resultAlias: options.resultAlias ?? \"result\",\r\n        });\r\n    }\r\n    isInstanceOf(name) {\r\n        return (\"LayoutService\" === name || this._baseName === name || this._name === name);\r\n    }\r\n}\r\nService.LayoutService = LayoutService;\r\nService.register(\"LayoutService\", {\r\n    constructor: LayoutService,\r\n});\r\nService.register(\"ScaleService\", {\r\n    constructor: LayoutService,\r\n    evaluate({ offsetx, width, offsety, height, scaleX, scaleY, scaleX_Overview, scaleY_Overview, layer, self }) {\r\n        let layerInstance = layer;\r\n        if (!layerInstance &&\r\n            self._layerInstances &&\r\n            self._layerInstances.length == 1) {\r\n            layerInstance = self._layerInstances[0];\r\n        }\r\n        if (scaleX && scaleY && scaleX.invert && scaleY.invert) {\r\n            if ((width <= 0 || isNaN(width)) && (height <= 0 || isNaN(height)))\r\n                return { scaleX, scaleY };\r\n            else if (height <= 0 || isNaN(height)) {\r\n                const scaleXCopy = scaleX.copy();\r\n                const startX = scaleX_Overview.invert(offsetx - (layerInstance?._offset?.x ?? 0));\r\n                const endX = scaleX_Overview.invert(offsetx + width - (layerInstance?._offset?.x ?? 0));\r\n                scaleXCopy.domain([startX, endX]);\r\n                scaleXCopy.clamp(true);\r\n                return { scaleX: scaleXCopy };\r\n            }\r\n            else if (width <= 0 || isNaN(width)) {\r\n                const scaleYCopy = scaleY.copy();\r\n                const startY = scaleY_Overview.invert(offsety - (layerInstance?._offset?.y ?? 0));\r\n                const endY = scaleY_Overview.invert(offsety + height - (layerInstance?._offset?.y ?? 0));\r\n                if (scaleY.domain()[0] < scaleY.domain()[1]) {\r\n                    scaleYCopy.domain([endY, startY]);\r\n                }\r\n                else {\r\n                    scaleYCopy.domain([startY, endY]);\r\n                }\r\n                scaleYCopy.clamp(true);\r\n                return { scaleY: scaleYCopy };\r\n            }\r\n            else {\r\n                const scaleXCopy = scaleX.copy();\r\n                const scaleYCopy = scaleY.copy();\r\n                const startX = scaleX_Overview.invert(offsetx - (layerInstance?._offset?.x ?? 0));\r\n                const endX = scaleX_Overview.invert(offsetx + width - (layerInstance?._offset?.x ?? 0));\r\n                const startY = scaleY_Overview.invert(offsety - (layerInstance?._offset?.y ?? 0));\r\n                const endY = scaleY_Overview.invert(offsety + height - (layerInstance?._offset?.y ?? 0));\r\n                scaleXCopy.domain([startX, endX]);\r\n                if (scaleY.domain()[0] < scaleY.domain()[1]) {\r\n                    scaleYCopy.domain([endY, startY]);\r\n                }\r\n                else {\r\n                    scaleYCopy.domain([startY, endY]);\r\n                }\r\n                scaleXCopy.clamp(true);\r\n                scaleYCopy.clamp(true);\r\n                console.log(\"ScaleService evaluate\", offsetx, offsety, width, height);\r\n                return { scaleX: scaleXCopy, scaleY: scaleYCopy };\r\n            }\r\n        }\r\n        return { scaleX, scaleY };\r\n    },\r\n});\r\n","import Service from \"./service\";\r\nimport * as helpers from \"../helpers\";\r\nimport * as d3 from \"d3\";\r\nexport default class AnalysisService extends Service {\r\n    constructor(baseName, options) {\r\n        super(baseName, {\r\n            ...options,\r\n            resultAlias: options.resultAlias ?? \"result\",\r\n        });\r\n    }\r\n    isInstanceOf(name) {\r\n        return (\"AnalysisService\" === name ||\r\n            this._baseName === name ||\r\n            this._name === name);\r\n    }\r\n}\r\nService.AnalysisService = AnalysisService;\r\nService.register(\"AnalysisService\", {\r\n    constructor: AnalysisService,\r\n});\r\nService.register(\"FilterService\", {\r\n    constructor: AnalysisService,\r\n    evaluate({ data, extents, result, fields, self }) {\r\n        if (!extents && (!result || !result.length || !fields || !fields.length)) {\r\n            if (!extents)\r\n                return [];\r\n            return data;\r\n        }\r\n        if (!data) {\r\n            try {\r\n                const layerInstances = self._layerInstances;\r\n                if (layerInstances && layerInstances.length > 0) {\r\n                    data = [...layerInstances[0].getGraphic().childNodes]\r\n                        .filter((el) => layerInstances[0].getDatum(el))\r\n                        .map((el) => Object.assign(layerInstances[0].cloneVisualElements(el), layerInstances[0].getDatum(el)));\r\n                }\r\n            }\r\n            catch (e) {\r\n                console.error(\"failed to get data from layerInstances\", e);\r\n            }\r\n        }\r\n        if (extents) {\r\n            Object.entries(extents).forEach(([field, extent]) => {\r\n                if (extent[0] >= extent[1] || isNaN(extent[0]) || isNaN(extent[1]))\r\n                    return;\r\n                data = data.filter((d) => d[field] >= extent[0] && d[field] <= extent[1]);\r\n            });\r\n        }\r\n        else {\r\n            const layerInstances = self._layerInstances;\r\n            let datum = d3.selectAll(result).datum();\r\n            if (layerInstances && layerInstances.length > 0) {\r\n                datum = layerInstances[0].getDatum(result[0]);\r\n            }\r\n            if (datum)\r\n                fields.forEach((field) => {\r\n                    data = data.filter((d) => d[field] == datum[field]);\r\n                });\r\n        }\r\n        return data;\r\n    },\r\n});\r\nService.register(\"InterpolationService\", {\r\n    constructor: AnalysisService,\r\n    evaluate({ result, field, data, formula }) {\r\n        if (!result) {\r\n            return null;\r\n        }\r\n        const { data: fieldValue, interpolatedNum } = result;\r\n        if (!fieldValue || interpolatedNum === undefined || isNaN(interpolatedNum))\r\n            return null;\r\n        const baseNum = Math.floor(interpolatedNum);\r\n        const newValue = fieldValue[baseNum][field];\r\n        let newInterpolatedData = data.filter((d) => d[field] === newValue);\r\n        if (interpolatedNum > baseNum) {\r\n            const nextNum = baseNum + 1;\r\n            const interpolate = interpolatedNum - baseNum;\r\n            newInterpolatedData = newInterpolatedData.map((baseDatum) => {\r\n                const nextDatum = data.find((d) => d[field] === fieldValue[nextNum][field] &&\r\n                    !Object.entries(baseDatum).find(([k, v]) => typeof v !== \"number\" && d[k] !== v));\r\n                return Object.fromEntries(Object.entries(baseDatum).map(([k, v]) => {\r\n                    if (typeof v === \"number\") {\r\n                        return [k, v * (1 - interpolate) + nextDatum[k] * interpolate];\r\n                    }\r\n                    else {\r\n                        return [k, v];\r\n                    }\r\n                }));\r\n            });\r\n        }\r\n        return newInterpolatedData.map((d) => {\r\n            if (formula) {\r\n                Object.entries(formula).forEach(([k, v]) => {\r\n                    d[k] = v(d);\r\n                });\r\n            }\r\n            return d;\r\n        });\r\n    },\r\n});\r\nService.register(\"DataJoinService\", {\r\n    constructor: AnalysisService,\r\n    evaluate({ data, result, offset, scaleX, scaleY, fieldX, fieldY, replace, self, }) {\r\n        if (!result || result.length <= 0)\r\n            return data;\r\n        const layerInstances = self._layerInstances;\r\n        if (layerInstances && layerInstances.length > 0) {\r\n            const datum = layerInstances[0].getDatum(result[0]);\r\n            if (datum) {\r\n                const datumBackup = helpers.deepClone(datum);\r\n                if (offset !== undefined && scaleX && scaleX.invert && fieldX) {\r\n                    datum[fieldX] = scaleX.invert(scaleX(datum[fieldX]) + parseFloat(offset.x));\r\n                }\r\n                if (offset !== undefined &&\r\n                    scaleY &&\r\n                    scaleY.invert &&\r\n                    fieldY &&\r\n                    fieldY !== fieldX) {\r\n                    datum[fieldY] = scaleY.invert(scaleY(datum[fieldY]) + parseFloat(offset.y));\r\n                }\r\n                if (!replace) {\r\n                    const newData = helpers.deepClone(data);\r\n                    Object.assign(datum, datumBackup);\r\n                    return newData;\r\n                }\r\n                else {\r\n                    return data;\r\n                }\r\n            }\r\n        }\r\n        return data;\r\n    },\r\n});\r\nService.register(\"AggregateService\", {\r\n    constructor: AnalysisService,\r\n    evaluate({ result, operation, fields }) {\r\n        if (!(result instanceof Array))\r\n            return 0;\r\n        if (operation === \"average\") {\r\n            return Object.fromEntries(fields.map((field) => [\r\n                field,\r\n                result.reduce((sum, d) => sum + d[field], 0) / result.length,\r\n            ]));\r\n        }\r\n        return result.length;\r\n    },\r\n});\r\nService.register(\"ReverseSelectionService\", {\r\n    constructor: AnalysisService,\r\n    evaluate({ result, self }) {\r\n        // Get all DOM on the layer\r\n        const layerInstances = self._layerInstances;\r\n        if (layerInstances && layerInstances.length > 0) {\r\n            const graphic = layerInstances[0].getGraphic();\r\n            const doms = [...graphic.childNodes].filter((el) => layerInstances[0].getDatum(el));\r\n            const domData = doms.map((el) => layerInstances[0].getDatum(el));\r\n            // As the result is the copied DOM, we need to convert it to data and then filter\r\n            const data = (result || []).map((el) => layerInstances[0].getDatum(el));\r\n            return doms\r\n                .filter((_, i) => !data.includes(domData[i]))\r\n                .map((d) => layerInstances[0].cloneVisualElements(d, true));\r\n        }\r\n        return [];\r\n    },\r\n});\r\nService.register(\"RegressionService\", {\r\n    constructor: AnalysisService,\r\n    evaluate({ result, xField, yField, self }) {\r\n        if (!result || result.length <= 1 || !(result instanceof Array))\r\n            return null;\r\n        // Need to convert DOM list to data\r\n        const layerInstances = self._layerInstances;\r\n        if (layerInstances && layerInstances.length > 0) {\r\n            const datum = layerInstances[0].getDatum(result[0]);\r\n            if (datum) {\r\n                result = result\r\n                    .map((d) => layerInstances[0].getDatum(d))\r\n                    .filter((x) => x !== undefined);\r\n            }\r\n        }\r\n        let xValues, yValues;\r\n        if (xField instanceof Function) {\r\n            xValues = result.map((d) => xField(d));\r\n        }\r\n        else if (xField) {\r\n            xValues = result.map((d) => d[xField]);\r\n        }\r\n        if (yField instanceof Function) {\r\n            yValues = result.map((d) => yField(d));\r\n        }\r\n        else if (yField) {\r\n            yValues = result.map((d) => d[yField]);\r\n        }\r\n        const xMean = d3.mean(xValues);\r\n        const yMean = d3.mean(yValues);\r\n        // Calculate slope of the regression line\r\n        // Calculate slope using least squares method\r\n        const numerator = d3.sum(xValues.map((x, i) => (x - xMean) * (yValues[i] - yMean)));\r\n        const denominator = d3.sum(xValues.map((x) => Math.pow(x - xMean, 2)));\r\n        const slope = numerator / denominator;\r\n        // Calculate y-intercept using point-slope form\r\n        const intercept = yMean - slope * xMean;\r\n        return {\r\n            slope,\r\n            intercept,\r\n        };\r\n    },\r\n});\r\n","import * as ServiceConstructor from \"./service\";\r\nimport ServiceClass from \"./service\";\r\nimport \"./selectionService\";\r\nimport \"./layoutService\";\r\nimport \"./algorithmService\";\r\nexport default ServiceClass;\r\nexport const register = ServiceConstructor.register;\r\nexport const initialize = ServiceConstructor.initialize;\r\nexport const findService = ServiceConstructor.findService;\r\nexport const instanceServices = ServiceConstructor.instanceServices;\r\nexport const Service = ServiceClass;\r\n","import Service from \"./service\";\r\nimport * as helpers from \"../helpers\";\r\nimport { GraphicalTransformer } from \"../transformer\";\r\nexport default class SelectionService extends Service {\r\n    constructor(baseName, options) {\r\n        super(baseName, {\r\n            ...options,\r\n            resultAlias: options?.resultAlias ?? \"result\",\r\n        });\r\n        this._currentDimension = [];\r\n        this._transformers.push(GraphicalTransformer.initialize(\"SelectionTransformer\", {\r\n            transient: true,\r\n            sharedVar: {\r\n                [this._resultAlias]: [],\r\n                layer: null,\r\n                highlightColor: options?.sharedVar?.highlightColor,\r\n                highlightAttrValues: options?.sharedVar?.highlightAttrValues,\r\n                tooltip: options?.sharedVar?.tooltip,\r\n            },\r\n        }));\r\n        this._selectionMapping = new Map();\r\n        Object.entries({\r\n            ...(this._userOptions?.query?.attrName\r\n                ? typeof this._userOptions.query.attrName === \"string\"\r\n                    ? {\r\n                        [this._userOptions.query.attrName]: this._userOptions?.query?.extent ?? [],\r\n                    }\r\n                    : Object.fromEntries(this._userOptions.query.attrName.map((attr, i) => [\r\n                        attr,\r\n                        this._userOptions?.query?.extent?.[i] ?? [],\r\n                    ]))\r\n                : {}),\r\n            ...(this._sharedVar?.attrName\r\n                ? typeof this._sharedVar.attrName === \"string\"\r\n                    ? {\r\n                        [this._sharedVar.attrName]: this._sharedVar?.extent ?? [],\r\n                    }\r\n                    : Object.fromEntries(this._sharedVar.attrName.map((attr, i) => [\r\n                        attr,\r\n                        this._sharedVar?.extent?.[i] ?? [],\r\n                    ]))\r\n                : {}),\r\n        })\r\n            .filter(([_, v]) => v instanceof Array)\r\n            .forEach(([key, value]) => this._selectionMapping.set(key, value));\r\n    }\r\n    async setSharedVar(sharedName, value, options) {\r\n        if (options &&\r\n            options.layer &&\r\n            this._layerInstances.length !== 0 &&\r\n            !this._layerInstances.includes(options.layer)) {\r\n            return;\r\n        }\r\n        this.preUpdate();\r\n        this._sharedVar[sharedName] = value;\r\n        this._transformers\r\n            .filter((t) => t.isInstanceOf(\"draw-shape\"))\r\n            .forEach((t) => {\r\n            const layer = options?.layer || this._layerInstances[0];\r\n            if (!layer)\r\n                return;\r\n            let bbox = layer.getGraphic().getBoundingClientRect();\r\n            if ((layer._width && bbox.width > layer._width) ||\r\n                (layer._height && bbox.height > layer._height)) {\r\n                const tempRect = document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\r\n                tempRect.setAttribute(\"x\", \"0\");\r\n                tempRect.setAttribute(\"y\", \"0\");\r\n                tempRect.setAttribute(\"width\", layer._width.toString());\r\n                tempRect.setAttribute(\"height\", layer._height.toString());\r\n                tempRect.setAttribute(\"opacity\", \"0\");\r\n                layer.getGraphic().appendChild(tempRect);\r\n                bbox = tempRect.getBoundingClientRect();\r\n                layer.getGraphic().removeChild(tempRect);\r\n            }\r\n            const x = this._sharedVar.x ?? bbox.left;\r\n            const y = this._sharedVar.y ?? bbox.top;\r\n            const width = this._sharedVar.width ?? layer._width ?? 0;\r\n            const height = this._sharedVar.height ?? layer._height ?? 0;\r\n            if (this._sharedVar.width !== undefined ||\r\n                this._sharedVar.height !== undefined) {\r\n                // only set when width or height is set\r\n                t.setSharedVars({\r\n                    layer: layer.getLayerFromQueue(\"transientLayer\"),\r\n                    x: x - bbox.left,\r\n                    y: y - bbox.top,\r\n                    width: width,\r\n                    height: height,\r\n                });\r\n            }\r\n        }); // transient shape\r\n        if ((options?.layer || this._layerInstances.length == 1) &&\r\n            this._userOptions.query) {\r\n            const layer = options?.layer || this._layerInstances[0];\r\n            if (this._nextTick) {\r\n                return;\r\n            }\r\n            this._nextTick = requestAnimationFrame(async () => {\r\n                this._evaluate(layer);\r\n            });\r\n        }\r\n        else {\r\n            this.postUpdate();\r\n        }\r\n    }\r\n    _evaluate(layer) {\r\n        if (!layer)\r\n            return;\r\n        if (!this._sharedVar.skipPicking) {\r\n            this._oldResult = this._result;\r\n            this._result = layer.picking({\r\n                ...this._userOptions.query,\r\n                ...this._sharedVar,\r\n            });\r\n        }\r\n        const selectionLayer = layer\r\n            .getLayerFromQueue(\"selectionLayer\")\r\n            .getGraphic();\r\n        while (selectionLayer?.firstChild) {\r\n            selectionLayer.removeChild(selectionLayer.lastChild);\r\n        }\r\n        if (this._sharedVar.deepClone) {\r\n            let resultNodes = [];\r\n            let refNodes = [];\r\n            this._result.forEach((node) => {\r\n                if (node !== layer.getGraphic()) {\r\n                    let k = refNodes.length;\r\n                    for (let i = 0; i < k; i++) {\r\n                        const refNode = refNodes[i];\r\n                        const resultNode = resultNodes[i];\r\n                        if (node.contains(refNode)) {\r\n                            refNodes.splice(i, 1);\r\n                            resultNodes.splice(i, 1);\r\n                            resultNode.remove();\r\n                            i--;\r\n                            k--;\r\n                        }\r\n                    }\r\n                    resultNodes.push(layer.cloneVisualElements(node, true));\r\n                    refNodes.push(node);\r\n                }\r\n            });\r\n            this._services.forEach((service) => {\r\n                service.setSharedVars({\r\n                    name: this._baseName,\r\n                    ...this._sharedVar,\r\n                    [this._resultAlias]: resultNodes,\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            this._services.forEach((service) => {\r\n                service.setSharedVars({\r\n                    ...this._sharedVar,\r\n                    [this._resultAlias]: this._result\r\n                        ? this._result.map((node) => layer.cloneVisualElements(node, false))\r\n                        : [],\r\n                });\r\n            });\r\n            this._transformers\r\n                .filter((t) => !t.isInstanceOf(\"draw-shape\"))\r\n                .forEach((transformer) => {\r\n                transformer.setSharedVars({\r\n                    name: this._baseName,\r\n                    ...this._sharedVar,\r\n                    x: this._sharedVar.offsetx ?? this._sharedVar.x,\r\n                    y: this._sharedVar.offsety ?? this._sharedVar.y,\r\n                    layer: layer.getLayerFromQueue(\"selectionLayer\"),\r\n                    [this._resultAlias]: this._result\r\n                        ? this._result.map((node) => layer.cloneVisualElements(node, false))\r\n                        : [],\r\n                });\r\n            });\r\n        }\r\n        if (this._sharedVar.scaleX &&\r\n            this._sharedVar.scaleX.invert &&\r\n            this._sharedVar.scaleY &&\r\n            this._sharedVar.scaleY.invert) {\r\n            const x = this._sharedVar.offsetx;\r\n            const y = this._sharedVar.offsety;\r\n            const width = this._sharedVar.width;\r\n            const height = this._sharedVar.height;\r\n            const layerOffsetX = layer._offset?.x ?? 0;\r\n            const layerOffsetY = layer._offset?.y ?? 0;\r\n            const newExtentX = [x - layerOffsetX, x - layerOffsetX + width].map(this._sharedVar.scaleX.invert);\r\n            const newExtentY = [y - layerOffsetY, y - layerOffsetY + height].map(this._sharedVar.scaleY.invert);\r\n            this.filter([newExtentX, newExtentY], { passive: true });\r\n        }\r\n        else if (this._sharedVar.scaleX && this._sharedVar.scaleX.invert) {\r\n            const x = this._sharedVar.offsetx;\r\n            const width = this._sharedVar.width;\r\n            const layerOffsetX = layer._offset?.x ?? 0;\r\n            const newExtentX = [x - layerOffsetX, x - layerOffsetX + width].map(this._sharedVar.scaleX.invert);\r\n            this.filter(newExtentX, { passive: true });\r\n        }\r\n        else if (this._sharedVar.scaleY && this._sharedVar.scaleY.invert) {\r\n            const y = this._sharedVar.offsety;\r\n            const height = this._sharedVar.height;\r\n            const layerOffsetY = layer._offset?.y ?? 0;\r\n            const newExtentY = [y - layerOffsetY, y - layerOffsetY + height].map(this._sharedVar.scaleY.invert);\r\n            this.filter(newExtentY, { passive: true });\r\n        }\r\n        this._nextTick = 0;\r\n        this.postUpdate();\r\n    }\r\n    isInstanceOf(name) {\r\n        return (\"SelectionService\" === name ||\r\n            this._baseName === name ||\r\n            this._name === name);\r\n    }\r\n    /** Cross filter */\r\n    dimension(dimension, formatter) {\r\n        let dimArr = [];\r\n        let fmtArr = [];\r\n        if (typeof dimension === \"string\") {\r\n            dimArr = [dimension];\r\n            fmtArr = [formatter ?? ((d) => d)];\r\n        }\r\n        else {\r\n            dimArr = helpers.deepClone(dimension);\r\n            fmtArr =\r\n                formatter ?? dimArr.map(() => (d) => d);\r\n        }\r\n        const zipArr = dimArr.map((d, i) => [d, fmtArr[i]]);\r\n        const scopeSharedVar = {};\r\n        let scopeLayerInstances = [];\r\n        this._currentDimension = zipArr;\r\n        return new Proxy(this, {\r\n            get(target, p, receiver) {\r\n                if (p === \"dimension\") {\r\n                    return target.dimension.bind(target);\r\n                }\r\n                else if (p === \"_currentDimension\") {\r\n                    return zipArr;\r\n                }\r\n                else if (p === \"_scopeMode\") {\r\n                    return true;\r\n                }\r\n                else if (p === \"_sharedVar\") {\r\n                    if (Object.keys(scopeSharedVar).length)\r\n                        return new Proxy({\r\n                            ...target._sharedVar,\r\n                            scaleX: undefined,\r\n                            scaleY: undefined,\r\n                            ...scopeSharedVar,\r\n                        }, {\r\n                            set: (target, p, value) => {\r\n                                scopeSharedVar[p] = value;\r\n                                return true;\r\n                            },\r\n                        });\r\n                    return new Proxy(target._sharedVar, {\r\n                        set: (target, p, value) => {\r\n                            scopeSharedVar[p] = value;\r\n                            return true;\r\n                        },\r\n                    });\r\n                }\r\n                else if (p === \"_layerInstances\") {\r\n                    if (scopeLayerInstances.length) {\r\n                        return scopeLayerInstances;\r\n                    }\r\n                    else {\r\n                        return target._layerInstances;\r\n                    }\r\n                }\r\n                else if (target[p] instanceof Function) {\r\n                    return target[p].bind(receiver);\r\n                }\r\n                else {\r\n                    return target[p];\r\n                }\r\n            },\r\n            set(target, p, value) {\r\n                if (p === \"_layerInstances\") {\r\n                    scopeLayerInstances = value;\r\n                    return true;\r\n                }\r\n                target[p] = value;\r\n                return true;\r\n            },\r\n        });\r\n    }\r\n    filter(extent, options) {\r\n        if (options &&\r\n            options.layer &&\r\n            this._layerInstances.length !== 0 &&\r\n            !this._layerInstances.includes(options.layer)) {\r\n            return this;\r\n        }\r\n        const layer = options?.layer || this._layerInstances[0];\r\n        if (this._currentDimension.length === 0 &&\r\n            extent instanceof Array &&\r\n            extent.length > 0) {\r\n            if (this._sharedVar.attrName) {\r\n                this._userOptions.query.attrName = this._sharedVar.attrName;\r\n            }\r\n            if (this._userOptions.query.attrName) {\r\n                this.dimension(this._userOptions.query.attrName).filter(extent);\r\n            }\r\n        }\r\n        else if (this._currentDimension.length === 1 &&\r\n            extent instanceof Array &&\r\n            extent.length > 0 &&\r\n            !(extent[0] instanceof Array)) {\r\n            this._selectionMapping.set(this._currentDimension[0][0], this._currentDimension[0][1](extent)\r\n                .sort((a, b) => typeof a === \"number\" ? a - b : a < b ? -1 : a == b ? 0 : 1));\r\n            if (!options?.passive) {\r\n                this._sharedVar.attrName = [...this._selectionMapping.keys()];\r\n                this._sharedVar.extent = [...this._selectionMapping.values()];\r\n                this._evaluate(layer);\r\n            }\r\n            this._services.forEach((service) => {\r\n                service.setSharedVar(\"extents\", this.extents);\r\n            });\r\n            this._transformers.forEach((transformer) => {\r\n                transformer.setSharedVar(\"extents\", this.extents);\r\n            });\r\n        }\r\n        else if (this._currentDimension.length === extent.length &&\r\n            extent.every((ex) => ex instanceof Array)) {\r\n            this._currentDimension.forEach((dim, i) => {\r\n                this._selectionMapping.set(dim[0], dim[1](extent[i]).sort((a, b) => typeof a === \"number\" ? a - b : a < b ? -1 : a == b ? 0 : 1));\r\n            });\r\n            if (!options?.passive) {\r\n                this._sharedVar.attrName = [...this._selectionMapping.keys()];\r\n                this._sharedVar.extent = [...this._selectionMapping.values()];\r\n                this._evaluate(layer);\r\n            }\r\n            this._services.forEach((service) => {\r\n                service.setSharedVar(\"extents\", this.extents);\r\n            });\r\n            this._transformers.forEach((transformer) => {\r\n                transformer.setSharedVar(\"extents\", this.extents);\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n    get extents() {\r\n        return Object.fromEntries(this._selectionMapping.entries());\r\n    }\r\n}\r\nService.SelectionService = SelectionService;\r\nService.register(\"SelectionService\", {\r\n    constructor: SelectionService,\r\n});\r\nService.register(\"SurfacePointSelectionService\", {\r\n    constructor: SelectionService,\r\n    query: {\r\n        baseOn: helpers.QueryType.Shape,\r\n        type: helpers.ShapeQueryType.SurfacePoint,\r\n        x: 0,\r\n        y: 0,\r\n    },\r\n});\r\nService.register(\"PointSelectionService\", {\r\n    constructor: SelectionService,\r\n    query: {\r\n        baseOn: helpers.QueryType.Shape,\r\n        type: helpers.ShapeQueryType.Point,\r\n        x: 0,\r\n        y: 0,\r\n    },\r\n});\r\nService.register(\"RectSelectionService\", {\r\n    constructor: SelectionService,\r\n    transformers: [\r\n        GraphicalTransformer.initialize(\"TransientRectangleTransformer\", {\r\n            sharedVar: {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0,\r\n                opacity: 0.3,\r\n            },\r\n        }),\r\n    ],\r\n    query: {\r\n        baseOn: helpers.QueryType.Shape,\r\n        type: helpers.ShapeQueryType.Rect,\r\n        x: 0,\r\n        y: 0,\r\n        width: 1,\r\n        height: 1,\r\n    },\r\n});\r\nService.register(\"CircleSelectionService\", {\r\n    constructor: SelectionService,\r\n    query: {\r\n        baseOn: helpers.QueryType.Shape,\r\n        type: helpers.ShapeQueryType.Circle,\r\n        x: 0,\r\n        y: 0,\r\n        r: 1,\r\n    },\r\n});\r\nService.register(\"PolygonSelectionService\", {\r\n    constructor: SelectionService,\r\n    query: {\r\n        baseOn: helpers.QueryType.Shape,\r\n        type: helpers.ShapeQueryType.Polygon,\r\n        points: [],\r\n    },\r\n});\r\nService.register(\"QuantitativeSelectionService\", {\r\n    constructor: SelectionService,\r\n    transformers: [\r\n        GraphicalTransformer.initialize(\"TransientRectangleTransformer\", {\r\n            sharedVar: {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0,\r\n                opacity: 0.3,\r\n            },\r\n        }),\r\n    ],\r\n    query: {\r\n        baseOn: helpers.QueryType.Data,\r\n        type: helpers.DataQueryType.Quantitative,\r\n        attrName: \"\",\r\n        extent: [0, 0],\r\n    },\r\n});\r\n","var _a;\r\nimport * as helpers from \"../helpers\";\r\nimport { GraphicalTransformer } from \"../transformer\";\r\nconst registeredServices = {};\r\nexport const instanceServices = [];\r\nexport default class Service {\r\n    constructor(baseName, options) {\r\n        this.joining = false;\r\n        this._linkCache = {};\r\n        this._transformers = [];\r\n        this._joinTransformers = [];\r\n        this._services = [];\r\n        this._joinServices = [];\r\n        this._initializing = null;\r\n        this._nextTick = 0;\r\n        this._computing = null;\r\n        this._result = null;\r\n        this._oldResult = null;\r\n        this._command = [];\r\n        this[_a] = true;\r\n        options.preInitialize && options.preInitialize.call(this, this);\r\n        this._baseName = baseName;\r\n        this._userOptions = options;\r\n        this._name = options.name ?? baseName;\r\n        // this._on = options.on ?? {};\r\n        this._sharedVar = {};\r\n        this._transformers = options.transformers ?? [];\r\n        this._joinTransformers = options.joinTransformers ?? [];\r\n        this._services = options.services ?? [];\r\n        this._joinServices = options.joinServices ?? [];\r\n        this._command = options.command ?? [];\r\n        this._layerInstances = [];\r\n        this._resultAlias = options.resultAlias ?? \"result\";\r\n        this._preInitialize = options.preInitialize ?? null;\r\n        this._postInitialize = options.postInitialize ?? null;\r\n        this._preUpdate = options.preUpdate ?? null;\r\n        this._preAttach = options.preAttach ?? null;\r\n        this._postUse = options.postUse ?? null;\r\n        this._initializing = Promise.all(Object.entries(options.sharedVar || {}).map((entry) => this.setSharedVar(entry[0], entry[1]))).then(async () => {\r\n            // await this.join();\r\n            options.postUpdate && options.postUpdate.call(this, this);\r\n            this._postUpdate = options.postUpdate ?? null;\r\n            this._initializing = null;\r\n        });\r\n        if (options.layer) {\r\n            this._layerInstances.push(options.layer);\r\n        }\r\n        instanceServices.push(this);\r\n        options.postInitialize && options.postInitialize.call(this, this);\r\n    }\r\n    // on(action: string, command: Command): void {\r\n    //   if (!this._on[action]) {\r\n    //     this._on[action] = [];\r\n    //   }\r\n    //   this._on[action].push(command);\r\n    // }\r\n    getSharedVar(sharedName, options) {\r\n        if (options &&\r\n            options.layer &&\r\n            this._layerInstances.length &&\r\n            !this._layerInstances.includes(options.layer)) {\r\n            return undefined;\r\n        }\r\n        if (!(sharedName in this._sharedVar) &&\r\n            options &&\r\n            \"defaultValue\" in options) {\r\n            this.setSharedVar(sharedName, options.defaultValue, options);\r\n        }\r\n        return this._sharedVar[sharedName];\r\n    }\r\n    async setSharedVar(sharedName, value, options) {\r\n        this.preUpdate();\r\n        this._sharedVar[sharedName] = value;\r\n        if (this._userOptions.evaluate && this._resultAlias) {\r\n            if (this._nextTick) {\r\n                return;\r\n            }\r\n            this._nextTick = requestAnimationFrame(async () => {\r\n                this._oldResult = this._result;\r\n                try {\r\n                    this._computing = this._userOptions.evaluate({\r\n                        self: this,\r\n                        ...(this._userOptions.params ?? {}),\r\n                        ...this._sharedVar,\r\n                    });\r\n                    this._result = await this._computing;\r\n                    this._computing = null;\r\n                    this._services.forEach((service) => {\r\n                        service.setSharedVars({\r\n                            ...this._sharedVar,\r\n                            [this._resultAlias]: this._result,\r\n                        });\r\n                    });\r\n                    this._transformers.forEach((transformer) => {\r\n                        transformer.setSharedVars({\r\n                            ...this._sharedVar,\r\n                            [this._resultAlias]: this._result,\r\n                        });\r\n                    });\r\n                }\r\n                catch (e) {\r\n                    console.error(e);\r\n                    this._result = undefined;\r\n                    this._computing = null;\r\n                }\r\n                this._nextTick = 0;\r\n                this.postUpdate();\r\n            });\r\n        }\r\n        else {\r\n            this.postUpdate();\r\n        }\r\n    }\r\n    async setSharedVars(obj, options) {\r\n        Object.entries(obj).forEach(([key, value]) => {\r\n            this._sharedVar[key] = value;\r\n        });\r\n        if (Object.keys(obj).length > 0) {\r\n            await this.setSharedVar(...Object.entries(obj)[0], options);\r\n        }\r\n    }\r\n    async join() {\r\n        if (this._resultAlias) {\r\n            this.joining = true;\r\n            if (Object.keys(this._sharedVar).length) {\r\n                this.setSharedVar(...Object.entries(this._sharedVar)[0]);\r\n            }\r\n            const result = await this._internalResults;\r\n            if (this._joinServices && this._joinServices.length) {\r\n                await Promise.all(this._joinServices.map(async (s) => {\r\n                    await s.setSharedVar(this._resultAlias, result);\r\n                    return s.results;\r\n                }));\r\n            }\r\n            else if (!this._initializing) {\r\n                await Promise.all(this._services.map(async (s) => {\r\n                    await s.setSharedVar(this._resultAlias, result);\r\n                    return s.results;\r\n                }));\r\n            }\r\n            if (this._joinTransformers && this._joinTransformers.length) {\r\n                await Promise.all(this._joinTransformers.map((t) => t.setSharedVar(this._resultAlias, result)));\r\n            }\r\n            else if (!this._initializing) {\r\n                await Promise.all(this._transformers.map((t) => t.setSharedVar(this._resultAlias, result)));\r\n            }\r\n            this.joining = false;\r\n        }\r\n    }\r\n    // watchSharedVar(sharedName: string, handler: Command) {\r\n    //   this.on(`update:${sharedName}`, handler);\r\n    // }\r\n    preUpdate() {\r\n        this._preUpdate && this._preUpdate.call(this, this);\r\n    }\r\n    postUpdate() {\r\n        this._postUpdate && this._postUpdate.call(this, this);\r\n    }\r\n    preAttach(instrument) {\r\n        this._preAttach && this._preAttach.call(this, this, instrument);\r\n    }\r\n    postUse(instrument) {\r\n        this._postUse && this._postUse.call(this, this, instrument);\r\n    }\r\n    invokeCommand() {\r\n        this._command.forEach((command) => {\r\n            command.execute({\r\n                self: this,\r\n                ...(this._userOptions.params ?? {}),\r\n                ...this._sharedVar,\r\n            });\r\n        });\r\n        this._services.forEach((service) => {\r\n            service.invokeCommand();\r\n        });\r\n    }\r\n    isInstanceOf(name) {\r\n        return this._baseName === name || this._name === name;\r\n    }\r\n    get transformers() {\r\n        return helpers.makeFindableList(this._transformers.slice(0), GraphicalTransformer, (e) => this._transformers.push(e), (e) => {\r\n            e.setSharedVars({\r\n                ...(this._resultAlias ? { [this._resultAlias]: null } : {}),\r\n                result: null,\r\n            });\r\n            this._transformers.splice(this._transformers.indexOf(e), 1);\r\n        }, this);\r\n    }\r\n    get services() {\r\n        return helpers.makeFindableList(this._services.slice(0), Service, (e) => this._services.push(e), (e) => {\r\n            Object.entries({\r\n                ...(this._resultAlias ? { [this._resultAlias]: null } : {}),\r\n                result: null,\r\n            }).forEach(([k, v]) => {\r\n                e.setSharedVar(k, v);\r\n            });\r\n            this._services.splice(this._services.indexOf(e), 1);\r\n        }, this);\r\n    }\r\n    get _internalResults() {\r\n        if (this._nextTick) {\r\n            return new Promise((res) => {\r\n                window.requestAnimationFrame(async () => {\r\n                    if (this._computing) {\r\n                        res(await this._computing);\r\n                    }\r\n                    else {\r\n                        res(this._result);\r\n                    }\r\n                });\r\n            });\r\n        }\r\n        return this._computing || this._result;\r\n    }\r\n    get results() {\r\n        if (this._initializing) {\r\n            return this._initializing.then(() => {\r\n                return this._internalResults;\r\n            });\r\n        }\r\n        return this._internalResults;\r\n    }\r\n    get oldCachedResults() {\r\n        return this._oldResult;\r\n    }\r\n    get oldResults() {\r\n        if (this._initializing) {\r\n            return this._initializing.then(() => {\r\n                if (this._nextTick) {\r\n                    return new Promise((res) => {\r\n                        window.requestAnimationFrame(async () => {\r\n                            if (this._computing) {\r\n                                await this._computing;\r\n                            }\r\n                            res(this._oldResult);\r\n                        });\r\n                    });\r\n                }\r\n                return this._oldResult;\r\n            });\r\n        }\r\n        if (this._nextTick) {\r\n            return new Promise((res) => {\r\n                window.requestAnimationFrame(async () => {\r\n                    if (this._computing) {\r\n                        await this._computing;\r\n                    }\r\n                    res(this._oldResult);\r\n                });\r\n            });\r\n        }\r\n        return this._oldResult;\r\n    }\r\n    static register(baseName, options) {\r\n        registeredServices[baseName] = options;\r\n    }\r\n    static unregister(baseName) {\r\n        delete registeredServices[baseName];\r\n        return true;\r\n    }\r\n    static initialize(baseName, options) {\r\n        const mergedOptions = Object.assign({ constructor: Service }, registeredServices[baseName] ?? {}, options ?? {}, {\r\n            // needs to deep merge object\r\n            on: Object.assign({}, (registeredServices[baseName] ?? {}).on ?? {}, options?.on ?? {}),\r\n            sharedVar: Object.assign({}, (registeredServices[baseName] ?? {}).sharedVar ?? {}, options?.sharedVar ?? {}),\r\n            params: Object.assign({}, (registeredServices[baseName] ?? {}).params ?? {}, options?.params ?? {}),\r\n        });\r\n        const service = new mergedOptions.constructor(baseName, mergedOptions);\r\n        return service;\r\n    }\r\n    static findService(baseNameOrRealName) {\r\n        return instanceServices.filter((service) => service.isInstanceOf(baseNameOrRealName));\r\n    }\r\n}\r\n_a = helpers.LibraSymbol;\r\nexport const register = Service.register;\r\nexport const unregister = Service.unregister;\r\nexport const initialize = Service.initialize;\r\nexport const findService = Service.findService;\r\n","var _a;\r\nimport * as helpers from \"../helpers\";\r\nconst registeredTransformers = {};\r\nexport const instanceTransformers = [];\r\nlet transientQueue = [];\r\nconst transientCleaner = () => {\r\n    let transientElement;\r\n    while ((transientElement = transientQueue.pop())) {\r\n        try {\r\n            transientElement.remove(); // TODO: other VIS toolkit APIs\r\n        }\r\n        catch (e) {\r\n            // ignore?\r\n        }\r\n    }\r\n    if (!helpers.global.stopTransient) {\r\n        instanceTransformers\r\n            .filter((transformer) => transformer._transient)\r\n            .forEach((transformer) => transformer.redraw());\r\n    }\r\n    requestAnimationFrame(transientCleaner);\r\n};\r\nrequestAnimationFrame(transientCleaner);\r\nexport default class GraphicalTransformer {\r\n    constructor(baseName, options) {\r\n        this[_a] = true;\r\n        this._baseName = baseName;\r\n        this._userOptions = options;\r\n        this._name = options.name ?? this._baseName;\r\n        this._sharedVar = options.sharedVar ?? {};\r\n        this._redraw = options.redraw ?? (() => { });\r\n        this._layer = options.layer;\r\n        this._transient = options.transient ?? false;\r\n        try {\r\n            this.redraw();\r\n        }\r\n        catch (e) {\r\n            // ignore\r\n        }\r\n    }\r\n    getSharedVar(name) {\r\n        return this._sharedVar[name];\r\n    }\r\n    setSharedVar(name, value) {\r\n        this._sharedVar[name] = value;\r\n        this.redraw();\r\n    }\r\n    setSharedVars(obj) {\r\n        Object.entries(obj).forEach(([k, v]) => (this._sharedVar[k] = v));\r\n        this.redraw();\r\n    }\r\n    redraw(transient = false) {\r\n        if (!this._layer && !this.getSharedVar(\"layer\"))\r\n            return;\r\n        const layer = this._layer || this.getSharedVar(\"layer\");\r\n        transient = transient || this._transient;\r\n        let preDrawElements = [], postDrawElements = [], changedLayers = new Set([layer]);\r\n        if (transient) {\r\n            preDrawElements = layer.getVisualElements();\r\n            if (!layer._getLayerFromQueue) {\r\n                layer._getLayerFromQueue = layer.getLayerFromQueue;\r\n                layer.getLayerFromQueue = function () {\r\n                    const result = layer._getLayerFromQueue(...arguments);\r\n                    preDrawElements = preDrawElements.concat(result.getVisualElements());\r\n                    changedLayers.add(result);\r\n                    return result;\r\n                };\r\n            }\r\n        }\r\n        this._redraw({\r\n            layer,\r\n            transformer: this,\r\n        });\r\n        if (transient) {\r\n            layer.getLayerFromQueue = layer._getLayerFromQueue;\r\n            delete layer._getLayerFromQueue;\r\n            changedLayers.forEach((layer) => {\r\n                // postDrawElements = layer.getVisualElements();\r\n                // const topLevelElements = postDrawElements.filter(\r\n                //   (el) => !postDrawElements.find((e) => e !== el && e.contains(el))\r\n                // );\r\n                postDrawElements = postDrawElements.concat(Array.prototype.slice.call(layer.getGraphic()?.childNodes ?? []));\r\n                const transientElements = postDrawElements.filter((el) => !preDrawElements.includes(el));\r\n                transientQueue = transientQueue.concat(transientElements);\r\n            });\r\n        }\r\n    }\r\n    isInstanceOf(name) {\r\n        return (this._baseName === name ||\r\n            this._name === name ||\r\n            (this._userOptions.className ?? []).includes(name));\r\n    }\r\n    static register(baseName, options) {\r\n        registeredTransformers[baseName] = options;\r\n    }\r\n    static unregister(baseName) {\r\n        delete registeredTransformers[baseName];\r\n        return true;\r\n    }\r\n    static initialize(baseName, options) {\r\n        const mergedOptions = Object.assign({ constructor: GraphicalTransformer }, registeredTransformers[baseName] ?? {}, options ?? {}, {\r\n            sharedVar: Object.assign({}, (registeredTransformers[baseName] ?? {}).sharedVar ?? {}, options?.sharedVar ?? {}),\r\n        });\r\n        const transformer = new mergedOptions.constructor(baseName, mergedOptions);\r\n        instanceTransformers.push(transformer);\r\n        return transformer;\r\n    }\r\n    static findTransformer(baseNameOrRealName) {\r\n        return instanceTransformers.filter((transformer) => transformer.isInstanceOf(baseNameOrRealName));\r\n    }\r\n    static findTransformerByLayer(layer) {\r\n        return instanceTransformers.filter((t) => t._layer === layer || t.getSharedVar(\"layer\") === layer);\r\n    }\r\n}\r\n_a = helpers.LibraSymbol;\r\nexport const register = GraphicalTransformer.register;\r\nexport const unregister = GraphicalTransformer.unregister;\r\nexport const initialize = GraphicalTransformer.initialize;\r\nexport const findTransformer = GraphicalTransformer.findTransformer;\r\n","import GraphicalTransformer from \"./transformer\";\r\nimport * as d3 from \"d3\";\r\nGraphicalTransformer.register(\"SliderTransformer\", {\r\n    constructor: GraphicalTransformer,\r\n    redraw: ({ layer, transformer }) => {\r\n        d3.select(layer.getGraphic())\r\n            .selectAll(\":not(.ig-layer-background)\")\r\n            .remove();\r\n        const x1 = transformer.getSharedVar(\"x1\") ?? 0;\r\n        const x2 = transformer.getSharedVar(\"x2\") ?? 0;\r\n        const height = transformer.getSharedVar(\"height\") ?? 0;\r\n        const fill = transformer.getSharedVar(\"fill\") ?? \"#000000\";\r\n        const opacity = transformer.getSharedVar(\"opacity\") ?? 0.3;\r\n        d3.select(layer.getGraphic())\r\n            .append(\"rect\")\r\n            .attr(\"x1\", x1)\r\n            .attr(\"x2\", x2)\r\n            .attr(\"width\", x2 - x1)\r\n            .attr(\"height\", height)\r\n            .attr(\"fill\", fill)\r\n            .attr(\"opacity\", opacity);\r\n    },\r\n});\r\nGraphicalTransformer.register(\"HighlightSelection\", {\r\n    constructor: GraphicalTransformer,\r\n    redraw({ layer, transformer }) {\r\n        const elems = d3\r\n            .select(layer.getGraphic())\r\n            .selectAll(transformer.getSharedVar(\"selector\") || \"*\");\r\n        const attrValueEntries = Object.entries(transformer.getSharedVar(\"highlightAttrValues\"));\r\n        attrValueEntries.forEach(([key, value]) => {\r\n            elems.attr(key, value);\r\n        });\r\n    },\r\n});\r\nGraphicalTransformer.register(\"TransientRectangleTransformer\", {\r\n    constructor: GraphicalTransformer,\r\n    className: [\"draw-shape\", \"transient-shape\", \"rectangle-shape\"],\r\n    redraw: ({ layer, transformer }) => {\r\n        d3.select(layer.getGraphic())\r\n            .selectAll(\":not(.ig-layer-background)\")\r\n            .remove();\r\n        d3.select(layer.getGraphic())\r\n            .append(\"rect\")\r\n            .attr(\"x\", transformer.getSharedVar(\"x\"))\r\n            .attr(\"y\", transformer.getSharedVar(\"y\"))\r\n            .attr(\"width\", transformer.getSharedVar(\"width\"))\r\n            .attr(\"height\", transformer.getSharedVar(\"height\"))\r\n            .attr(\"fill\", transformer.getSharedVar(\"fillColor\"))\r\n            .attr(\"opacity\", transformer.getSharedVar(\"opacity\"));\r\n    },\r\n});\r\nGraphicalTransformer.register(\"SelectionTransformer\", {\r\n    constructor: GraphicalTransformer,\r\n    redraw: ({ layer, transformer }) => {\r\n        transformer.getSharedVar(\"result\")?.forEach((resultNode) => {\r\n            layer.getGraphic().appendChild(resultNode);\r\n        });\r\n        const highlightColor = transformer.getSharedVar(\"highlightColor\");\r\n        const attrValueEntries = Object.entries(transformer.getSharedVar(\"highlightAttrValues\") || {});\r\n        if (highlightColor || attrValueEntries.length) {\r\n            const elems = d3.selectAll(transformer.getSharedVar(\"result\"));\r\n            if (highlightColor) {\r\n                elems.attr(\"fill\", highlightColor).attr(\"stroke\", highlightColor);\r\n            }\r\n            attrValueEntries.forEach(([key, value]) => {\r\n                elems.attr(key, value);\r\n            });\r\n        }\r\n        const tooltip = transformer.getSharedVar(\"tooltip\");\r\n        if (tooltip) {\r\n            if (typeof tooltip === \"object\" &&\r\n                ((tooltip.fields && tooltip.fields.length) || tooltip.text)) {\r\n                const tooltipQueue = [];\r\n                let shouldDisplay = false;\r\n                if (typeof tooltip === \"object\" && tooltip.prefix) {\r\n                    tooltipQueue.push(tooltip.prefix);\r\n                }\r\n                if (tooltip.text) {\r\n                    tooltipQueue.push(tooltip.text);\r\n                    shouldDisplay = true;\r\n                }\r\n                if (tooltip.fields && tooltip.fields.length) {\r\n                    const result = transformer.getSharedVar(\"result\");\r\n                    if (result && result.length <= 1) {\r\n                        tooltip.fields.forEach((field) => {\r\n                            const displayContent = layer.getDatum(result?.[0])?.[field] ?? \"\";\r\n                            if (displayContent) {\r\n                                tooltipQueue.push(displayContent);\r\n                                shouldDisplay = true;\r\n                            }\r\n                        });\r\n                    }\r\n                    else if (result && result.length > 1) {\r\n                        const queueArray = [];\r\n                        result.forEach((el) => {\r\n                            const datum = layer.getDatum(el);\r\n                            if (datum) {\r\n                                const subArray = [el];\r\n                                tooltip.fields.forEach((field) => {\r\n                                    const displayContent = datum?.[field] ?? \"\";\r\n                                    if (displayContent) {\r\n                                        subArray.push(displayContent);\r\n                                    }\r\n                                });\r\n                                queueArray.push(subArray);\r\n                            }\r\n                        });\r\n                        shouldDisplay = true;\r\n                        tooltipQueue.push(queueArray);\r\n                    }\r\n                }\r\n                if (typeof tooltip === \"object\" && tooltip.suffix) {\r\n                    tooltipQueue.push(tooltip.suffix);\r\n                }\r\n                const tooltipText = tooltipQueue.join(\" \");\r\n                if (tooltipText && shouldDisplay) {\r\n                    if (tooltip.position == \"absolute\") {\r\n                        const tooltipArrayIndex = tooltipQueue.findIndex((item) => item instanceof Array);\r\n                        if (tooltipArrayIndex !== -1) {\r\n                            const tooltipPrefix = tooltipQueue.slice(0, tooltipArrayIndex);\r\n                            const tooltipArray = tooltipQueue[tooltipArrayIndex];\r\n                            const tooltipSuffix = tooltipQueue.slice(tooltipArrayIndex + 1);\r\n                            tooltipArray.forEach((subArray) => {\r\n                                const el = subArray[0];\r\n                                const str = [\r\n                                    ...tooltipPrefix,\r\n                                    ...subArray.slice(1),\r\n                                    ...tooltipSuffix,\r\n                                ].join(\" \");\r\n                                // Make the tooltip offset relative to the element\r\n                                const offsetX = (el.getBBox()?.x ?? 0) + (tooltip.offset?.x ?? 0);\r\n                                const offsetY = (el.getBBox()?.y ?? 0) + (tooltip.offset?.y ?? 0);\r\n                                d3.select(layer.getGraphic())\r\n                                    .append(\"text\")\r\n                                    .attr(\"x\", offsetX)\r\n                                    .attr(\"y\", offsetY)\r\n                                    .text(str);\r\n                            });\r\n                        }\r\n                    }\r\n                    else {\r\n                        d3.select(layer.getGraphic())\r\n                            .append(\"text\")\r\n                            .attr(\"x\", transformer.getSharedVar(\"x\") -\r\n                            (layer._offset?.x ?? 0) +\r\n                            (tooltip.offset?.x ?? 0))\r\n                            .attr(\"y\", transformer.getSharedVar(\"y\") -\r\n                            (layer._offset?.y ?? 0) +\r\n                            (tooltip.offset?.y ?? 0))\r\n                            .text(tooltipText);\r\n                    }\r\n                }\r\n            }\r\n            if (typeof tooltip === \"object\" && tooltip.image) {\r\n                if (typeof tooltip.image === \"string\") {\r\n                    d3.select(layer.getGraphic())\r\n                        .append(\"image\")\r\n                        .attr(\"x\", transformer.getSharedVar(\"x\") -\r\n                        (layer._offset?.x ?? 0) +\r\n                        (tooltip.offset?.x ?? 0))\r\n                        .attr(\"y\", transformer.getSharedVar(\"y\") -\r\n                        (layer._offset?.y ?? 0) +\r\n                        (tooltip.offset?.y ?? 0))\r\n                        .attr(\"width\", tooltip.width ?? 100)\r\n                        .attr(\"height\", tooltip.height ?? 100)\r\n                        .attr(\"style\", \"object-fit: contain\")\r\n                        .attr(\"xlink:href\", tooltip.image);\r\n                }\r\n                else if (tooltip.image instanceof Function) {\r\n                    try {\r\n                        const image = tooltip.image(layer.getDatum(transformer.getSharedVar(\"result\")[0]));\r\n                        if (image) {\r\n                            d3.select(layer.getGraphic())\r\n                                .append(\"image\")\r\n                                .attr(\"x\", transformer.getSharedVar(\"x\") -\r\n                                (layer._offset?.x ?? 0) +\r\n                                (tooltip.offset?.x ?? 0))\r\n                                .attr(\"y\", transformer.getSharedVar(\"y\") -\r\n                                (layer._offset?.y ?? 0) +\r\n                                (tooltip.offset?.y ?? 0))\r\n                                .attr(\"width\", tooltip.width ?? 100)\r\n                                .attr(\"height\", tooltip.height ?? 100)\r\n                                .attr(\"style\", \"object-fit: contain\")\r\n                                .attr(\"xlink:href\", image);\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        // Do nothing\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    },\r\n});\r\nGraphicalTransformer.register(\"LineTransformer\", {\r\n    constructor: GraphicalTransformer,\r\n    transient: true,\r\n    sharedVar: {\r\n        orientation: [\"horizontal\", \"vertical\"],\r\n        style: {},\r\n    },\r\n    redraw({ layer, transformer }) {\r\n        const mainLayer = layer.getLayerFromQueue(\"mainLayer\");\r\n        const orientation = transformer.getSharedVar(\"orientation\");\r\n        const style = transformer.getSharedVar(\"style\");\r\n        const x = transformer.getSharedVar(\"offsetx\") ? transformer.getSharedVar(\"offsetx\") : transformer.getSharedVar(\"x\");\r\n        const y = transformer.getSharedVar(\"offsety\") ? transformer.getSharedVar(\"offsety\") : transformer.getSharedVar(\"y\");\r\n        const tooltipConfig = transformer.getSharedVar(\"tooltip\");\r\n        const scaleX = transformer.getSharedVar(\"scaleX\");\r\n        const scaleY = transformer.getSharedVar(\"scaleY\");\r\n        const result = transformer.getSharedVar(\"result\");\r\n        if (result &&\r\n            result.slope !== undefined &&\r\n            result.intercept !== undefined) {\r\n            // Draw regression line, will ignore orientation\r\n            orientation.splice(0, orientation.length);\r\n            const line = d3\r\n                .select(layer.getGraphic())\r\n                .append(\"line\")\r\n                .attr(\"x1\", 0)\r\n                .attr(\"x2\", mainLayer.getGraphic().getBoundingClientRect().width)\r\n                .attr(\"y1\", result.intercept)\r\n                .attr(\"y2\", result.slope * mainLayer.getGraphic().getBoundingClientRect().width +\r\n                result.intercept)\r\n                .attr(\"stroke-width\", 1)\r\n                .attr(\"stroke\", \"#000\");\r\n            if (style) {\r\n                Object.entries(style).forEach(([key, value]) => {\r\n                    line.attr(key, value);\r\n                });\r\n            }\r\n        }\r\n        const tooltipQueue = [];\r\n        let tooltipOffsetX = 0;\r\n        let tooltipOffsetY = 0;\r\n        if (tooltipConfig) {\r\n            if (typeof tooltipConfig === \"object\" && tooltipConfig.prefix) {\r\n                tooltipQueue.push(tooltipConfig.prefix);\r\n            }\r\n            if (scaleX && scaleX.invert && typeof x === \"number\") {\r\n                tooltipQueue.push(scaleX.invert(x - (layer._offset?.x ?? 0)));\r\n            }\r\n            if (scaleY && scaleY.invert && typeof y === \"number\") {\r\n                tooltipQueue.push(scaleY.invert(y - (layer._offset?.y ?? 0)));\r\n            }\r\n            if (typeof tooltipConfig === \"object\" && tooltipConfig.suffix) {\r\n                tooltipQueue.push(tooltipConfig.suffix);\r\n            }\r\n            if (typeof tooltipConfig === \"object\" && tooltipConfig.offset) {\r\n                if (typeof tooltipConfig.offset.x === \"number\") {\r\n                    tooltipOffsetX = tooltipConfig.offset.x;\r\n                }\r\n                if (typeof tooltipConfig.offset.y === \"number\") {\r\n                    tooltipOffsetY = tooltipConfig.offset.y;\r\n                }\r\n                if (typeof tooltipConfig.offset.x === \"function\" &&\r\n                    typeof x === \"number\") {\r\n                    tooltipOffsetX = tooltipConfig.offset.x(x - (layer._offset?.x ?? 0));\r\n                }\r\n                if (typeof tooltipConfig.offset.y === \"function\" &&\r\n                    typeof y === \"number\") {\r\n                    tooltipOffsetY = tooltipConfig.offset.y(y - (layer._offset?.y ?? 0));\r\n                }\r\n            }\r\n        }\r\n        const tooltip = tooltipQueue.join(\" \");\r\n        if (orientation.includes(\"horizontal\") && typeof y === \"number\") {\r\n            const line = d3\r\n                .select(layer.getGraphic())\r\n                .append(\"line\")\r\n                .attr(\"x1\", 0)\r\n                .attr(\"x2\", mainLayer.getGraphic().getBoundingClientRect().width)\r\n                .attr(\"y1\", y - (layer._offset?.y ?? 0))\r\n                .attr(\"y2\", y - (layer._offset?.y ?? 0))\r\n                .attr(\"stroke-width\", 1)\r\n                .attr(\"stroke\", \"#000\");\r\n            if (style) {\r\n                Object.entries(style).forEach(([key, value]) => {\r\n                    line.attr(key, value);\r\n                });\r\n            }\r\n        }\r\n        if (orientation.includes(\"vertical\") && typeof x === \"number\") {\r\n            const line = d3\r\n                .select(layer.getGraphic())\r\n                .append(\"line\")\r\n                .attr(\"y1\", 0)\r\n                .attr(\"y2\", mainLayer.getGraphic().getBoundingClientRect().height)\r\n                .attr(\"x1\", x - (layer._offset?.x ?? 0))\r\n                .attr(\"x2\", x - (layer._offset?.x ?? 0))\r\n                .attr(\"stroke-width\", 1)\r\n                .attr(\"stroke\", \"#000\");\r\n            if (style) {\r\n                Object.entries(style).forEach(([key, value]) => {\r\n                    line.attr(key, value);\r\n                });\r\n            }\r\n        }\r\n        if (tooltip) {\r\n            d3.select(layer.getGraphic())\r\n                .append(\"text\")\r\n                .attr(\"x\", x - (layer._offset?.x ?? 0))\r\n                .attr(\"y\", y - (layer._offset?.y ?? 0))\r\n                .text(tooltip);\r\n        }\r\n    },\r\n});\r\nGraphicalTransformer.register(\"TextTransformer\", {\r\n    constructor: GraphicalTransformer,\r\n    transient: true,\r\n    sharedVar: {\r\n        style: {},\r\n        content: \"\",\r\n        field: null,\r\n    },\r\n    redraw({ layer, transformer }) {\r\n        const style = transformer.getSharedVar(\"style\");\r\n        const x = transformer.getSharedVar(\"offsetx\") || transformer.getSharedVar(\"x\");\r\n        const y = transformer.getSharedVar(\"offsety\") || transformer.getSharedVar(\"y\");\r\n        const content = transformer.getSharedVar(\"content\");\r\n        const field = transformer.getSharedVar(\"field\");\r\n        const result = transformer.getSharedVar(\"result\");\r\n        const position = transformer.getSharedVar(\"position\");\r\n        let displayContent = content;\r\n        let displayX = x, displayY = y;\r\n        if (field) {\r\n            const datum = layer.getDatum(result);\r\n            if (datum) {\r\n                displayContent = datum?.[field] ?? \"\";\r\n                if (position instanceof Function) {\r\n                    let { x, y } = position(datum);\r\n                    displayX = x ?? displayX;\r\n                    displayY = y ?? displayY;\r\n                }\r\n                else {\r\n                    displayX = position?.x ?? displayX;\r\n                    displayY = position?.y ?? displayY;\r\n                }\r\n            }\r\n            else {\r\n                displayContent = \"\";\r\n            }\r\n        }\r\n        d3.select(layer.getGraphic())\r\n            .append(\"text\")\r\n            .attr(\"x\", displayX)\r\n            .attr(\"y\", displayY)\r\n            .text(displayContent)\r\n            .call((t) => {\r\n            if (style) {\r\n                Object.entries(style).forEach(([key, value]) => {\r\n                    t.style(key, value);\r\n                });\r\n            }\r\n        });\r\n    },\r\n});\r\n","import * as TransformerConstructor from \"./transformer\";\r\nimport TransformerClass from \"./transformer\";\r\nimport \"./builtin\";\r\nexport default TransformerClass;\r\nexport const register = TransformerConstructor.register;\r\nexport const initialize = TransformerConstructor.initialize;\r\nexport const findTransformer = TransformerConstructor.findTransformer;\r\nexport const instanceTransformers = TransformerConstructor.instanceTransformers;\r\nexport const GraphicalTransformer = TransformerClass;\r\n","import { registeredInstruments, instanceInstruments, } from \"../instrument/instrument\";\r\nimport Instrument from \"../instrument/instrument\";\r\nimport { Layer } from \"../layer\";\r\nimport { Service } from \"../service\";\r\nimport { GraphicalTransformer } from \"../transformer\";\r\nimport Interactor, { transferInteractorInnerAction, } from \"../interactor/interactor\";\r\nimport SelectionService from \"../service/selectionService\";\r\nimport { deepClone } from \"../helpers\";\r\nimport { Command } from \"../command\";\r\nconst registeredInteractions = {};\r\nexport class Interaction {\r\n    static build(options) {\r\n        if (!(options.inherit in registeredInstruments) &&\r\n            !(options.inherit in registeredInteractions)) {\r\n            throw new Error(`Interaction ${options.inherit} is not registered, please register it first`);\r\n        }\r\n        let instrument;\r\n        if (options.inherit in registeredInstruments) {\r\n            const inheritOption = Object.assign({ constructor: Instrument }, registeredInstruments[options.inherit], {\r\n                sharedVar: Object.assign({}, {\r\n                    layers: options.layers ?? [],\r\n                    layer: options.layers?.length == 1 ? options.layers[0] : undefined,\r\n                }, registeredInstruments[options.inherit].sharedVar ?? {}, options.sharedVar ?? {}),\r\n            });\r\n            if (options.layers) {\r\n                inheritOption.layers = options.layers;\r\n            }\r\n            instrument = new inheritOption.constructor(options.inherit, inheritOption);\r\n            instanceInstruments.push(instrument);\r\n        }\r\n        else {\r\n            const inheritOption = Object.assign({}, registeredInteractions[options.inherit], options, {\r\n                inherit: registeredInteractions[options.inherit].inherit,\r\n                sharedVar: Object.assign({}, {\r\n                    layers: options.layers ?? [],\r\n                    layer: options.layers?.length == 1 ? options.layers[0] : undefined,\r\n                }, registeredInteractions[options.inherit].sharedVar ?? {}, options.sharedVar ?? {}),\r\n            });\r\n            instrument = Interaction.build(inheritOption);\r\n            instanceInstruments.push(instrument);\r\n        }\r\n        if (options.name) {\r\n            registeredInteractions[options.name] = options;\r\n            if (!options.layers || !options.layers.length)\r\n                return;\r\n        }\r\n        const findNested = (parent, findType) => {\r\n            if (parent instanceof Instrument) {\r\n                const s = parent._serviceInstances.find((service) => service.isInstanceOf(findType));\r\n                if (s)\r\n                    return [s, parent];\r\n                const t = parent._transformers.find((transformer) => transformer.isInstanceOf(findType));\r\n                if (t)\r\n                    return [t, parent];\r\n                for (let service of parent._serviceInstances) {\r\n                    const result = findNested(service, findType);\r\n                    if (result)\r\n                        return result;\r\n                }\r\n            }\r\n            else {\r\n                const s = parent._services.find((service) => service.isInstanceOf(findType));\r\n                if (s)\r\n                    return [s, parent];\r\n                const t = parent._transformers.find((transformer) => transformer.isInstanceOf(findType));\r\n                if (t)\r\n                    return [t, parent];\r\n                for (let service of parent.services) {\r\n                    const result = findNested(service, findType);\r\n                    if (result)\r\n                        return result;\r\n                }\r\n            }\r\n            return [undefined, undefined];\r\n        };\r\n        const findNestedReference = (parent, findType) => {\r\n            if (parent.isInstanceOf(findType))\r\n                return parent;\r\n            if (parent instanceof Instrument) {\r\n                const s = parent._serviceInstances.find((service) => service.isInstanceOf(findType));\r\n                if (s)\r\n                    return s;\r\n                for (let service of parent._serviceInstances) {\r\n                    const result = findNestedReference(service, findType);\r\n                    if (result)\r\n                        return result;\r\n                }\r\n            }\r\n            else {\r\n                const s = parent._services.find((service) => service.isInstanceOf(findType));\r\n                if (s)\r\n                    return s;\r\n                for (let service of parent.services) {\r\n                    const result = findNestedReference(service, findType);\r\n                    if (result)\r\n                        return result;\r\n                }\r\n            }\r\n        };\r\n        if (options.remove) {\r\n            for (let removeOption of options.remove) {\r\n                while (true) {\r\n                    const [removeNode, parentNode] = findNested(instrument, removeOption.find);\r\n                    if (!removeNode)\r\n                        break;\r\n                    let parentServiceArray = parentNode instanceof Instrument\r\n                        ? parentNode._serviceInstances\r\n                        : parentNode._services;\r\n                    if (removeOption.cascade) {\r\n                        if (removeNode instanceof Service) {\r\n                            parentServiceArray.splice(parentServiceArray.indexOf(removeNode), 1);\r\n                        }\r\n                        else {\r\n                            parentNode._transformers.splice(parentNode._transformers.indexOf(removeNode), 1);\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (removeNode instanceof Service) {\r\n                            parentServiceArray.splice(parentServiceArray.indexOf(removeNode), 1, ...removeNode._services);\r\n                            parentNode._transformers.push(...removeNode._transformers);\r\n                        }\r\n                        else {\r\n                            parentNode._transformers.splice(parentNode._transformers.indexOf(removeNode), 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (options.override) {\r\n            for (let overrideOption of options.override) {\r\n                if (overrideOption.find.endsWith(\"Interactor\")) {\r\n                    // Support for overriding interactor\r\n                    const interactorsList = [...instrument._layerInteractors.values()];\r\n                    const removeNodes = interactorsList.map((interactors) => interactors.filter((interactor) => interactor.isInstanceOf(overrideOption.find)));\r\n                    if (overrideOption.comp) {\r\n                        removeNodes.forEach((list, i) => {\r\n                            list.forEach((interactor) => {\r\n                                const newInteractor = Interactor.initialize(overrideOption.comp);\r\n                                if (newInteractor) {\r\n                                    interactorsList[i].splice(interactorsList[i].indexOf(interactor), 1, newInteractor);\r\n                                }\r\n                            });\r\n                        });\r\n                    }\r\n                    else if (overrideOption.actions) {\r\n                        removeNodes.forEach((list) => {\r\n                            list.forEach((interactor) => {\r\n                                interactor._actions = deepClone(overrideOption.actions).map(transferInteractorInnerAction);\r\n                            });\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    const [removeNode, parentNode] = findNested(instrument, overrideOption.find);\r\n                    if (!removeNode)\r\n                        continue;\r\n                    let replaceNode;\r\n                    if (overrideOption.comp.includes(\"Transformer\")) {\r\n                        let transformer;\r\n                        if (overrideOption.name) {\r\n                            if (GraphicalTransformer.findTransformer(overrideOption.name)\r\n                                .length > 0) {\r\n                                transformer = GraphicalTransformer.findTransformer(overrideOption.name)[0];\r\n                            }\r\n                        }\r\n                        if (!transformer)\r\n                            transformer = GraphicalTransformer.initialize(overrideOption.comp, {\r\n                                name: overrideOption.name,\r\n                                sharedVar: {\r\n                                    ...(options.sharedVar || {}),\r\n                                    ...(overrideOption.sharedVar || {}),\r\n                                },\r\n                            });\r\n                        replaceNode = transformer;\r\n                    }\r\n                    else if (overrideOption.comp.includes(\"Service\")) {\r\n                        let service;\r\n                        if (overrideOption.name) {\r\n                            if (Service.findService(overrideOption.name).length > 0) {\r\n                                service = Service.findService(overrideOption.name)[0];\r\n                            }\r\n                        }\r\n                        if (!service)\r\n                            service = Service.initialize(overrideOption.comp, {\r\n                                ...overrideOption,\r\n                                services: [\r\n                                    ...(overrideOption.services || []),\r\n                                    ...(removeNode instanceof Service\r\n                                        ? removeNode._services\r\n                                        : []),\r\n                                ],\r\n                                transformers: [\r\n                                    ...(overrideOption.transformers || []),\r\n                                    ...(removeNode instanceof Service\r\n                                        ? removeNode._transformers\r\n                                        : []),\r\n                                ],\r\n                                sharedVar: {\r\n                                    ...(options.sharedVar || {}),\r\n                                    ...(overrideOption.sharedVar || {}),\r\n                                },\r\n                            });\r\n                        if (overrideOption.dimension &&\r\n                            service.isInstanceOf(\"SelectionService\")) {\r\n                            service = service.dimension(overrideOption.dimension);\r\n                            if (overrideOption.layers) {\r\n                                service._layerInstances = overrideOption.layers.slice(0);\r\n                            }\r\n                            if (overrideOption.sharedVar) {\r\n                                service.setSharedVars(overrideOption.sharedVar);\r\n                            }\r\n                        }\r\n                        replaceNode = service;\r\n                    }\r\n                    let parentServiceArray = parentNode instanceof Instrument\r\n                        ? parentNode._serviceInstances\r\n                        : parentNode._services;\r\n                    if (removeNode instanceof Service) {\r\n                        parentServiceArray.splice(parentServiceArray.indexOf(removeNode), 1);\r\n                    }\r\n                    else {\r\n                        parentNode._transformers.splice(parentNode._transformers.indexOf(removeNode), 1);\r\n                    }\r\n                    if (overrideOption.comp.includes(\"Transformer\")) {\r\n                        parentNode._transformers.push(replaceNode);\r\n                    }\r\n                    else {\r\n                        parentServiceArray.push(replaceNode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (options.insert) {\r\n            for (let insert of options.insert) {\r\n                const insertNode = findNestedReference(instrument, insert.find);\r\n                if (!insertNode)\r\n                    continue;\r\n                let prevComponent = null;\r\n                let prevType = null;\r\n                for (let i = insert.flow.length - 1; i >= 0; i--) {\r\n                    const componentOption = insert.flow[i];\r\n                    if (componentOption instanceof Function) {\r\n                        const newPrevComponent = [];\r\n                        let newPrevType = null;\r\n                        for (let j = 0; j < options.layers?.length ?? 0; j++) {\r\n                            const layer = options.layers[j];\r\n                            const generatedOption = componentOption(layer, j);\r\n                            if (generatedOption.comp.includes(\"Transformer\")) {\r\n                                let transformer;\r\n                                if (generatedOption.name) {\r\n                                    if (GraphicalTransformer.findTransformer(generatedOption.name)\r\n                                        .length > 0) {\r\n                                        transformer = GraphicalTransformer.findTransformer(generatedOption.name)[0];\r\n                                    }\r\n                                }\r\n                                if (!transformer)\r\n                                    transformer = GraphicalTransformer.initialize(generatedOption.comp, {\r\n                                        ...generatedOption,\r\n                                        sharedVar: {\r\n                                            ...(options.sharedVar || {}),\r\n                                            ...(generatedOption.sharedVar || {}),\r\n                                        },\r\n                                    });\r\n                                newPrevComponent.push(transformer);\r\n                                newPrevType = \"Transformer\";\r\n                            }\r\n                            else if (generatedOption.comp.includes(\"Service\")) {\r\n                                let service;\r\n                                if (generatedOption.name) {\r\n                                    if (Service.findService(generatedOption.name).length > 0) {\r\n                                        service = Service.findService(generatedOption.name)[0];\r\n                                    }\r\n                                }\r\n                                if (!service)\r\n                                    service = Service.initialize(generatedOption.comp, {\r\n                                        ...generatedOption,\r\n                                        ...(prevComponent\r\n                                            ? prevType == \"Transformer\"\r\n                                                ? {\r\n                                                    transformers: prevComponent instanceof Array\r\n                                                        ? prevComponent\r\n                                                        : [prevComponent],\r\n                                                }\r\n                                                : {\r\n                                                    services: prevComponent instanceof Array\r\n                                                        ? prevComponent\r\n                                                        : [prevComponent],\r\n                                                }\r\n                                            : {}),\r\n                                        sharedVar: {\r\n                                            ...(options.sharedVar || {}),\r\n                                            ...(generatedOption.sharedVar || {}),\r\n                                        },\r\n                                    });\r\n                                if (generatedOption.dimension &&\r\n                                    service instanceof SelectionService) {\r\n                                    service = service.dimension(generatedOption.dimension);\r\n                                    if (generatedOption.layers) {\r\n                                        service._layerInstances = generatedOption.layers.slice(0);\r\n                                    }\r\n                                    if (generatedOption.sharedVar) {\r\n                                        service.setSharedVars(generatedOption.sharedVar);\r\n                                    }\r\n                                }\r\n                                newPrevComponent.push(service);\r\n                                newPrevType = \"Service\";\r\n                            }\r\n                        }\r\n                        prevComponent = newPrevComponent;\r\n                        prevType = newPrevType;\r\n                    }\r\n                    else if (componentOption instanceof Array) {\r\n                        const newPrevComponent = [];\r\n                        let newPrevType = null;\r\n                        for (let j = 0; j < componentOption.length; j++) {\r\n                            const component = componentOption[j];\r\n                            if (component instanceof GraphicalTransformer) {\r\n                                newPrevComponent.push(component);\r\n                                newPrevType = \"Transformer\";\r\n                            }\r\n                            else if (component instanceof Service) {\r\n                                if (prevType == \"Transformer\") {\r\n                                    component._transformers.push(...(prevComponent instanceof Array\r\n                                        ? prevComponent\r\n                                        : [prevComponent]));\r\n                                }\r\n                                else {\r\n                                    component._services.push(...(prevComponent instanceof Array\r\n                                        ? prevComponent\r\n                                        : [prevComponent]));\r\n                                }\r\n                                newPrevComponent.push(component);\r\n                                newPrevType = \"Service\";\r\n                            }\r\n                            else if (component.comp.includes(\"Transformer\")) {\r\n                                let transformer;\r\n                                if (component.name) {\r\n                                    if (GraphicalTransformer.findTransformer(component.name)\r\n                                        .length > 0) {\r\n                                        transformer = GraphicalTransformer.findTransformer(component.name)[0];\r\n                                    }\r\n                                }\r\n                                if (!transformer)\r\n                                    transformer = GraphicalTransformer.initialize(component.comp, {\r\n                                        ...component,\r\n                                        sharedVar: {\r\n                                            ...(options.sharedVar || {}),\r\n                                            ...(component.sharedVar || {}),\r\n                                        },\r\n                                    });\r\n                                newPrevComponent.push(transformer);\r\n                                newPrevType = \"Transformer\";\r\n                            }\r\n                            else if (component.comp.includes(\"Service\")) {\r\n                                let service;\r\n                                if (component.name) {\r\n                                    if (Service.findService(component.name).length > 0) {\r\n                                        service = Service.findService(component.name)[0];\r\n                                    }\r\n                                }\r\n                                if (!service)\r\n                                    service = Service.initialize(component.comp, {\r\n                                        ...component,\r\n                                        ...(prevComponent\r\n                                            ? prevType == \"Transformer\"\r\n                                                ? {\r\n                                                    transformers: prevComponent instanceof Array\r\n                                                        ? prevComponent\r\n                                                        : [prevComponent],\r\n                                                }\r\n                                                : {\r\n                                                    services: prevComponent instanceof Array\r\n                                                        ? prevComponent\r\n                                                        : [prevComponent],\r\n                                                }\r\n                                            : {}),\r\n                                        sharedVar: {\r\n                                            ...(options.sharedVar || {}),\r\n                                            ...(component.sharedVar || {}),\r\n                                        },\r\n                                    });\r\n                                if (component.dimension &&\r\n                                    service instanceof SelectionService) {\r\n                                    service = service.dimension(component.dimension);\r\n                                    if (component.layers) {\r\n                                        service._layerInstances = component.layers.slice(0);\r\n                                    }\r\n                                    if (component.sharedVar) {\r\n                                        service.setSharedVars(component.sharedVar);\r\n                                    }\r\n                                }\r\n                                newPrevComponent.push(service);\r\n                                newPrevType = \"Service\";\r\n                            }\r\n                        }\r\n                        prevComponent = newPrevComponent;\r\n                        prevType = newPrevType;\r\n                    }\r\n                    else if (componentOption instanceof GraphicalTransformer) {\r\n                        prevComponent = componentOption;\r\n                        prevType = \"Transformer\";\r\n                    }\r\n                    else if (componentOption instanceof Service) {\r\n                        if (prevType == \"Transformer\") {\r\n                            componentOption._transformers.push(...(prevComponent instanceof Array\r\n                                ? prevComponent\r\n                                : [prevComponent]));\r\n                        }\r\n                        else {\r\n                            componentOption._services.push(...(prevComponent instanceof Array\r\n                                ? prevComponent\r\n                                : [prevComponent]));\r\n                        }\r\n                        prevComponent = componentOption;\r\n                        prevType = \"Service\";\r\n                    }\r\n                    else if (componentOption instanceof Command) {\r\n                        if (prevType == \"Service\") {\r\n                            if (prevComponent instanceof Array) {\r\n                                prevComponent.forEach((service) => service._command.push(componentOption));\r\n                            }\r\n                            else {\r\n                                prevComponent._command.push(componentOption);\r\n                            }\r\n                        }\r\n                    }\r\n                    else if (componentOption.comp.includes(\"Transformer\")) {\r\n                        let transformer;\r\n                        if (componentOption.name) {\r\n                            if (GraphicalTransformer.findTransformer(componentOption.name)\r\n                                .length > 0) {\r\n                                transformer = GraphicalTransformer.findTransformer(componentOption.name)[0];\r\n                            }\r\n                        }\r\n                        if (!transformer)\r\n                            transformer = GraphicalTransformer.initialize(componentOption.comp, {\r\n                                ...(options.layers && options.layers.length == 1\r\n                                    ? options.layers[0] instanceof Layer\r\n                                        ? { layer: options.layers[0] }\r\n                                        : { layer: options.layers[0].layer }\r\n                                    : {}),\r\n                                ...componentOption,\r\n                                sharedVar: {\r\n                                    ...(options.sharedVar || {}),\r\n                                    ...(componentOption.sharedVar || {}),\r\n                                },\r\n                            });\r\n                        prevComponent = transformer;\r\n                        prevType = \"Transformer\";\r\n                    }\r\n                    else if (componentOption.comp.includes(\"Service\")) {\r\n                        let service;\r\n                        if (componentOption.name) {\r\n                            if (Service.findService(componentOption.name).length > 0) {\r\n                                service = Service.findService(componentOption.name)[0];\r\n                            }\r\n                        }\r\n                        if (!service)\r\n                            service = Service.initialize(componentOption.comp, {\r\n                                ...(options.layers && options.layers.length == 1\r\n                                    ? options.layers[0] instanceof Layer\r\n                                        ? { layer: options.layers[0] }\r\n                                        : { layer: options.layers[0].layer }\r\n                                    : {}),\r\n                                ...componentOption,\r\n                                ...(prevComponent\r\n                                    ? prevType == \"Transformer\"\r\n                                        ? {\r\n                                            transformers: prevComponent instanceof Array\r\n                                                ? prevComponent\r\n                                                : [prevComponent],\r\n                                        }\r\n                                        : {\r\n                                            services: prevComponent instanceof Array\r\n                                                ? prevComponent\r\n                                                : [prevComponent],\r\n                                        }\r\n                                    : {}),\r\n                                sharedVar: {\r\n                                    ...(options.sharedVar || {}),\r\n                                    ...(componentOption.sharedVar || {}),\r\n                                },\r\n                            });\r\n                        if (componentOption.dimension &&\r\n                            service.isInstanceOf(\"SelectionService\")) {\r\n                            service = service.dimension(componentOption.dimension);\r\n                            if (componentOption.layers) {\r\n                                service._layerInstances = componentOption.layers.slice(0);\r\n                            }\r\n                            if (componentOption.sharedVar) {\r\n                                service.setSharedVars(componentOption.sharedVar);\r\n                            }\r\n                        }\r\n                        prevComponent = service;\r\n                        prevType = \"Service\";\r\n                    }\r\n                }\r\n                if (prevComponent) {\r\n                    if (prevType == \"Transformer\") {\r\n                        if (prevComponent instanceof Array) {\r\n                            insertNode._transformers.push(...prevComponent);\r\n                        }\r\n                        else {\r\n                            insertNode._transformers.push(prevComponent);\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (insertNode instanceof Instrument) {\r\n                            if (prevComponent instanceof Array) {\r\n                                insertNode._serviceInstances.push(...prevComponent);\r\n                            }\r\n                            else {\r\n                                insertNode._serviceInstances.push(prevComponent);\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (prevComponent instanceof Array) {\r\n                                insertNode._services.push(...prevComponent);\r\n                            }\r\n                            else {\r\n                                insertNode._services.push(prevComponent);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return instrument;\r\n    }\r\n}\r\n","import { Command } from \"./command\";\r\nimport { Instrument } from \"./instrument\";\r\nimport { Interactor } from \"./interactor\";\r\nimport { Layer } from \"./layer\";\r\nimport { Service } from \"./service\";\r\nimport { createHistoryTrrack } from \"./history\";\r\nimport { GraphicalTransformer } from \"./transformer\";\r\nimport { Interaction } from \"./interaction\";\r\nexport default {\r\n    Command,\r\n    Instrument,\r\n    Interactor,\r\n    Layer,\r\n    Service,\r\n    createHistoryTrrack,\r\n    GraphicalTransformer,\r\n    Interaction,\r\n};\r\nexport { Command } from \"./command\";\r\nexport { Instrument } from \"./instrument\";\r\nexport { Interactor } from \"./interactor\";\r\nexport { Layer } from \"./layer\";\r\nexport { Service } from \"./service\";\r\nexport { createHistoryTrrack } from \"./history\";\r\nexport { GraphicalTransformer } from \"./transformer\";\r\nexport { Interaction } from \"./interaction\";\r\n","import 'core-js/stable';\r\nimport 'regenerator-runtime/runtime';\r\nimport '../styles/index.scss';\r\nimport * as d3 from 'd3';\r\nimport Libra from 'libra-vis';\r\nimport mnistData from '../data/mnist_tsne.json';\r\n\r\n// constants\r\nconst MARGIN = { top: 30, right: 80, bottom: 40, left: 60 };\r\nconst WIDTH = 500 - MARGIN.left - MARGIN.right;\r\nconst HEIGHT = 400 - MARGIN.top - MARGIN.bottom;\r\nconst FIELD_X = \"x\";\r\nconst FIELD_Y = \"y\";\r\nconst FIELD_COLOR = \"label\";\r\n\r\n// shared state\r\nlet data = [];\r\nlet x = null;\r\nlet y = null;\r\nlet color = null;\r\n\r\n// dynamic field selection (updated by UI)\r\nlet currentFields = { xField: FIELD_X, yField: FIELD_Y, colorField: FIELD_COLOR, imageField: null };\r\n\r\n// UI elements\r\nlet fileInput, xFieldSelect, yFieldSelect, colorFieldSelect, imageFieldSelect, renderBtn, resetBtn, statusEl, rowCountEl;\r\n\r\nfunction $(id) {\r\n  return document.getElementById(id);\r\n}\r\n\r\nfunction setStatus(msg) {\r\n  if (statusEl) statusEl.textContent = msg || '';\r\n}\r\n\r\nfunction setRowCount(n) {\r\n  if (rowCountEl) rowCountEl.textContent = String(n || 0);\r\n}\r\n\r\nfunction clearSVG() {\r\n  const root = document.querySelector('#LibraPlayground');\r\n  if (root) root.innerHTML = '';\r\n}\r\n\r\nfunction clearSelect(selectEl, placeholderText) {\r\n  if (!selectEl) return;\r\n  while (selectEl.firstChild) selectEl.removeChild(selectEl.firstChild);\r\n  const opt = document.createElement('option');\r\n  opt.value = '';\r\n  opt.textContent = placeholderText || '';\r\n  selectEl.appendChild(opt);\r\n  selectEl.value = '';\r\n}\r\n\r\nfunction populateSelect(selectEl, options) {\r\n  if (!selectEl) return;\r\n  const frag = document.createDocumentFragment();\r\n  options.forEach((name) => {\r\n    const opt = document.createElement('option');\r\n    opt.value = name;\r\n    opt.textContent = name;\r\n    frag.appendChild(opt);\r\n  });\r\n  selectEl.appendChild(frag);\r\n}\r\n\r\nfunction inferFieldTypes(rows) {\r\n  if (!rows || !rows.length) return {};\r\n  const keysSet = new Set();\r\n  rows.forEach((row) => {\r\n    Object.keys(row).forEach((k) => keysSet.add(k));\r\n  });\r\n  const types = {};\r\n  keysSet.forEach((k) => {\r\n    let sawValue = false;\r\n    let allNumeric = true;\r\n    for (let i = 0; i < rows.length; i++) {\r\n      const v = rows[i][k];\r\n      if (v === null || v === undefined || v === '') continue; // ignore empties\r\n      sawValue = true;\r\n      const num = typeof v === 'number' ? v : (typeof v === 'string' ? Number(v) : NaN);\r\n      if (!Number.isFinite(num)) { allNumeric = false; break; }\r\n    }\r\n    types[k] = sawValue && allNumeric ? 'number' : 'string';\r\n  });\r\n  return types;\r\n}\r\n\r\nfunction uniqueValues(rows, field) {\r\n  const set = new Set();\r\n  rows.forEach((d) => {\r\n    const v = d[field];\r\n    if (v != null) set.add(v);\r\n  });\r\n  const arr = Array.from(set);\r\n  if (arr.length && typeof arr[0] === 'number') arr.sort((a, b) => a - b);\r\n  return arr;\r\n}\r\n\r\nasync function loadData() {\r\n  // import  JSON devserver  404\r\n  data = mnistData;\r\n}\r\n\r\nfunction renderStaticVisualization() {\r\n  // append the svg object to the body of the page\r\n  const svg = d3\r\n    .select(\"#LibraPlayground\")\r\n    .append(\"svg\")\r\n    .attr(\r\n      \"width\",\r\n      WIDTH + MARGIN.left + MARGIN.right\r\n    )\r\n    .attr(\r\n      \"height\",\r\n      HEIGHT + MARGIN.top + MARGIN.bottom\r\n    )\r\n    .attr(\"viewbox\", `0 0 ${WIDTH} ${HEIGHT}`)\r\n    .append(\"g\")\r\n    .attr(\r\n      \"transform\",\r\n      \"translate(\" + MARGIN.left + \",\" + MARGIN.top + \")\"\r\n    );\r\n\r\n  const extentX = [0, d3.max(data, (d) => d[FIELD_X])];\r\n  const extentY = [0, d3.max(data, (d) => d[FIELD_Y])];\r\n\r\n  // Add X axis\r\n  x = d3\r\n    .scaleLinear()\r\n    .domain(extentX)\r\n    .range([0, WIDTH])\r\n    .nice()\r\n    .clamp(true);\r\n\r\n  // Add Y axis\r\n  y = d3\r\n    .scaleLinear()\r\n    .domain(extentY)\r\n    .nice()\r\n    .range([0, HEIGHT])\r\n    .clamp(true);\r\n\r\n  // Add Legend\r\n  const categories = uniqueValues(data, FIELD_COLOR);\r\n\r\n  color = d3\r\n    .scaleOrdinal()\r\n    .domain(categories)\r\n    .range(d3.schemeTableau10);\r\n  svg\r\n    .append(\"g\")\r\n    .call((g) =>\r\n      g\r\n        .append(\"text\")\r\n        .text(FIELD_COLOR)\r\n        .attr(\"fill\", \"black\")\r\n        .attr(\"text-anchor\", \"middle\")\r\n        .attr(\"font-size\", \"12px\")\r\n        .attr(\"font-weight\", \"bold\")\r\n        .attr(\"x\", WIDTH + MARGIN.right / 2)\r\n        .attr(\"y\", -MARGIN.top / 2)\r\n    )\r\n    .call((g) =>\r\n      g\r\n        .append(\"g\")\r\n        .selectAll(\"g\")\r\n        .data(categories)\r\n        .join(\"g\")\r\n        .call((g) => {\r\n          g.append(\"circle\")\r\n            .attr(\"fill\", (d) => color(d))\r\n            .attr(\"cx\", WIDTH + 10)\r\n            .attr(\"cy\", (_, i) => i * 20)\r\n            .attr(\"r\", 5);\r\n        })\r\n        .call((g) => {\r\n          g.append(\"text\")\r\n            .text((d) => d)\r\n            .attr(\"font-size\", \"12px\")\r\n            .attr(\"x\", WIDTH + 20)\r\n            .attr(\"y\", (_, i) => i * 20 + 5);\r\n        })\r\n    );\r\n}\r\n\r\nasync function main() {\r\n  await loadData();\r\n  renderStaticVisualization();\r\n  const mainLayer = renderMainVisualization();\r\n  mountInteraction(mainLayer);\r\n}\r\n\r\nfunction renderMainVisualization() {\r\n  // Find the SVG element on page\r\n  const svg = d3.select(\"#LibraPlayground svg\");\r\n\r\n  // Create the main layer\r\n  const mainLayer = Libra.Layer.initialize(\"D3Layer\", {\r\n    name: \"mainLayer\",\r\n    width: WIDTH,\r\n    height: HEIGHT,\r\n    offset: { x: MARGIN.left, y: MARGIN.top },\r\n    container: svg.node(),\r\n  });\r\n  const g = d3.select(mainLayer.getGraphic());\r\n\r\n  // Draw points code from the input static visualization\r\n  g.selectAll(\"circle\")\r\n    .data(data)\r\n    .join(\"circle\")\r\n    .attr(\"class\", \"mark\")\r\n    .attr(\"cx\", (d) => x(d[FIELD_X]))\r\n    .attr(\"cy\", (d) => y(d[FIELD_Y]))\r\n    .attr(\"fill\", (d) => color(d[FIELD_COLOR]))\r\n    .attr(\"fill-opacity\", 0.7)\r\n    .attr(\"r\", 3);\r\n\r\n  return mainLayer;\r\n}\r\n\r\nasync function mountInteraction(layer) {\r\n  // Attach HoverInstrument to the main layer\r\nLibra.Interaction.build({\r\n    inherit: \"HoverInstrument\",\r\n    layers: [layer],\r\n    sharedVar: {\r\n      tooltip: {\r\n        image: (d) => d.image,\r\n        offset: {\r\n          x: -70 - MARGIN.left,\r\n          y: -100 - MARGIN.top,\r\n        },\r\n      },\r\n    },\r\n  });\r\n    Libra.Interaction.build({\r\n    inherit: \"ClickInstrument\",\r\n    layers: [layer],\r\n    remove: [\r\n      {\r\n        find: \"SelectionTransformer\",\r\n      },\r\n    ],\r\n    insert: [\r\n      {\r\n        find: \"SelectionService\",\r\n        flow: [\r\n          {\r\n            comp: \"FilterService\",\r\n            sharedVar: {\r\n              fields: [\"label\"],\r\n            },\r\n          },\r\n          {\r\n            comp: \"SelectionTransformer\",\r\n            layer: layer.getLayerFromQueue(\"selectionLayer\"),\r\n          },\r\n        ],\r\n      },\r\n    ],\r\n    sharedVar: {\r\n      highlightColor: (d) => color(d[FIELD_COLOR]),\r\n    },\r\n  });\r\n  await Libra.createHistoryTrrack();\r\n}\r\n\r\nmain();\r\n\r\n// dynamic rendering and UI binding\r\nfunction renderVisualizationDynamic(dataset, fields) {\r\n  clearSVG();\r\n  const { xField, yField, colorField } = fields;\r\n  const svg = d3\r\n    .select(\"#LibraPlayground\")\r\n    .append(\"svg\")\r\n    .attr(\r\n      \"width\",\r\n      WIDTH + MARGIN.left + MARGIN.right\r\n    )\r\n    .attr(\r\n      \"height\",\r\n      HEIGHT + MARGIN.top + MARGIN.bottom\r\n    )\r\n    .attr(\"viewbox\", `0 0 ${WIDTH} ${HEIGHT}`)\r\n    .append(\"g\")\r\n    .attr(\r\n      \"transform\",\r\n      \"translate(\" + MARGIN.left + \",\" + MARGIN.top + \")\"\r\n    );\r\n\r\n  const extentX = d3.extent(dataset, (d) => +d[xField]);\r\n  const extentY = d3.extent(dataset, (d) => +d[yField]);\r\n\r\n  x = d3\r\n    .scaleLinear()\r\n    .domain(extentX)\r\n    .range([0, WIDTH])\r\n    .nice()\r\n    .clamp(true);\r\n\r\n  y = d3\r\n    .scaleLinear()\r\n    .domain(extentY)\r\n    .nice()\r\n    .range([0, HEIGHT])\r\n    .clamp(true);\r\n\r\n  const categories = uniqueValues(dataset, colorField);\r\n  color = d3.scaleOrdinal().domain(categories).range(d3.schemeTableau10);\r\n\r\n  const legend = svg.append(\"g\");\r\n  legend\r\n    .append(\"text\")\r\n    .text(colorField)\r\n    .attr(\"fill\", \"black\")\r\n    .attr(\"text-anchor\", \"middle\")\r\n    .attr(\"font-size\", \"12px\")\r\n    .attr(\"font-weight\", \"bold\")\r\n    .attr(\"x\", WIDTH + MARGIN.right / 2)\r\n    .attr(\"y\", -MARGIN.top / 2);\r\n  legend\r\n    .append(\"g\")\r\n    .selectAll(\"g\")\r\n    .data(categories)\r\n    .join(\"g\")\r\n    .call((g) => {\r\n      g.append(\"circle\")\r\n        .attr(\"fill\", (d) => color(d))\r\n        .attr(\"cx\", WIDTH + 10)\r\n        .attr(\"cy\", (_, i) => i * 20)\r\n        .attr(\"r\", 5);\r\n    })\r\n    .call((g) => {\r\n      g.append(\"text\")\r\n        .text((d) => d)\r\n        .attr(\"font-size\", \"12px\")\r\n        .attr(\"x\", WIDTH + 20)\r\n        .attr(\"y\", (_, i) => i * 20 + 5);\r\n    });\r\n\r\n  // Draw points\r\n  const mainLayer = Libra.Layer.initialize(\"D3Layer\", {\r\n    name: \"mainLayer\",\r\n    width: WIDTH,\r\n    height: HEIGHT,\r\n    offset: { x: MARGIN.left, y: MARGIN.top },\r\n    container: d3.select(\"#LibraPlayground svg\").node(),\r\n  });\r\n  const g = d3.select(mainLayer.getGraphic());\r\n\r\n  g.selectAll(\"circle\")\r\n    .data(dataset)\r\n    .join(\"circle\")\r\n    .attr(\"class\", \"mark\")\r\n    .attr(\"cx\", (d) => x(+d[xField]))\r\n    .attr(\"cy\", (d) => y(+d[yField]))\r\n    .attr(\"fill\", (d) => color(d[colorField]))\r\n    .attr(\"fill-opacity\", 0.7)\r\n    .attr(\"r\", 3);\r\n\r\n  // Interaction\r\n  Libra.Interaction.build({\r\n    inherit: \"HoverInstrument\",\r\n    layers: [mainLayer],\r\n    sharedVar: {\r\n      tooltip: {\r\n        image: (d) => d.image,\r\n        offset: {\r\n          x: -70 - MARGIN.left,\r\n          y: -100 - MARGIN.top,\r\n        },\r\n      },\r\n    },\r\n  });\r\n    Libra.Interaction.build({\r\n    inherit: \"ClickInstrument\",\r\n    layers: [mainLayer],\r\n    remove: [\r\n      {\r\n        find: \"SelectionTransformer\",\r\n      },\r\n    ],\r\n    insert: [\r\n      {\r\n        find: \"SelectionService\",\r\n        flow: [\r\n          {\r\n            comp: \"FilterService\",\r\n            sharedVar: {\r\n              fields: [\"label\"],\r\n            },\r\n          },\r\n          {\r\n            comp: \"SelectionTransformer\",\r\n            layer: mainLayer.getLayerFromQueue(\"selectionLayer\"),\r\n          },\r\n        ],\r\n      },\r\n    ],\r\n    sharedVar: {\r\n      highlightColor: (d) => color(d[FIELD_COLOR]),\r\n    },\r\n  });\r\n  \r\n}\r\n\r\nfunction bindUI() {\r\n  fileInput = $(\"fileInput\");\r\n  xFieldSelect = $(\"xField\");\r\n  yFieldSelect = $(\"yField\");\r\n  colorFieldSelect = $(\"colorField\");\r\n  imageFieldSelect = $(\"imageField\");\r\n  renderBtn = $(\"renderBtn\");\r\n  resetBtn = $(\"resetBtn\");\r\n  statusEl = $(\"status\");\r\n  rowCountEl = $(\"rowCount\");\r\n\r\n  clearSelect(xFieldSelect, \"X \");\r\n  clearSelect(yFieldSelect, \"Y \");\r\n  clearSelect(colorFieldSelect, \"\");\r\n  clearSelect(imageFieldSelect, \"\");\r\n  if (renderBtn) renderBtn.disabled = true;\r\n  setStatus(\"\");\r\n  setRowCount(data.length || 0);\r\n\r\n  if (fileInput) {\r\n    fileInput.addEventListener(\"change\", async (e) => {\r\n      const file = e.target.files && e.target.files[0];\r\n      if (!file) return;\r\n      try {\r\n        const text = await file.text();\r\n        let parsed = [];\r\n        if (/\\.csv$/i.test(file.name)) {\r\n          parsed = d3.csvParse(text);\r\n        } else {\r\n          const json = JSON.parse(text);\r\n          parsed = Array.isArray(json) ? json : (Array.isArray(json.data) ? json.data : []);\r\n        }\r\n        if (!parsed.length) throw new Error(\"\");\r\n        data = parsed;\r\n        const types = inferFieldTypes(parsed);\r\n        const allKeys = Object.keys(types);\r\n        const numericFields = allKeys.filter((k) => types[k] === \"number\");\r\n        const stringFields = allKeys.filter((k) => types[k] === \"string\");\r\n\r\n        clearSelect(xFieldSelect, \"X \");\r\n        clearSelect(yFieldSelect, \"Y \");\r\n        clearSelect(colorFieldSelect, \"\");\r\n        clearSelect(imageFieldSelect, \"\");\r\n        populateSelect(xFieldSelect, numericFields.length ? numericFields : allKeys);\r\n        populateSelect(yFieldSelect, numericFields.length ? numericFields : allKeys);\r\n        populateSelect(colorFieldSelect, allKeys);\r\n        populateSelect(imageFieldSelect, stringFields);\r\n\r\n        // auto-select defaults if present\r\n        const prefer = (sel, name) => {\r\n          if (!sel) return false;\r\n          const opt = Array.from(sel.options).find((o) => o.value === name);\r\n          if (opt) sel.value = name;\r\n          return !!opt;\r\n        };\r\n        if (!prefer(xFieldSelect, FIELD_X) && xFieldSelect.options.length > 1) xFieldSelect.selectedIndex = 1;\r\n        if (!prefer(yFieldSelect, FIELD_Y) && yFieldSelect.options.length > 1) yFieldSelect.selectedIndex = 1;\r\n        if (!prefer(colorFieldSelect, FIELD_COLOR) && colorFieldSelect.options.length > 1) colorFieldSelect.selectedIndex = 1;\r\n        const imgCandidates = [\"image\", \"img\", \"url\", \"picture\"];\r\n        const imgAuto = imgCandidates.find((n) => stringFields.includes(n));\r\n        if (imgAuto) imageFieldSelect.value = imgAuto;\r\n\r\n        currentFields.xField = xFieldSelect.value || FIELD_X;\r\n        currentFields.yField = yFieldSelect.value || FIELD_Y;\r\n        currentFields.colorField = colorFieldSelect.value || FIELD_COLOR;\r\n        currentFields.imageField = imageFieldSelect.value || null;\r\n\r\n        setRowCount(data.length);\r\n        setStatus(\"\");\r\n        if (renderBtn) renderBtn.disabled = !(currentFields.xField && currentFields.yField && currentFields.colorField);\r\n      } catch (err) {\r\n        console.error(err);\r\n        setStatus(\"\" + err.message);\r\n        setRowCount(0);\r\n        if (renderBtn) renderBtn.disabled = true;\r\n      }\r\n    });\r\n  }\r\n\r\n  if (xFieldSelect) xFieldSelect.addEventListener(\"change\", () => { currentFields.xField = xFieldSelect.value; if (renderBtn) renderBtn.disabled = !(currentFields.xField && currentFields.yField && currentFields.colorField); });\r\n  if (yFieldSelect) yFieldSelect.addEventListener(\"change\", () => { currentFields.yField = yFieldSelect.value; if (renderBtn) renderBtn.disabled = !(currentFields.xField && currentFields.yField && currentFields.colorField); });\r\n  if (colorFieldSelect) colorFieldSelect.addEventListener(\"change\", () => { currentFields.colorField = colorFieldSelect.value; if (renderBtn) renderBtn.disabled = !(currentFields.xField && currentFields.yField && currentFields.colorField); });\r\n  if (imageFieldSelect) imageFieldSelect.addEventListener(\"change\", () => { currentFields.imageField = imageFieldSelect.value || null; });\r\n\r\n  if (renderBtn) {\r\n    renderBtn.addEventListener(\"click\", () => {\r\n      if (!(currentFields.xField && currentFields.yField && currentFields.colorField)) {\r\n        setStatus(\" X/Y/ \");\r\n        return;\r\n      }\r\n      renderVisualizationDynamic(data, currentFields);\r\n      setStatus(\"\");\r\n    });\r\n  }\r\n\r\n  if (resetBtn) {\r\n    resetBtn.addEventListener(\"click\", () => {\r\n      if (fileInput) fileInput.value = \"\"; //  change\r\n      clearSelect(xFieldSelect, \"X \");\r\n      clearSelect(yFieldSelect, \"Y \");\r\n      clearSelect(colorFieldSelect, \"\");\r\n      clearSelect(imageFieldSelect, \"\");\r\n      if (renderBtn) renderBtn.disabled = true;\r\n      setStatus(\"\");\r\n      setRowCount(0);\r\n      clearSVG();\r\n      // reset state\r\n      currentFields = { xField: FIELD_X, yField: FIELD_Y, colorField: FIELD_COLOR, imageField: null };\r\n    });\r\n  }\r\n}\r\n\r\n// bind UI after initial render\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n  try { bindUI(); } catch (e) { console.error(e); }\r\n});","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t143: 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = function(chunkId) { return installedChunks[chunkId] === 0; };\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = function(parentChunkLoadingFunction, data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkwebpack_starter\"] = self[\"webpackChunkwebpack_starter\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [109], function() { return __webpack_require__(29796); })\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n"],"names":["deferred","_a","tryGetHistoryTrrackInstance","registeredCommands","instanceCommands","Command","constructor","baseName","options","this","preInitialize","call","_baseName","_userOptions","_name","name","_feedback","feedback","_undo","undo","_redo","redo","_execute","execute","_preInitialize","_postInitialize","postInitialize","_preExecute","preExecute","_postExecute","postExecute","async","commit","e","console","error","isInstanceOf","static","mergedOptions","Object","assign","command","push","baseNameOrRealName","filter","helpers","register","initialize","findCommand","then","HM","CommandConstructor","CommandClass","LibraSymbol","Symbol","QueryType","ShapeQueryType","DataQueryType","NonsenseClass","tryRegisterDynamicInstance","args","makeFindableList","list","typing","addFunc","removeFunc","self","Proxy","get","target","p","defaultValue","filteredResult","item","length","newElement","slice","forEach","newTarget","find","arguments","add","remove","origin","splice","indexOf","Function","map","t","apply","f","iterator","getTransform","elem","getAttribute","split","i","parseFloat","parseEventSelector","selector","parseMerge","trim","parseSelector","ILLEGAL","MARKS","arc","area","group","image","line","path","rect","rule","shape","symbol","text","trail","s","endChar","pushChar","popChar","c","count","n","output","start","LBRACK","RBRACK","substring","b","stream","bt","between","parseBetween","source","type","j","throttle","markname","lastIndexOf","a","_","x","parseThrottle","test","hasOwnProperty","marktype","consume","debounce","parseStream","deepClone","obj","copy","nodeCopy","key","getOwnPropertyDescriptors","Array","includes","Node","cloneNode","propertyObject","fromEntries","entries","k","v","create","getPrototypeOf","global","stopTransient","historyInstanceMapping","Map","createHistoryTrrack","historyTrace","currentHistoryNode","commitLock","HistoryManager","traceStructure","node","recordList","record","keys","children","current","component","fields","instanceInteractors","instanceInstruments","instanceServices","instanceTransformers","flatMap","results","set","field","commandName","checkParent","historyNode","prev","newHistoryNode","next","records","layerHold","_sharedVar","layer","setSharedVar","undefined","targetNode","reduce","join","has","parentComponent","newComponent","Instrument","interactors","on","hover","event","instrument","changedTouches","services","setSharedVars","clientX","y","clientY","offsetx","offsetX","offsety","offsetY","transformers","cx","cy","click","sharedVar","getSharedVar","highlightColor","highlightAttrValues","tooltip","preAttach","data","dragstart","emit","dragend","dragabort","width","height","startx","starty","startoffsetx","startoffsety","currentx","currenty","layerOffsetX","_offset","layerOffsetY","scaleX","scaleY","invert","newExtentX","newExtentY","drag","Math","min","abs","endx","endy","getLayerFromQueue","orientation","style","layerPos","d3","getGraphic","continuous","newExtentDataX","newExtentDataY","log","Promise","all","attrNameX","extentX","extentXData","attrNameY","extentY","extentYData","reverse","transient","fill","opacity","layerPosX","newExtent","startLayerPosX","_height","attrName","extent","extentData","offset","skipPicking","begin","left","speed","helperBar","querySelector","newX","setAttribute","right","focus","startPos","transientLayer","document","createElementNS","append","GraphicalTransformer","transformer","sx","sy","fixRange","scaleXOrigin","newDomain","range","domain","scaleYOrigin","newRangeX","newRangeY","wheel","layerGraphic","delta","deltaY","cumulativeDelta","offsetXDomain","d","Date","getTime","exp","offsetYDomain","abort","currentLevel","scaleLevels","sign","closestLevel","curr","parseInt","postUse","InstrumentConstructor","InstrumentClass","registeredInstruments","EventDispatcher","EventQueue","eventHandling","_transformers","_linkCache","_preAttach","_postUse","_on","_interactors","_layers","_layerInteractors","_services","_serviceInstances","interactor","useInteractor","Interactor","service","useService","layers","attach","action","feedforwardOrCommand","invokeCommand","off","_use","findService","preUse","layr","Layer","copyInteractor","setActions","getActions","sideEffect","getAcceptEvents","getContainerGraphic","addEventListener","_dispatch","bind","l","sharedName","value","watchSharedVar","handler","inter","preventDefault","stopPropagation","stopImmediatePropagation","existingEventIndex","findIndex","eventType","_order","sort","handled","layerOption","MouseEvent","toLowerCase","replaceAll","pointerEvents","picking","baseOn","_state","maybeD3Layer","_width","dispatch","eventDescription","shift","graphic","Service","Error","findInstrument","state","actions","events","transition","InteractorClass","SR","window","SpeechRecognition","webkitSpeechRecognition","SGL","SpeechGrammarList","webkitSpeechGrammarList","registeredInteractors","_actions","transferInteractorInnerAction","_modalities","_preUse","enableModality","modal","recognition","speechRecognitionList","addFromString","grammars","lang","disableModality","speech","onresult","onend","mergeActions","concat","_parseEvent","flatStream","Set","eventStreams","eventStream","moveAction","es","inculdeEvent","Event","some","filterFuncs","every","moveTransition","startsWith","result","resultIndex","transcript","originAction","evtSelector","transferEventStream","registeredLayers","instanceLayers","siblingLayers","orderLayers","_nextTick","_container","container","_preUpdate","preUpdate","_postUpdate","postUpdate","_graphic","getVisualElements","cloneVisualElements","element","deep","copiedElement","createDocumentFragment","__libra__screenElement","getDatum","rightTable","joinKey","isPointInPolygon","point","polygon","inside","xi","yi","xj","yj","pathIntersectsRect","pathLength","getTotalLength","step","getPointAtLength","siblingLayerName","siblings","redraw","setLayersOrder","layerNameOrderKVPairs","orders","frag","layerName","order","display","appendChild","findLayer","backgroundClassName","D3Layer","super","g","attr","tempElem","tagName","parentElement","_svg","datum","querySelectorAll","clone","select","_shapeQuery","_dataQuery","_attrQuery","_isElementInLayer","contains","classList","svgBCR","getBoundingClientRect","isFinite","elementsFromPoint","top","r","innerRectWidth","floor","sin","PI","innerRectX","innerRectY","elemSet","innerRect","createSVGRect","getIntersectionList","zeroStrokeWidthPaths","getComputedStyle","transformedRect","transformRect","outerRectWidth","outerRectX","outerRectY","outerElemSet","outerRect","outer","delete","size","w","sqrt","pow","topRect","bottomRect","leftRect","rightRect","x0","y0","absWidth","absHeight","customIntersectingPaths","points","adjustedPoints","queryLargestRectangles","from","resultWithSVGGElement","visualElements","intermediateResult","ext","nodes","dateParser","referenceElement","boundingBox","getBoundingBox","maxX","minX","maxY","minY","queryPolygon","largestRect","findLargestRectangle","zeroFillPaths","subtractRectFromPolygon","Infinity","max","largestArea","h","isRectangleInPolygon","corner","remainingPoints","rectCorners","bbox","getBBox","pathIntersectsPolygon","VegaLayer","matrixStr","currDom","matrix","compose","fromDefinition","fromTransformAttribute","real","el","currentElement","transform","bottom","rawX","rawY","circleDistanceX","circleDistanceY","PlotLayer","x1","y1","LayerClass","LayoutService","resultAlias","evaluate","scaleX_Overview","scaleY_Overview","layerInstance","_layerInstances","isNaN","scaleXCopy","startX","endX","clamp","scaleYCopy","startY","endY","AnalysisService","extents","layerInstances","childNodes","formula","fieldValue","interpolatedNum","baseNum","newValue","newInterpolatedData","nextNum","interpolate","baseDatum","nextDatum","fieldX","fieldY","replace","datumBackup","newData","operation","sum","doms","domData","xField","yField","xValues","yValues","xMean","yMean","slope","intercept","ServiceConstructor","ServiceClass","SelectionService","_currentDimension","_resultAlias","_selectionMapping","query","tempRect","toString","removeChild","requestAnimationFrame","_evaluate","_oldResult","_result","selectionLayer","firstChild","lastChild","resultNodes","refNodes","refNode","resultNode","passive","dimension","formatter","dimArr","fmtArr","zipArr","scopeSharedVar","scopeLayerInstances","receiver","values","ex","dim","registeredServices","joining","_joinTransformers","_joinServices","_initializing","_computing","_command","joinTransformers","joinServices","entry","params","_internalResults","res","oldCachedResults","oldResults","registeredTransformers","transientQueue","transientCleaner","transientElement","pop","_transient","_redraw","_layer","preDrawElements","postDrawElements","changedLayers","_getLayerFromQueue","prototype","transientElements","className","unregister","findTransformer","selectAll","x2","elems","attrValueEntries","tooltipQueue","shouldDisplay","prefix","displayContent","queueArray","subArray","suffix","tooltipText","position","tooltipArrayIndex","tooltipPrefix","tooltipArray","tooltipSuffix","str","mainLayer","tooltipConfig","tooltipOffsetX","tooltipOffsetY","content","displayX","displayY","TransformerConstructor","TransformerClass","registeredInteractions","Interaction","inherit","inheritOption","build","findNested","parent","findType","findNestedReference","removeOption","removeNode","parentNode","parentServiceArray","cascade","override","overrideOption","endsWith","interactorsList","removeNodes","comp","newInteractor","replaceNode","insert","insertNode","prevComponent","prevType","flow","componentOption","newPrevComponent","newPrevType","generatedOption","fileInput","xFieldSelect","yFieldSelect","colorFieldSelect","imageFieldSelect","renderBtn","resetBtn","statusEl","rowCountEl","MARGIN","WIDTH","HEIGHT","FIELD_X","FIELD_Y","FIELD_COLOR","color","currentFields","colorField","imageField","$","id","getElementById","setStatus","msg","textContent","setRowCount","String","clearSVG","root","innerHTML","clearSelect","selectEl","placeholderText","opt","createElement","populateSelect","inferFieldTypes","rows","keysSet","row","types","sawValue","allNumeric","num","Number","NaN","uniqueValues","arr","loadData","mnistData","renderStaticVisualization","svg","nice","categories","mountInteraction","renderMainVisualization","Libra","main","disabled","file","files","parsed","json","JSON","parse","isArray","allKeys","numericFields","stringFields","prefer","sel","o","selectedIndex","imgAuto","message","dataset","legend","renderVisualizationDynamic","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","O","chunkIds","fn","priority","notFulfilled","fulfilled","definition","defineProperty","enumerable","globalThis","prop","toStringTag","installedChunks","chunkId","webpackJsonpCallback","parentChunkLoadingFunction","moreModules","runtime","chunkLoadingGlobal","__webpack_exports__"],"sourceRoot":""}